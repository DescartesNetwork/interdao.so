/*! For license information please see vendors-node_modules_senswap_sen-js_dist_utils_js-node_modules_base64-js_index_js-node_module-343e97.698453ea.chunk.js.LICENSE.txt */
(globalThis.webpackChunkinterdao=globalThis.webpackChunkinterdao||[]).push([["vendors-node_modules_senswap_sen-js_dist_utils_js-node_modules_base64-js_index_js-node_module-343e97"],{65967:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),s=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.NOISE=void 0;const i=r(28705);s(r(28705),t),t.NOISE=new i.Noise},40106:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(48839),s=r(48744),i=r(71256),o=new s("1000000000"),a={BASIC_TX_FEE:5e-6,LAMPORTS_PER_SOL:i.LAMPORTS_PER_SOL,parseCGK:async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";if(!e)throw new Error("Ticket is empty");const{data:{image:{large:t,small:r,thumb:s},symbol:i,name:o,platforms:{solana:a},market_cap_rank:c,market_data:{current_price:{usd:l},total_volume:{usd:u},price_change_percentage_24h:d}}}=await(0,n.default)({method:"get",url:"https://api.coingecko.com/api/v3/coins/"+e}),h=t||s||r,p=i.toUpperCase();return{icon:h,symbol:p,name:o,address:a,rank:c,price:l,priceChange:d,totalVolume:u}},decimalize:(e,t)=>{if(!e)return BigInt(0);if(t<0||t%1!=0)throw new Error("decimals must be an integer greater than zero");const r=e.toString();if(!t)return BigInt(r);const n=r.split(".");if(n.length>2)throw new Error("Invalid number");return 1==n.length?BigInt(e)*BigInt(10**t):n[1].length>=t?BigInt(n[0]+n[1].substring(0,t)):BigInt(n[0]+n[1]+"0".repeat(t-n[1].length))},undecimalize:(e,t)=>{if(t<0||t%1!=0)throw new Error("decimals must be an integer greater than zero");if(!e)return"0";const r=e.toString();if(!t)return r;let n=r.length>t?r.substring(0,r.length-t):"0",s="";for(s=r.length>t?r.substring(r.length-t,r.length):r.length==t?r:"0".repeat(t-r.length)+r,s=s.split("");"0"===s[s.length-1];)s.pop();return s=s.join(""),s?n+"."+s:n},div:(e,t)=>{if(!t)throw new Error("Cannot be divided by 0");if(!e)return 0;const r=new s(e.toString()),n=new s(t.toString()),i=r.mul(o).div(n).toString();return i.length>9?parseFloat(i.substring(0,i.length-9)+"."+i.substring(i.length-9,i.length)):parseFloat("0."+"0".repeat(9-i.length)+i)},wrappedGetMultipleAccountsInfo:async(e,t,r)=>{const n=t.length,s=Math.floor(n/99)+1;let i=[];for(let o=0;o<s;o++){const n=t.slice(99*o,99*(o+1)),s=await e.getMultipleAccountsInfo(n,r);s&&(i=i.concat(s))}return i}};t.default=a},71256:(e,t,r)=>{"use strict";r.r(t),r.d(t,{Account:()=>Gt,Authorized:()=>Is,BLOCKHASH_CACHE_TIMEOUT_MS:()=>Xr,BPF_LOADER_DEPRECATED_PROGRAM_ID:()=>Vt,BPF_LOADER_PROGRAM_ID:()=>Dr,BpfLoader:()=>Br,COMPUTE_BUDGET_INSTRUCTION_LAYOUTS:()=>Nr,ComputeBudgetInstruction:()=>xr,ComputeBudgetProgram:()=>Or,Connection:()=>bs,Ed25519Program:()=>ks,Enum:()=>jt,EpochSchedule:()=>Wr,FeeCalculatorLayout:()=>vr,Keypair:()=>vs,LAMPORTS_PER_SOL:()=>Zs,Loader:()=>Tr,Lockup:()=>Ss,MAX_SEED_LENGTH:()=>zt,Message:()=>tr,NONCE_ACCOUNT_LENGTH:()=>kr,NonceAccount:()=>Er,PACKET_DATA_SIZE:()=>Xt,PublicKey:()=>Wt,SIGNATURE_LENGTH_IN_BYTES:()=>Jt,SOLANA_SCHEMA:()=>Ut,STAKE_CONFIG_ID:()=>Es,STAKE_INSTRUCTION_LAYOUTS:()=>As,SYSTEM_INSTRUCTION_LAYOUTS:()=>Ar,SYSVAR_CLOCK_PUBKEY:()=>ar,SYSVAR_EPOCH_SCHEDULE_PUBKEY:()=>cr,SYSVAR_INSTRUCTIONS_PUBKEY:()=>lr,SYSVAR_RECENT_BLOCKHASHES_PUBKEY:()=>ur,SYSVAR_RENT_PUBKEY:()=>dr,SYSVAR_REWARDS_PUBKEY:()=>hr,SYSVAR_SLOT_HASHES_PUBKEY:()=>pr,SYSVAR_SLOT_HISTORY_PUBKEY:()=>fr,SYSVAR_STAKE_HISTORY_PUBKEY:()=>gr,Secp256k1Program:()=>xs,SendTransactionError:()=>$r,StakeAuthorizationLayout:()=>Rs,StakeInstruction:()=>Ps,StakeProgram:()=>Cs,Struct:()=>Mt,SystemInstruction:()=>Pr,SystemProgram:()=>Rr,Transaction:()=>or,TransactionExpiredBlockheightExceededError:()=>Kr,TransactionExpiredTimeoutError:()=>qr,TransactionInstruction:()=>ir,TransactionStatus:()=>nr,VALIDATOR_INFO_KEY:()=>Ns,VOTE_PROGRAM_ID:()=>Ms,ValidatorInfo:()=>Ls,VoteAccount:()=>Us,VoteAuthorizationLayout:()=>Hs,VoteInit:()=>Fs,VoteInstruction:()=>Ks,VoteProgram:()=>Gs,clusterApiUrl:()=>Js,sendAndConfirmRawTransaction:()=>Vs,sendAndConfirmTransaction:()=>yr});var n=r(44967),s=r.n(n),i=r(97713),o=r(48744),a=r.n(o),c=r(68532),l=r.n(c),u=r(4306),d=r(25047),h=r(68706),p=r(54338),f=r(85606),g=r(32908),y=r.n(g),m=r(91747),w=r.n(m),b=r(16348),v=r.n(b);const _=e=>i.Buffer.isBuffer(e)?e:e instanceof Uint8Array?i.Buffer.from(e.buffer,e.byteOffset,e.byteLength):i.Buffer.from(e);var k={},E={},I=S;function S(e,t){if(!e)throw new Error(t||"Assertion failed")}S.equal=function(e,t,r){if(e!=t)throw new Error(r||"Assertion failed: "+e+" != "+t)};var P={exports:{}};"function"===typeof Object.create?P.exports=function(e,t){t&&(e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}))}:P.exports=function(e,t){if(t){e.super_=t;var r=function(){};r.prototype=t.prototype,e.prototype=new r,e.prototype.constructor=e}};var A=I,R=P.exports;function C(e,t){return 55296===(64512&e.charCodeAt(t))&&(!(t<0||t+1>=e.length)&&56320===(64512&e.charCodeAt(t+1)))}function T(e){return(e>>>24|e>>>8&65280|e<<8&16711680|(255&e)<<24)>>>0}function D(e){return 1===e.length?"0"+e:e}function B(e){return 7===e.length?"0"+e:6===e.length?"00"+e:5===e.length?"000"+e:4===e.length?"0000"+e:3===e.length?"00000"+e:2===e.length?"000000"+e:1===e.length?"0000000"+e:e}E.inherits=R,E.toArray=function(e,t){if(Array.isArray(e))return e.slice();if(!e)return[];var r=[];if("string"===typeof e)if(t){if("hex"===t)for((e=e.replace(/[^a-z0-9]+/gi,"")).length%2!==0&&(e="0"+e),s=0;s<e.length;s+=2)r.push(parseInt(e[s]+e[s+1],16))}else for(var n=0,s=0;s<e.length;s++){var i=e.charCodeAt(s);i<128?r[n++]=i:i<2048?(r[n++]=i>>6|192,r[n++]=63&i|128):C(e,s)?(i=65536+((1023&i)<<10)+(1023&e.charCodeAt(++s)),r[n++]=i>>18|240,r[n++]=i>>12&63|128,r[n++]=i>>6&63|128,r[n++]=63&i|128):(r[n++]=i>>12|224,r[n++]=i>>6&63|128,r[n++]=63&i|128)}else for(s=0;s<e.length;s++)r[s]=0|e[s];return r},E.toHex=function(e){for(var t="",r=0;r<e.length;r++)t+=D(e[r].toString(16));return t},E.htonl=T,E.toHex32=function(e,t){for(var r="",n=0;n<e.length;n++){var s=e[n];"little"===t&&(s=T(s)),r+=B(s.toString(16))}return r},E.zero2=D,E.zero8=B,E.join32=function(e,t,r,n){var s=r-t;A(s%4===0);for(var i=new Array(s/4),o=0,a=t;o<i.length;o++,a+=4){var c;c="big"===n?e[a]<<24|e[a+1]<<16|e[a+2]<<8|e[a+3]:e[a+3]<<24|e[a+2]<<16|e[a+1]<<8|e[a],i[o]=c>>>0}return i},E.split32=function(e,t){for(var r=new Array(4*e.length),n=0,s=0;n<e.length;n++,s+=4){var i=e[n];"big"===t?(r[s]=i>>>24,r[s+1]=i>>>16&255,r[s+2]=i>>>8&255,r[s+3]=255&i):(r[s+3]=i>>>24,r[s+2]=i>>>16&255,r[s+1]=i>>>8&255,r[s]=255&i)}return r},E.rotr32=function(e,t){return e>>>t|e<<32-t},E.rotl32=function(e,t){return e<<t|e>>>32-t},E.sum32=function(e,t){return e+t>>>0},E.sum32_3=function(e,t,r){return e+t+r>>>0},E.sum32_4=function(e,t,r,n){return e+t+r+n>>>0},E.sum32_5=function(e,t,r,n,s){return e+t+r+n+s>>>0},E.sum64=function(e,t,r,n){var s=e[t],i=n+e[t+1]>>>0,o=(i<n?1:0)+r+s;e[t]=o>>>0,e[t+1]=i},E.sum64_hi=function(e,t,r,n){return(t+n>>>0<t?1:0)+e+r>>>0},E.sum64_lo=function(e,t,r,n){return t+n>>>0},E.sum64_4_hi=function(e,t,r,n,s,i,o,a){var c=0,l=t;return c+=(l=l+n>>>0)<t?1:0,c+=(l=l+i>>>0)<i?1:0,e+r+s+o+(c+=(l=l+a>>>0)<a?1:0)>>>0},E.sum64_4_lo=function(e,t,r,n,s,i,o,a){return t+n+i+a>>>0},E.sum64_5_hi=function(e,t,r,n,s,i,o,a,c,l){var u=0,d=t;return u+=(d=d+n>>>0)<t?1:0,u+=(d=d+i>>>0)<i?1:0,u+=(d=d+a>>>0)<a?1:0,e+r+s+o+c+(u+=(d=d+l>>>0)<l?1:0)>>>0},E.sum64_5_lo=function(e,t,r,n,s,i,o,a,c,l){return t+n+i+a+l>>>0},E.rotr64_hi=function(e,t,r){return(t<<32-r|e>>>r)>>>0},E.rotr64_lo=function(e,t,r){return(e<<32-r|t>>>r)>>>0},E.shr64_hi=function(e,t,r){return e>>>r},E.shr64_lo=function(e,t,r){return(e<<32-r|t>>>r)>>>0};var x={},N=E,O=I;function L(){this.pending=null,this.pendingTotal=0,this.blockSize=this.constructor.blockSize,this.outSize=this.constructor.outSize,this.hmacStrength=this.constructor.hmacStrength,this.padLength=this.constructor.padLength/8,this.endian="big",this._delta8=this.blockSize/8,this._delta32=this.blockSize/32}x.BlockHash=L,L.prototype.update=function(e,t){if(e=N.toArray(e,t),this.pending?this.pending=this.pending.concat(e):this.pending=e,this.pendingTotal+=e.length,this.pending.length>=this._delta8){var r=(e=this.pending).length%this._delta8;this.pending=e.slice(e.length-r,e.length),0===this.pending.length&&(this.pending=null),e=N.join32(e,0,e.length-r,this.endian);for(var n=0;n<e.length;n+=this._delta32)this._update(e,n,n+this._delta32)}return this},L.prototype.digest=function(e){return this.update(this._pad()),O(null===this.pending),this._digest(e)},L.prototype._pad=function(){var e=this.pendingTotal,t=this._delta8,r=t-(e+this.padLength)%t,n=new Array(r+this.padLength);n[0]=128;for(var s=1;s<r;s++)n[s]=0;if(e<<=3,"big"===this.endian){for(var i=8;i<this.padLength;i++)n[s++]=0;n[s++]=0,n[s++]=0,n[s++]=0,n[s++]=0,n[s++]=e>>>24&255,n[s++]=e>>>16&255,n[s++]=e>>>8&255,n[s++]=255&e}else for(n[s++]=255&e,n[s++]=e>>>8&255,n[s++]=e>>>16&255,n[s++]=e>>>24&255,n[s++]=0,n[s++]=0,n[s++]=0,n[s++]=0,i=8;i<this.padLength;i++)n[s++]=0;return n};var M={},j={},U=E.rotr32;function z(e,t,r){return e&t^~e&r}function W(e,t,r){return e&t^e&r^t&r}function $(e,t,r){return e^t^r}j.ft_1=function(e,t,r,n){return 0===e?z(t,r,n):1===e||3===e?$(t,r,n):2===e?W(t,r,n):void 0},j.ch32=z,j.maj32=W,j.p32=$,j.s0_256=function(e){return U(e,2)^U(e,13)^U(e,22)},j.s1_256=function(e){return U(e,6)^U(e,11)^U(e,25)},j.g0_256=function(e){return U(e,7)^U(e,18)^e>>>3},j.g1_256=function(e){return U(e,17)^U(e,19)^e>>>10};var F=E,K=x,q=j,H=F.rotl32,G=F.sum32,V=F.sum32_5,X=q.ft_1,J=K.BlockHash,Z=[1518500249,1859775393,2400959708,3395469782];function Y(){if(!(this instanceof Y))return new Y;J.call(this),this.h=[1732584193,4023233417,2562383102,271733878,3285377520],this.W=new Array(80)}F.inherits(Y,J);var Q=Y;Y.blockSize=512,Y.outSize=160,Y.hmacStrength=80,Y.padLength=64,Y.prototype._update=function(e,t){for(var r=this.W,n=0;n<16;n++)r[n]=e[t+n];for(;n<r.length;n++)r[n]=H(r[n-3]^r[n-8]^r[n-14]^r[n-16],1);var s=this.h[0],i=this.h[1],o=this.h[2],a=this.h[3],c=this.h[4];for(n=0;n<r.length;n++){var l=~~(n/20),u=V(H(s,5),X(l,i,o,a),c,r[n],Z[l]);c=a,a=o,o=H(i,30),i=s,s=u}this.h[0]=G(this.h[0],s),this.h[1]=G(this.h[1],i),this.h[2]=G(this.h[2],o),this.h[3]=G(this.h[3],a),this.h[4]=G(this.h[4],c)},Y.prototype._digest=function(e){return"hex"===e?F.toHex32(this.h,"big"):F.split32(this.h,"big")};var ee=E,te=x,re=j,ne=I,se=ee.sum32,ie=ee.sum32_4,oe=ee.sum32_5,ae=re.ch32,ce=re.maj32,le=re.s0_256,ue=re.s1_256,de=re.g0_256,he=re.g1_256,pe=te.BlockHash,fe=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298];function ge(){if(!(this instanceof ge))return new ge;pe.call(this),this.h=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225],this.k=fe,this.W=new Array(64)}ee.inherits(ge,pe);var ye=ge;ge.blockSize=512,ge.outSize=256,ge.hmacStrength=192,ge.padLength=64,ge.prototype._update=function(e,t){for(var r=this.W,n=0;n<16;n++)r[n]=e[t+n];for(;n<r.length;n++)r[n]=ie(he(r[n-2]),r[n-7],de(r[n-15]),r[n-16]);var s=this.h[0],i=this.h[1],o=this.h[2],a=this.h[3],c=this.h[4],l=this.h[5],u=this.h[6],d=this.h[7];for(ne(this.k.length===r.length),n=0;n<r.length;n++){var h=oe(d,ue(c),ae(c,l,u),this.k[n],r[n]),p=se(le(s),ce(s,i,o));d=u,u=l,l=c,c=se(a,h),a=o,o=i,i=s,s=se(h,p)}this.h[0]=se(this.h[0],s),this.h[1]=se(this.h[1],i),this.h[2]=se(this.h[2],o),this.h[3]=se(this.h[3],a),this.h[4]=se(this.h[4],c),this.h[5]=se(this.h[5],l),this.h[6]=se(this.h[6],u),this.h[7]=se(this.h[7],d)},ge.prototype._digest=function(e){return"hex"===e?ee.toHex32(this.h,"big"):ee.split32(this.h,"big")};var me=E,we=ye;function be(){if(!(this instanceof be))return new be;we.call(this),this.h=[3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428]}me.inherits(be,we);var ve=be;be.blockSize=512,be.outSize=224,be.hmacStrength=192,be.padLength=64,be.prototype._digest=function(e){return"hex"===e?me.toHex32(this.h.slice(0,7),"big"):me.split32(this.h.slice(0,7),"big")};var _e=E,ke=x,Ee=I,Ie=_e.rotr64_hi,Se=_e.rotr64_lo,Pe=_e.shr64_hi,Ae=_e.shr64_lo,Re=_e.sum64,Ce=_e.sum64_hi,Te=_e.sum64_lo,De=_e.sum64_4_hi,Be=_e.sum64_4_lo,xe=_e.sum64_5_hi,Ne=_e.sum64_5_lo,Oe=ke.BlockHash,Le=[1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591];function Me(){if(!(this instanceof Me))return new Me;Oe.call(this),this.h=[1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209],this.k=Le,this.W=new Array(160)}_e.inherits(Me,Oe);var je=Me;function Ue(e,t,r,n,s){var i=e&r^~e&s;return i<0&&(i+=4294967296),i}function ze(e,t,r,n,s,i){var o=t&n^~t&i;return o<0&&(o+=4294967296),o}function We(e,t,r,n,s){var i=e&r^e&s^r&s;return i<0&&(i+=4294967296),i}function $e(e,t,r,n,s,i){var o=t&n^t&i^n&i;return o<0&&(o+=4294967296),o}function Fe(e,t){var r=Ie(e,t,28)^Ie(t,e,2)^Ie(t,e,7);return r<0&&(r+=4294967296),r}function Ke(e,t){var r=Se(e,t,28)^Se(t,e,2)^Se(t,e,7);return r<0&&(r+=4294967296),r}function qe(e,t){var r=Ie(e,t,14)^Ie(e,t,18)^Ie(t,e,9);return r<0&&(r+=4294967296),r}function He(e,t){var r=Se(e,t,14)^Se(e,t,18)^Se(t,e,9);return r<0&&(r+=4294967296),r}function Ge(e,t){var r=Ie(e,t,1)^Ie(e,t,8)^Pe(e,t,7);return r<0&&(r+=4294967296),r}function Ve(e,t){var r=Se(e,t,1)^Se(e,t,8)^Ae(e,t,7);return r<0&&(r+=4294967296),r}function Xe(e,t){var r=Ie(e,t,19)^Ie(t,e,29)^Pe(e,t,6);return r<0&&(r+=4294967296),r}function Je(e,t){var r=Se(e,t,19)^Se(t,e,29)^Ae(e,t,6);return r<0&&(r+=4294967296),r}Me.blockSize=1024,Me.outSize=512,Me.hmacStrength=192,Me.padLength=128,Me.prototype._prepareBlock=function(e,t){for(var r=this.W,n=0;n<32;n++)r[n]=e[t+n];for(;n<r.length;n+=2){var s=Xe(r[n-4],r[n-3]),i=Je(r[n-4],r[n-3]),o=r[n-14],a=r[n-13],c=Ge(r[n-30],r[n-29]),l=Ve(r[n-30],r[n-29]),u=r[n-32],d=r[n-31];r[n]=De(s,i,o,a,c,l,u,d),r[n+1]=Be(s,i,o,a,c,l,u,d)}},Me.prototype._update=function(e,t){this._prepareBlock(e,t);var r=this.W,n=this.h[0],s=this.h[1],i=this.h[2],o=this.h[3],a=this.h[4],c=this.h[5],l=this.h[6],u=this.h[7],d=this.h[8],h=this.h[9],p=this.h[10],f=this.h[11],g=this.h[12],y=this.h[13],m=this.h[14],w=this.h[15];Ee(this.k.length===r.length);for(var b=0;b<r.length;b+=2){var v=m,_=w,k=qe(d,h),E=He(d,h),I=Ue(d,h,p,f,g),S=ze(d,h,p,f,g,y),P=this.k[b],A=this.k[b+1],R=r[b],C=r[b+1],T=xe(v,_,k,E,I,S,P,A,R,C),D=Ne(v,_,k,E,I,S,P,A,R,C);v=Fe(n,s),_=Ke(n,s),k=We(n,s,i,o,a),E=$e(n,s,i,o,a,c);var B=Ce(v,_,k,E),x=Te(v,_,k,E);m=g,w=y,g=p,y=f,p=d,f=h,d=Ce(l,u,T,D),h=Te(u,u,T,D),l=a,u=c,a=i,c=o,i=n,o=s,n=Ce(T,D,B,x),s=Te(T,D,B,x)}Re(this.h,0,n,s),Re(this.h,2,i,o),Re(this.h,4,a,c),Re(this.h,6,l,u),Re(this.h,8,d,h),Re(this.h,10,p,f),Re(this.h,12,g,y),Re(this.h,14,m,w)},Me.prototype._digest=function(e){return"hex"===e?_e.toHex32(this.h,"big"):_e.split32(this.h,"big")};var Ze=E,Ye=je;function Qe(){if(!(this instanceof Qe))return new Qe;Ye.call(this),this.h=[3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428]}Ze.inherits(Qe,Ye);var et=Qe;Qe.blockSize=1024,Qe.outSize=384,Qe.hmacStrength=192,Qe.padLength=128,Qe.prototype._digest=function(e){return"hex"===e?Ze.toHex32(this.h.slice(0,12),"big"):Ze.split32(this.h.slice(0,12),"big")},M.sha1=Q,M.sha224=ve,M.sha256=ye,M.sha384=et,M.sha512=je;var tt={},rt=E,nt=x,st=rt.rotl32,it=rt.sum32,ot=rt.sum32_3,at=rt.sum32_4,ct=nt.BlockHash;function lt(){if(!(this instanceof lt))return new lt;ct.call(this),this.h=[1732584193,4023233417,2562383102,271733878,3285377520],this.endian="little"}function ut(e,t,r,n){return e<=15?t^r^n:e<=31?t&r|~t&n:e<=47?(t|~r)^n:e<=63?t&n|r&~n:t^(r|~n)}function dt(e){return e<=15?0:e<=31?1518500249:e<=47?1859775393:e<=63?2400959708:2840853838}function ht(e){return e<=15?1352829926:e<=31?1548603684:e<=47?1836072691:e<=63?2053994217:0}rt.inherits(lt,ct),tt.ripemd160=lt,lt.blockSize=512,lt.outSize=160,lt.hmacStrength=192,lt.padLength=64,lt.prototype._update=function(e,t){for(var r=this.h[0],n=this.h[1],s=this.h[2],i=this.h[3],o=this.h[4],a=r,c=n,l=s,u=i,d=o,h=0;h<80;h++){var p=it(st(at(r,ut(h,n,s,i),e[pt[h]+t],dt(h)),gt[h]),o);r=o,o=i,i=st(s,10),s=n,n=p,p=it(st(at(a,ut(79-h,c,l,u),e[ft[h]+t],ht(h)),yt[h]),d),a=d,d=u,u=st(l,10),l=c,c=p}p=ot(this.h[1],s,u),this.h[1]=ot(this.h[2],i,d),this.h[2]=ot(this.h[3],o,a),this.h[3]=ot(this.h[4],r,c),this.h[4]=ot(this.h[0],n,l),this.h[0]=p},lt.prototype._digest=function(e){return"hex"===e?rt.toHex32(this.h,"little"):rt.split32(this.h,"little")};var pt=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13],ft=[5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11],gt=[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6],yt=[8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11],mt=E,wt=I;function bt(e,t,r){if(!(this instanceof bt))return new bt(e,t,r);this.Hash=e,this.blockSize=e.blockSize/8,this.outSize=e.outSize/8,this.inner=null,this.outer=null,this._init(mt.toArray(t,r))}var vt=bt;bt.prototype._init=function(e){e.length>this.blockSize&&(e=(new this.Hash).update(e).digest()),wt(e.length<=this.blockSize);for(var t=e.length;t<this.blockSize;t++)e.push(0);for(t=0;t<e.length;t++)e[t]^=54;for(this.inner=(new this.Hash).update(e),t=0;t<e.length;t++)e[t]^=106;this.outer=(new this.Hash).update(e)},bt.prototype.update=function(e,t){return this.inner.update(e,t),this},bt.prototype.digest=function(e){return this.outer.update(this.inner.digest()),this.outer.digest(e)},function(e){var t=e;t.utils=E,t.common=x,t.sha=M,t.ripemd=tt,t.hmac=vt,t.sha1=t.sha.sha1,t.sha256=t.sha.sha256,t.sha224=t.sha.sha224,t.sha384=t.sha.sha384,t.sha512=t.sha.sha512,t.ripemd160=t.ripemd.ripemd160}(k);var _t=k;let kt=!1,Et=!1;const It={debug:1,default:2,info:2,warning:3,error:4,off:5};let St=It.default,Pt=null;const At=function(){try{const e=[];if(["NFD","NFC","NFKD","NFKC"].forEach((t=>{try{if("test"!=="test".normalize(t))throw new Error("bad normalize")}catch(r){e.push(t)}})),e.length)throw new Error("missing "+e.join(", "));if(String.fromCharCode(233).normalize("NFD")!==String.fromCharCode(101,769))throw new Error("broken implementation")}catch(e){return e.message}return null}();var Rt,Ct;!function(e){e.DEBUG="DEBUG",e.INFO="INFO",e.WARNING="WARNING",e.ERROR="ERROR",e.OFF="OFF"}(Rt||(Rt={})),function(e){e.UNKNOWN_ERROR="UNKNOWN_ERROR",e.NOT_IMPLEMENTED="NOT_IMPLEMENTED",e.UNSUPPORTED_OPERATION="UNSUPPORTED_OPERATION",e.NETWORK_ERROR="NETWORK_ERROR",e.SERVER_ERROR="SERVER_ERROR",e.TIMEOUT="TIMEOUT",e.BUFFER_OVERRUN="BUFFER_OVERRUN",e.NUMERIC_FAULT="NUMERIC_FAULT",e.MISSING_NEW="MISSING_NEW",e.INVALID_ARGUMENT="INVALID_ARGUMENT",e.MISSING_ARGUMENT="MISSING_ARGUMENT",e.UNEXPECTED_ARGUMENT="UNEXPECTED_ARGUMENT",e.CALL_EXCEPTION="CALL_EXCEPTION",e.INSUFFICIENT_FUNDS="INSUFFICIENT_FUNDS",e.NONCE_EXPIRED="NONCE_EXPIRED",e.REPLACEMENT_UNDERPRICED="REPLACEMENT_UNDERPRICED",e.UNPREDICTABLE_GAS_LIMIT="UNPREDICTABLE_GAS_LIMIT",e.TRANSACTION_REPLACED="TRANSACTION_REPLACED"}(Ct||(Ct={}));const Tt="0123456789abcdef";class Dt{constructor(e){Object.defineProperty(this,"version",{enumerable:!0,value:e,writable:!1})}_log(e,t){const r=e.toLowerCase();null==It[r]&&this.throwArgumentError("invalid log level name","logLevel",e),St>It[r]||console.log.apply(console,t)}debug(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];this._log(Dt.levels.DEBUG,t)}info(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];this._log(Dt.levels.INFO,t)}warn(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];this._log(Dt.levels.WARNING,t)}makeError(e,t,r){if(Et)return this.makeError("censored error",t,{});t||(t=Dt.errors.UNKNOWN_ERROR),r||(r={});const n=[];Object.keys(r).forEach((e=>{const t=r[e];try{if(t instanceof Uint8Array){let r="";for(let e=0;e<t.length;e++)r+=Tt[t[e]>>4],r+=Tt[15&t[e]];n.push(e+"=Uint8Array(0x"+r+")")}else n.push(e+"="+JSON.stringify(t))}catch(o){n.push(e+"="+JSON.stringify(r[e].toString()))}})),n.push(`code=${t}`),n.push(`version=${this.version}`);const s=e;let i="";switch(t){case Ct.NUMERIC_FAULT:{i="NUMERIC_FAULT";const t=e;switch(t){case"overflow":case"underflow":case"division-by-zero":i+="-"+t;break;case"negative-power":case"negative-width":i+="-unsupported";break;case"unbound-bitwise-result":i+="-unbound-result"}break}case Ct.CALL_EXCEPTION:case Ct.INSUFFICIENT_FUNDS:case Ct.MISSING_NEW:case Ct.NONCE_EXPIRED:case Ct.REPLACEMENT_UNDERPRICED:case Ct.TRANSACTION_REPLACED:case Ct.UNPREDICTABLE_GAS_LIMIT:i=t}i&&(e+=" [ See: https://links.ethers.org/v5-errors-"+i+" ]"),n.length&&(e+=" ("+n.join(", ")+")");const o=new Error(e);return o.reason=s,o.code=t,Object.keys(r).forEach((function(e){o[e]=r[e]})),o}throwError(e,t,r){throw this.makeError(e,t,r)}throwArgumentError(e,t,r){return this.throwError(e,Dt.errors.INVALID_ARGUMENT,{argument:t,value:r})}assert(e,t,r,n){e||this.throwError(t,r,n)}assertArgument(e,t,r,n){e||this.throwArgumentError(t,r,n)}checkNormalize(e){At&&this.throwError("platform missing String.prototype.normalize",Dt.errors.UNSUPPORTED_OPERATION,{operation:"String.prototype.normalize",form:At})}checkSafeUint53(e,t){"number"===typeof e&&(null==t&&(t="value not safe"),(e<0||e>=9007199254740991)&&this.throwError(t,Dt.errors.NUMERIC_FAULT,{operation:"checkSafeInteger",fault:"out-of-safe-range",value:e}),e%1&&this.throwError(t,Dt.errors.NUMERIC_FAULT,{operation:"checkSafeInteger",fault:"non-integer",value:e}))}checkArgumentCount(e,t,r){r=r?": "+r:"",e<t&&this.throwError("missing argument"+r,Dt.errors.MISSING_ARGUMENT,{count:e,expectedCount:t}),e>t&&this.throwError("too many arguments"+r,Dt.errors.UNEXPECTED_ARGUMENT,{count:e,expectedCount:t})}checkNew(e,t){e!==Object&&null!=e||this.throwError("missing new",Dt.errors.MISSING_NEW,{name:t.name})}checkAbstract(e,t){e===t?this.throwError("cannot instantiate abstract class "+JSON.stringify(t.name)+" directly; use a sub-class",Dt.errors.UNSUPPORTED_OPERATION,{name:e.name,operation:"new"}):e!==Object&&null!=e||this.throwError("missing new",Dt.errors.MISSING_NEW,{name:t.name})}static globalLogger(){return Pt||(Pt=new Dt("logger/5.6.0")),Pt}static setCensorship(e,t){if(!e&&t&&this.globalLogger().throwError("cannot permanently disable censorship",Dt.errors.UNSUPPORTED_OPERATION,{operation:"setCensorship"}),kt){if(!e)return;this.globalLogger().throwError("error censorship permanent",Dt.errors.UNSUPPORTED_OPERATION,{operation:"setCensorship"})}Et=!!e,kt=!!t}static setLogLevel(e){const t=It[e.toLowerCase()];null!=t?St=t:Dt.globalLogger().warn("invalid log level - "+e)}static from(e){return new Dt(e)}}Dt.errors=Ct,Dt.levels=Rt;const Bt=new Dt("bytes/5.6.0");function xt(e){return e.slice||(e.slice=function(){const t=Array.prototype.slice.call(arguments);return xt(new Uint8Array(Array.prototype.slice.apply(e,t)))}),e}function Nt(e){return"number"===typeof e&&e==e&&e%1===0}function Ot(e,t){if(t||(t={}),"number"===typeof e){Bt.checkSafeUint53(e,"invalid arrayify value");const t=[];for(;e;)t.unshift(255&e),e=parseInt(String(e/256));return 0===t.length&&t.push(0),xt(new Uint8Array(t))}if(t.allowMissingPrefix&&"string"===typeof e&&"0x"!==e.substring(0,2)&&(e="0x"+e),function(e){return!!e.toHexString}(e)&&(e=e.toHexString()),function(e,t){if("string"!==typeof e||!e.match(/^0x[0-9A-Fa-f]*$/))return!1;if(t&&e.length!==2+2*t)return!1;return!0}(e)){let r=e.substring(2);r.length%2&&("left"===t.hexPad?r="0x0"+r.substring(2):"right"===t.hexPad?r+="0":Bt.throwArgumentError("hex data is odd-length","value",e));const n=[];for(let e=0;e<r.length;e+=2)n.push(parseInt(r.substring(e,e+2),16));return xt(new Uint8Array(n))}return function(e){if(null==e)return!1;if(e.constructor===Uint8Array)return!0;if("string"===typeof e)return!1;if(!Nt(e.length)||e.length<0)return!1;for(let t=0;t<e.length;t++){const r=e[t];if(!Nt(r)||r<0||r>=256)return!1}return!0}(e)?xt(new Uint8Array(e)):Bt.throwArgumentError("invalid arrayify value","value",e)}function Lt(e){return"0x"+_t.sha256().update(Ot(e)).digest("hex")}new Dt("sha2/5.6.0");class Mt{constructor(e){Object.assign(this,e)}encode(){return i.Buffer.from((0,u.serialize)(Ut,this))}static decode(e){return(0,u.deserialize)(Ut,this,e)}static decodeUnchecked(e){return(0,u.deserializeUnchecked)(Ut,this,e)}}class jt extends Mt{constructor(e){if(super(e),this.enum="",1!==Object.keys(e).length)throw new Error("Enum can only take single value");Object.keys(e).map((e=>{this.enum=e}))}}const Ut=new Map,zt=32;class Wt extends Mt{constructor(e){if(super({}),this._bn=void 0,function(e){return void 0!==e._bn}(e))this._bn=e._bn;else{if("string"===typeof e){const t=l().decode(e);if(32!=t.length)throw new Error("Invalid public key input");this._bn=new(a())(t)}else this._bn=new(a())(e);if(this._bn.byteLength()>32)throw new Error("Invalid public key input")}}equals(e){return this._bn.eq(e._bn)}toBase58(){return l().encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){return this.toBuffer()}toBuffer(){const e=this._bn.toArrayLike(i.Buffer);if(32===e.length)return e;const t=i.Buffer.alloc(32);return e.copy(t,32-e.length),t}toString(){return this.toBase58()}static async createWithSeed(e,t,r){const n=i.Buffer.concat([e.toBuffer(),i.Buffer.from(t),r.toBuffer()]),s=Lt(new Uint8Array(n)).slice(2);return new Wt(i.Buffer.from(s,"hex"))}static createProgramAddressSync(e,t){let r=i.Buffer.alloc(0);e.forEach((function(e){if(e.length>zt)throw new TypeError("Max seed length exceeded");r=i.Buffer.concat([r,_(e)])})),r=i.Buffer.concat([r,t.toBuffer(),i.Buffer.from("ProgramDerivedAddress")]);let n=Lt(new Uint8Array(r)).slice(2),s=new(a())(n,16).toArray(void 0,32);if(Ft(s))throw new Error("Invalid seeds, address must fall off the curve");return new Wt(s)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let r,n=255;for(;0!=n;){try{const s=e.concat(i.Buffer.from([n]));r=this.createProgramAddressSync(s,t)}catch(s){if(s instanceof TypeError)throw s;n--;continue}return[r,n]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){return 1==Ft(new Wt(e).toBytes())}}Wt.default=new Wt("11111111111111111111111111111111"),Ut.set(Wt,{kind:"struct",fields:[["_bn","u256"]]});let $t=s().lowlevel;function Ft(e){var t=[$t.gf(),$t.gf(),$t.gf(),$t.gf()],r=$t.gf(),n=$t.gf(),s=$t.gf(),i=$t.gf(),o=$t.gf(),a=$t.gf(),c=$t.gf();return $t.set25519(t[2],Kt),$t.unpack25519(t[1],e),$t.S(s,t[1]),$t.M(i,s,$t.D),$t.Z(s,s,t[2]),$t.A(i,t[2],i),$t.S(o,i),$t.S(a,o),$t.M(c,a,o),$t.M(r,c,s),$t.M(r,r,i),$t.pow2523(r,r),$t.M(r,r,s),$t.M(r,r,i),$t.M(r,r,i),$t.M(t[0],r,i),$t.S(n,t[0]),$t.M(n,n,i),Ht(n,s)&&$t.M(t[0],t[0],qt),$t.S(n,t[0]),$t.M(n,n,i),Ht(n,s)?0:1}let Kt=$t.gf([1]),qt=$t.gf([41136,18958,6951,50414,58488,44335,6150,12099,55207,15867,153,11085,57099,20417,9344,11139]);function Ht(e,t){var r=new Uint8Array(32),n=new Uint8Array(32);return $t.pack25519(r,e),$t.pack25519(n,t),$t.crypto_verify_32(r,0,n,0)}class Gt{constructor(e){this._keypair=void 0,this._keypair=e?s().sign.keyPair.fromSecretKey(_(e)):s().sign.keyPair()}get publicKey(){return new Wt(this._keypair.publicKey)}get secretKey(){return _(this._keypair.secretKey)}}const Vt=new Wt("BPFLoader1111111111111111111111111111111111"),Xt=1232,Jt=64,Zt=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"publicKey";return d.Ik(32,e)},Yt=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"string";const t=d.n_([d.Jq("length"),d.Jq("lengthPadding"),d.Ik(d.cv(d.Jq(),-8),"chars")],e),r=t.decode.bind(t),n=t.encode.bind(t),s=t;return s.decode=(e,t)=>r(e,t).chars.toString(),s.encode=(e,t,r)=>{const s={chars:i.Buffer.from(e,"utf8")};return n(s,t,r)},s.alloc=e=>d.Jq().span+d.Jq().span+i.Buffer.from(e,"utf8").length,s};function Qt(e){let t=0,r=0;for(;;){let n=e.shift();if(t|=(127&n)<<7*r,r+=1,0===(128&n))break}return t}function er(e,t){let r=t;for(;;){let t=127&r;if(r>>=7,0==r){e.push(t);break}t|=128,e.push(t)}}class tr{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map((e=>new Wt(e))),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach((e=>this.indexToProgramIds.set(e.programIdIndex,this.accountKeys[e.programIdIndex])))}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){return e<this.header.numRequiredSignatures-this.header.numReadonlySignedAccounts||e>=this.header.numRequiredSignatures&&e<this.accountKeys.length-this.header.numReadonlyUnsignedAccounts}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter(((e,t)=>!this.isProgramId(t)))}serialize(){const e=this.accountKeys.length;let t=[];er(t,e);const r=this.instructions.map((e=>{const{accounts:t,programIdIndex:r}=e,n=Array.from(l().decode(e.data));let s=[];er(s,t.length);let o=[];return er(o,n.length),{programIdIndex:r,keyIndicesCount:i.Buffer.from(s),keyIndices:t,dataLength:i.Buffer.from(o),data:n}}));let n=[];er(n,r.length);let s=i.Buffer.alloc(Xt);i.Buffer.from(n).copy(s);let o=n.length;r.forEach((e=>{const t=d.n_([d.u8("programIdIndex"),d.Ik(e.keyIndicesCount.length,"keyIndicesCount"),d.A9(d.u8("keyIndex"),e.keyIndices.length,"keyIndices"),d.Ik(e.dataLength.length,"dataLength"),d.A9(d.u8("userdatum"),e.data.length,"data")]).encode(e,s,o);o+=t})),s=s.slice(0,o);const a=d.n_([d.Ik(1,"numRequiredSignatures"),d.Ik(1,"numReadonlySignedAccounts"),d.Ik(1,"numReadonlyUnsignedAccounts"),d.Ik(t.length,"keyCount"),d.A9(Zt("key"),e,"keys"),Zt("recentBlockhash")]),c={numRequiredSignatures:i.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:i.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:i.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:i.Buffer.from(t),keys:this.accountKeys.map((e=>_(e.toBytes()))),recentBlockhash:l().decode(this.recentBlockhash)};let u=i.Buffer.alloc(2048);const h=a.encode(c,u);return s.copy(u,h),u.slice(0,h+s.length)}static from(e){let t=[...e];const r=t.shift(),n=t.shift(),s=t.shift(),o=Qt(t);let a=[];for(let p=0;p<o;p++){const e=t.slice(0,32);t=t.slice(32),a.push(l().encode(i.Buffer.from(e)))}const c=t.slice(0,32);t=t.slice(32);const u=Qt(t);let d=[];for(let p=0;p<u;p++){const e=t.shift(),r=Qt(t),n=t.slice(0,r);t=t.slice(r);const s=Qt(t),o=t.slice(0,s),a=l().encode(i.Buffer.from(o));t=t.slice(s),d.push({programIdIndex:e,accounts:n,data:a})}const h={header:{numRequiredSignatures:r,numReadonlySignedAccounts:n,numReadonlyUnsignedAccounts:s},recentBlockhash:l().encode(i.Buffer.from(c)),accountKeys:a,instructions:d};return new tr(h)}}function rr(e,t){if(!e)throw new Error(t||"Assertion failed")}let nr;!function(e){e[e.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",e[e.PROCESSED=1]="PROCESSED",e[e.TIMED_OUT=2]="TIMED_OUT"}(nr||(nr={}));const sr=i.Buffer.alloc(Jt).fill(0);class ir{constructor(e){this.keys=void 0,this.programId=void 0,this.data=i.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map((e=>{let{pubkey:t,isSigner:r,isWritable:n}=e;return{pubkey:t.toJSON(),isSigner:r,isWritable:n}})),programId:this.programId.toJSON(),data:[...this.data]}}}class or{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this._message=void 0,this._json=void 0,e)if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const t=e;Object.assign(this,t),this.recentBlockhash=t.blockhash,this.lastValidBlockHeight=t.lastValidBlockHeight}else{const t=e;Object.assign(this,t),this.recentBlockhash=t.recentBlockhash}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map((e=>e.toJSON())),signers:this.signatures.map((e=>{let{publicKey:t}=e;return t.toJSON()}))}}add(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];if(0===t.length)throw new Error("No instructions");return t.forEach((e=>{"instructions"in e?this.instructions=this.instructions.concat(e.instructions):"data"in e&&"programId"in e&&"keys"in e?this.instructions.push(e):this.instructions.push(new ir(e))})),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;const{nonceInfo:e}=this;e&&this.instructions[0]!=e.nonceInstruction&&(this.recentBlockhash=e.nonce,this.instructions.unshift(e.nonceInstruction));const{recentBlockhash:t}=this;if(!t)throw new Error("Transaction recentBlockhash required");let r;if(this.instructions.length<1&&console.warn("No instructions provided"),this.feePayer)r=this.feePayer;else{if(!(this.signatures.length>0&&this.signatures[0].publicKey))throw new Error("Transaction fee payer required");r=this.signatures[0].publicKey}for(let l=0;l<this.instructions.length;l++)if(void 0===this.instructions[l].programId)throw new Error(`Transaction instruction index ${l} has undefined program id`);const n=[],s=[];this.instructions.forEach((e=>{e.keys.forEach((e=>{s.push({...e})}));const t=e.programId.toString();n.includes(t)||n.push(t)})),n.forEach((e=>{s.push({pubkey:new Wt(e),isSigner:!1,isWritable:!1})}));const i=[];s.forEach((e=>{const t=e.pubkey.toString(),r=i.findIndex((e=>e.pubkey.toString()===t));r>-1?(i[r].isWritable=i[r].isWritable||e.isWritable,i[r].isSigner=i[r].isSigner||e.isSigner):i.push(e)})),i.sort((function(e,t){return e.isSigner!==t.isSigner?e.isSigner?-1:1:e.isWritable!==t.isWritable?e.isWritable?-1:1:e.pubkey.toBase58().localeCompare(t.pubkey.toBase58())}));const o=i.findIndex((e=>e.pubkey.equals(r)));if(o>-1){const[e]=i.splice(o,1);e.isSigner=!0,e.isWritable=!0,i.unshift(e)}else i.unshift({pubkey:r,isSigner:!0,isWritable:!0});for(const l of this.signatures){const e=i.findIndex((e=>e.pubkey.equals(l.publicKey)));if(!(e>-1))throw new Error(`unknown signer: ${l.publicKey.toString()}`);i[e].isSigner||(i[e].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."))}let a=0,c=0,u=0;const d=[],h=[];i.forEach((e=>{let{pubkey:t,isSigner:r,isWritable:n}=e;r?(d.push(t.toString()),a+=1,n||(c+=1)):(h.push(t.toString()),n||(u+=1))}));const p=d.concat(h),f=this.instructions.map((e=>{const{data:t,programId:r}=e;return{programIdIndex:p.indexOf(r.toString()),accounts:e.keys.map((e=>p.indexOf(e.pubkey.toString()))),data:l().encode(t)}}));return f.forEach((e=>{rr(e.programIdIndex>=0),e.accounts.forEach((e=>rr(e>=0)))})),new tr({header:{numRequiredSignatures:a,numReadonlySignedAccounts:c,numReadonlyUnsignedAccounts:u},accountKeys:p,recentBlockhash:t,instructions:f})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);if(this.signatures.length===t.length){if(this.signatures.every(((e,r)=>t[r].equals(e.publicKey))))return e}return this.signatures=t.map((e=>({signature:null,publicKey:e}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];if(0===t.length)throw new Error("No signers");const n=new Set;this.signatures=t.filter((e=>{const t=e.toString();return!n.has(t)&&(n.add(t),!0)})).map((e=>({signature:null,publicKey:e})))}sign(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];if(0===t.length)throw new Error("No signers");const n=new Set,s=[];for(const o of t){const e=o.publicKey.toString();n.has(e)||(n.add(e),s.push(o))}this.signatures=s.map((e=>({signature:null,publicKey:e.publicKey})));const i=this._compile();this._partialSign(i,...s)}partialSign(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];if(0===t.length)throw new Error("No signers");const n=new Set,s=[];for(const o of t){const e=o.publicKey.toString();n.has(e)||(n.add(e),s.push(o))}const i=this._compile();this._partialSign(i,...s)}_partialSign(e){const t=e.serialize();for(var r=arguments.length,n=new Array(r>1?r-1:0),i=1;i<r;i++)n[i-1]=arguments[i];n.forEach((e=>{const r=s().sign.detached(t,e.secretKey);this._addSignature(e.publicKey,_(r))}))}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){rr(64===t.length);const r=this.signatures.findIndex((t=>e.equals(t.publicKey)));if(r<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[r].signature=i.Buffer.from(t)}verifySignatures(){return this._verifySignatures(this.serializeMessage(),!0)}_verifySignatures(e,t){for(const{signature:r,publicKey:n}of this.signatures)if(null===r){if(t)return!1}else if(!s().sign.detached.verify(e,r,n.toBuffer()))return!1;return!0}serialize(e){const{requireAllSignatures:t,verifySignatures:r}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),n=this.serializeMessage();if(r&&!this._verifySignatures(n,t))throw new Error("Signature verification failed");return this._serialize(n)}_serialize(e){const{signatures:t}=this,r=[];er(r,t.length);const n=r.length+64*t.length+e.length,s=i.Buffer.alloc(n);return rr(t.length<256),i.Buffer.from(r).copy(s,0),t.forEach(((e,t)=>{let{signature:n}=e;null!==n&&(rr(64===n.length,"signature has invalid length"),i.Buffer.from(n).copy(s,r.length+64*t))})),e.copy(s,r.length+64*t.length),rr(s.length<=Xt,`Transaction too large: ${s.length} > ${Xt}`),s}get keys(){return rr(1===this.instructions.length),this.instructions[0].keys.map((e=>e.pubkey))}get programId(){return rr(1===this.instructions.length),this.instructions[0].programId}get data(){return rr(1===this.instructions.length),this.instructions[0].data}static from(e){let t=[...e];const r=Qt(t);let n=[];for(let s=0;s<r;s++){const e=t.slice(0,Jt);t=t.slice(Jt),n.push(l().encode(i.Buffer.from(e)))}return or.populate(tr.from(t),n)}static populate(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const r=new or;return r.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(r.feePayer=e.accountKeys[0]),t.forEach(((t,n)=>{const s={signature:t==l().encode(sr)?null:l().decode(t),publicKey:e.accountKeys[n]};r.signatures.push(s)})),e.instructions.forEach((t=>{const n=t.accounts.map((t=>{const n=e.accountKeys[t];return{pubkey:n,isSigner:r.signatures.some((e=>e.publicKey.toString()===n.toString()))||e.isAccountSigner(t),isWritable:e.isAccountWritable(t)}}));r.instructions.push(new ir({keys:n,programId:e.accountKeys[t.programIdIndex],data:l().decode(t.data)}))})),r._message=e,r._json=r.toJSON(),r}}const ar=new Wt("SysvarC1ock11111111111111111111111111111111"),cr=new Wt("SysvarEpochSchedu1e111111111111111111111111"),lr=new Wt("Sysvar1nstructions1111111111111111111111111"),ur=new Wt("SysvarRecentB1ockHashes11111111111111111111"),dr=new Wt("SysvarRent111111111111111111111111111111111"),hr=new Wt("SysvarRewards111111111111111111111111111111"),pr=new Wt("SysvarS1otHashes111111111111111111111111111"),fr=new Wt("SysvarS1otHistory11111111111111111111111111"),gr=new Wt("SysvarStakeHistory1111111111111111111111111");async function yr(e,t,r,n){const s=n&&{skipPreflight:n.skipPreflight,preflightCommitment:n.preflightCommitment||n.commitment,maxRetries:n.maxRetries},i=await e.sendTransaction(t,r,s),o=null!=t.recentBlockhash&&null!=t.lastValidBlockHeight?(await e.confirmTransaction({signature:i,blockhash:t.recentBlockhash,lastValidBlockHeight:t.lastValidBlockHeight},n&&n.commitment)).value:(await e.confirmTransaction(i,n&&n.commitment)).value;if(o.err)throw new Error(`Transaction ${i} failed (${JSON.stringify(o)})`);return i}function mr(e){return new Promise((t=>setTimeout(t,e)))}function wr(e,t){const r=e.layout.span>=0?e.layout.span:function(e,t){let r=0;return e.layout.fields.forEach((e=>{e.span>=0?r+=e.span:"function"===typeof e.alloc&&(r+=e.alloc(t[e.property]))})),r}(e,t),n=i.Buffer.alloc(r),s=Object.assign({instruction:e.index},t);return e.layout.encode(s,n),n}function br(e,t){let r;try{r=e.layout.decode(t)}catch(n){throw new Error("invalid instruction; "+n)}if(r.instruction!==e.index)throw new Error(`invalid instruction; instruction index mismatch ${r.instruction} != ${e.index}`);return r}const vr=d._O("lamportsPerSignature"),_r=d.n_([d.Jq("version"),d.Jq("state"),Zt("authorizedPubkey"),Zt("nonce"),d.n_([vr],"feeCalculator")]),kr=_r.span;class Er{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){const t=_r.decode(_(e),0);return new Er({authorizedPubkey:new Wt(t.authorizedPubkey),nonce:new Wt(t.nonce).toString(),feeCalculator:t.feeCalculator})}}const Ir=(Sr=8,e=>{const t=(0,d.Ik)(Sr,e),{encode:r,decode:n}=(e=>({decode:e.decode.bind(e),encode:e.encode.bind(e)}))(t),s=t;return s.decode=(e,t)=>{const r=n(e,t);return(0,h.oU)(i.Buffer.from(r))},s.encode=(e,t,n)=>{const s=(0,h.k$)(e,Sr);return r(s,t,n)},s});var Sr;class Pr{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=d.Jq("instruction").decode(e.data);let r;for(const[n,s]of Object.entries(Ar))if(s.index==t){r=n;break}if(!r)throw new Error("Instruction type incorrect; not a SystemInstruction");return r}static decodeCreateAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t,space:r,programId:n}=br(Ar.Create,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,lamports:t,space:r,programId:new Wt(n)}}static decodeTransfer(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t}=br(Ar.Transfer,e.data);return{fromPubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,lamports:t}}static decodeTransferWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t,seed:r,programId:n}=br(Ar.TransferWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,basePubkey:e.keys[1].pubkey,toPubkey:e.keys[2].pubkey,lamports:t,seed:r,programId:new Wt(n)}}static decodeAllocate(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{space:t}=br(Ar.Allocate,e.data);return{accountPubkey:e.keys[0].pubkey,space:t}}static decodeAllocateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:r,space:n,programId:s}=br(Ar.AllocateWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new Wt(t),seed:r,space:n,programId:new Wt(s)}}static decodeAssign(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{programId:t}=br(Ar.Assign,e.data);return{accountPubkey:e.keys[0].pubkey,programId:new Wt(t)}}static decodeAssignWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:r,programId:n}=br(Ar.AssignWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new Wt(t),seed:r,programId:new Wt(n)}}static decodeCreateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{base:t,seed:r,lamports:n,space:s,programId:i}=br(Ar.CreateWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,basePubkey:new Wt(t),seed:r,lamports:n,space:s,programId:new Wt(i)}}static decodeNonceInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{authorized:t}=br(Ar.InitializeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:new Wt(t)}}static decodeNonceAdvance(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),br(Ar.AdvanceNonceAccount,e.data),{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static decodeNonceWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=br(Ar.WithdrawNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t}}static decodeNonceAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t}=br(Ar.AuthorizeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[1].pubkey,newAuthorizedPubkey:new Wt(t)}}static checkProgramId(e){if(!e.equals(Rr.programId))throw new Error("invalid instruction; programId is not SystemProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const Ar=Object.freeze({Create:{index:0,layout:d.n_([d.Jq("instruction"),d.gM("lamports"),d.gM("space"),Zt("programId")])},Assign:{index:1,layout:d.n_([d.Jq("instruction"),Zt("programId")])},Transfer:{index:2,layout:d.n_([d.Jq("instruction"),Ir("lamports")])},CreateWithSeed:{index:3,layout:d.n_([d.Jq("instruction"),Zt("base"),Yt("seed"),d.gM("lamports"),d.gM("space"),Zt("programId")])},AdvanceNonceAccount:{index:4,layout:d.n_([d.Jq("instruction")])},WithdrawNonceAccount:{index:5,layout:d.n_([d.Jq("instruction"),d.gM("lamports")])},InitializeNonceAccount:{index:6,layout:d.n_([d.Jq("instruction"),Zt("authorized")])},AuthorizeNonceAccount:{index:7,layout:d.n_([d.Jq("instruction"),Zt("authorized")])},Allocate:{index:8,layout:d.n_([d.Jq("instruction"),d.gM("space")])},AllocateWithSeed:{index:9,layout:d.n_([d.Jq("instruction"),Zt("base"),Yt("seed"),d.gM("space"),Zt("programId")])},AssignWithSeed:{index:10,layout:d.n_([d.Jq("instruction"),Zt("base"),Yt("seed"),Zt("programId")])},TransferWithSeed:{index:11,layout:d.n_([d.Jq("instruction"),Ir("lamports"),Yt("seed"),Zt("programId")])},UpgradeNonceAccount:{index:12,layout:d.n_([d.Jq("instruction")])}});class Rr{constructor(){}static createAccount(e){const t=wr(Ar.Create,{lamports:e.lamports,space:e.space,programId:_(e.programId.toBuffer())});return new ir({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:t})}static transfer(e){let t,r;if("basePubkey"in e){t=wr(Ar.TransferWithSeed,{lamports:BigInt(e.lamports),seed:e.seed,programId:_(e.programId.toBuffer())}),r=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{t=wr(Ar.Transfer,{lamports:BigInt(e.lamports)}),r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new ir({keys:r,programId:this.programId,data:t})}static assign(e){let t,r;if("basePubkey"in e){t=wr(Ar.AssignWithSeed,{base:_(e.basePubkey.toBuffer()),seed:e.seed,programId:_(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{t=wr(Ar.Assign,{programId:_(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new ir({keys:r,programId:this.programId,data:t})}static createAccountWithSeed(e){const t=wr(Ar.CreateWithSeed,{base:_(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:_(e.programId.toBuffer())});let r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey!=e.fromPubkey&&r.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new ir({keys:r,programId:this.programId,data:t})}static createNonceAccount(e){const t=new or;"basePubkey"in e&&"seed"in e?t.add(Rr.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:kr,programId:this.programId})):t.add(Rr.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:kr,programId:this.programId}));const r={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(r)),t}static nonceInitialize(e){const t=wr(Ar.InitializeNonceAccount,{authorized:_(e.authorizedPubkey.toBuffer())}),r={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:ur,isSigner:!1,isWritable:!1},{pubkey:dr,isSigner:!1,isWritable:!1}],programId:this.programId,data:t};return new ir(r)}static nonceAdvance(e){const t=wr(Ar.AdvanceNonceAccount),r={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:ur,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:t};return new ir(r)}static nonceWithdraw(e){const t=wr(Ar.WithdrawNonceAccount,{lamports:e.lamports});return new ir({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:ur,isSigner:!1,isWritable:!1},{pubkey:dr,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:t})}static nonceAuthorize(e){const t=wr(Ar.AuthorizeNonceAccount,{authorized:_(e.newAuthorizedPubkey.toBuffer())});return new ir({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:t})}static allocate(e){let t,r;if("basePubkey"in e){t=wr(Ar.AllocateWithSeed,{base:_(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:_(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{t=wr(Ar.Allocate,{space:e.space}),r=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new ir({keys:r,programId:this.programId,data:t})}}Rr.programId=new Wt("11111111111111111111111111111111");const Cr=Xt-300;class Tr{constructor(){}static getMinNumSignatures(e){return 2*(Math.ceil(e/Tr.chunkSize)+1+1)}static async load(e,t,r,n,s){{const i=await e.getMinimumBalanceForRentExemption(s.length),o=await e.getAccountInfo(r.publicKey,"confirmed");let a=null;if(null!==o){if(o.executable)return console.error("Program load failed, account is already executable"),!1;o.data.length!==s.length&&(a=a||new or,a.add(Rr.allocate({accountPubkey:r.publicKey,space:s.length}))),o.owner.equals(n)||(a=a||new or,a.add(Rr.assign({accountPubkey:r.publicKey,programId:n}))),o.lamports<i&&(a=a||new or,a.add(Rr.transfer({fromPubkey:t.publicKey,toPubkey:r.publicKey,lamports:i-o.lamports})))}else a=(new or).add(Rr.createAccount({fromPubkey:t.publicKey,newAccountPubkey:r.publicKey,lamports:i>0?i:1,space:s.length,programId:n}));null!==a&&await yr(e,a,[t,r],{commitment:"confirmed"})}const o=d.n_([d.Jq("instruction"),d.Jq("offset"),d.Jq("bytesLength"),d.Jq("bytesLengthPadding"),d.A9(d.u8("byte"),d.cv(d.Jq(),-8),"bytes")]),a=Tr.chunkSize;let c=0,l=s,u=[];for(;l.length>0;){const s=l.slice(0,a),d=i.Buffer.alloc(a+16);o.encode({instruction:0,offset:c,bytes:s,bytesLength:0,bytesLengthPadding:0},d);const h=(new or).add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0}],programId:n,data:d});if(u.push(yr(e,h,[t,r],{commitment:"confirmed"})),e._rpcEndpoint.includes("solana.com")){const e=4;await mr(1e3/e)}c+=a,l=l.slice(a)}await Promise.all(u);{const s=d.n_([d.Jq("instruction")]),o=i.Buffer.alloc(s.span);s.encode({instruction:1},o);const a=(new or).add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0},{pubkey:dr,isSigner:!1,isWritable:!1}],programId:n,data:o});await yr(e,a,[t,r],{commitment:"confirmed"})}return!0}}Tr.chunkSize=Cr;const Dr=new Wt("BPFLoader2111111111111111111111111111111111");class Br{static getMinNumSignatures(e){return Tr.getMinNumSignatures(e)}static load(e,t,r,n,s){return Tr.load(e,t,r,s,n)}}class xr{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=d.u8("instruction").decode(e.data);let r;for(const[n,s]of Object.entries(Nr))if(s.index==t){r=n;break}if(!r)throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");return r}static decodeRequestUnits(e){this.checkProgramId(e.programId);const{units:t,additionalFee:r}=br(Nr.RequestUnits,e.data);return{units:t,additionalFee:r}}static decodeRequestHeapFrame(e){this.checkProgramId(e.programId);const{bytes:t}=br(Nr.RequestHeapFrame,e.data);return{bytes:t}}static decodeSetComputeUnitLimit(e){this.checkProgramId(e.programId);const{units:t}=br(Nr.SetComputeUnitLimit,e.data);return{units:t}}static decodeSetComputeUnitPrice(e){this.checkProgramId(e.programId);const{microLamports:t}=br(Nr.SetComputeUnitPrice,e.data);return{microLamports:t}}static checkProgramId(e){if(!e.equals(Or.programId))throw new Error("invalid instruction; programId is not ComputeBudgetProgram")}}const Nr=Object.freeze({RequestUnits:{index:0,layout:d.n_([d.u8("instruction"),d.Jq("units"),d.Jq("additionalFee")])},RequestHeapFrame:{index:1,layout:d.n_([d.u8("instruction"),d.Jq("bytes")])},SetComputeUnitLimit:{index:2,layout:d.n_([d.u8("instruction"),d.Jq("units")])},SetComputeUnitPrice:{index:3,layout:d.n_([d.u8("instruction"),Ir("microLamports")])}});class Or{constructor(){}static requestUnits(e){const t=wr(Nr.RequestUnits,e);return new ir({keys:[],programId:this.programId,data:t})}static requestHeapFrame(e){const t=wr(Nr.RequestHeapFrame,e);return new ir({keys:[],programId:this.programId,data:t})}static setComputeUnitLimit(e){const t=wr(Nr.SetComputeUnitLimit,e);return new ir({keys:[],programId:this.programId,data:t})}static setComputeUnitPrice(e){const t=wr(Nr.SetComputeUnitPrice,{microLamports:BigInt(e.microLamports)});return new ir({keys:[],programId:this.programId,data:t})}}Or.programId=new Wt("ComputeBudget111111111111111111111111111111");var Lr=Object.prototype.toString,Mr=Object.keys||function(e){var t=[];for(var r in e)t.push(r);return t};function jr(e,t){var r,n,s,i,o,a,c;if(!0===e)return"true";if(!1===e)return"false";switch(typeof e){case"object":if(null===e)return null;if(e.toJSON&&"function"===typeof e.toJSON)return jr(e.toJSON(),t);if("[object Array]"===(c=Lr.call(e))){for(s="[",n=e.length-1,r=0;r<n;r++)s+=jr(e[r],!0)+",";return n>-1&&(s+=jr(e[r],!0)),s+"]"}if("[object Object]"===c){for(n=(i=Mr(e).sort()).length,s="",r=0;r<n;)void 0!==(a=jr(e[o=i[r]],!1))&&(s&&(s+=","),s+=JSON.stringify(o)+":"+a),r++;return"{"+s+"}"}return JSON.stringify(e);case"function":case"undefined":return t?null:void 0;case"string":return JSON.stringify(e);default:return isFinite(e)?e:null}}var Ur=function(e){var t=jr(e,!1);if(void 0!==t)return""+t};function zr(e){let t=0;for(;e>1;)e/=2,t++;return t}class Wr{constructor(e,t,r,n,s){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=r,this.firstNormalEpoch=n,this.firstNormalSlot=s}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){const r=zr(0===(t=e+32+1)?1:(t--,t|=t>>1,t|=t>>2,t|=t>>4,t|=t>>8,t|=t>>16,1+(t|=t>>32)))-zr(32)-1;return[r,e-(this.getSlotsInEpoch(r)-32)]}{const t=e-this.firstNormalSlot,r=Math.floor(t/this.slotsPerEpoch);return[this.firstNormalEpoch+r,t%this.slotsPerEpoch]}var t}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?32*(Math.pow(2,e)-1):(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+zr(32)):this.slotsPerEpoch}}class $r extends Error{constructor(e,t){super(e),this.logs=void 0,this.logs=t}}var Fr=globalThis.fetch;class Kr extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Kr.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class qr extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty(qr.prototype,"name",{value:"TransactionExpiredTimeoutError"});const Hr=(0,p.oQ)((0,p.eE)(Wt),(0,p.Z_)(),(e=>new Wt(e))),Gr=(0,p.bc)([(0,p.Z_)(),(0,p.i0)("base64")]),Vr=(0,p.oQ)((0,p.eE)(i.Buffer),Gr,(e=>i.Buffer.from(e[0],"base64"))),Xr=3e4;function Jr(e){return(0,p.G0)([(0,p.dt)({jsonrpc:(0,p.i0)("2.0"),id:(0,p.Z_)(),result:e}),(0,p.dt)({jsonrpc:(0,p.i0)("2.0"),id:(0,p.Z_)(),error:(0,p.dt)({code:(0,p._4)(),message:(0,p.Z_)(),data:(0,p.jt)((0,p.Yj)())})})])}const Zr=Jr((0,p._4)());function Yr(e){return(0,p.oQ)(Jr(e),Zr,(t=>"error"in t?t:{...t,result:(0,p.Ue)(t.result,e)}))}function Qr(e){return Yr((0,p.dt)({context:(0,p.dt)({slot:(0,p.Rx)()}),value:e}))}function en(e){return(0,p.dt)({context:(0,p.dt)({slot:(0,p.Rx)()}),value:e})}const tn=(0,p.dt)({foundation:(0,p.Rx)(),foundationTerm:(0,p.Rx)(),initial:(0,p.Rx)(),taper:(0,p.Rx)(),terminal:(0,p.Rx)()}),rn=Yr((0,p.IX)((0,p.AG)((0,p.dt)({epoch:(0,p.Rx)(),effectiveSlot:(0,p.Rx)(),amount:(0,p.Rx)(),postBalance:(0,p.Rx)()})))),nn=(0,p.dt)({epoch:(0,p.Rx)(),slotIndex:(0,p.Rx)(),slotsInEpoch:(0,p.Rx)(),absoluteSlot:(0,p.Rx)(),blockHeight:(0,p.jt)((0,p.Rx)()),transactionCount:(0,p.jt)((0,p.Rx)())}),sn=(0,p.dt)({slotsPerEpoch:(0,p.Rx)(),leaderScheduleSlotOffset:(0,p.Rx)(),warmup:(0,p.O7)(),firstNormalEpoch:(0,p.Rx)(),firstNormalSlot:(0,p.Rx)()}),on=(0,p.IM)((0,p.Z_)(),(0,p.IX)((0,p.Rx)())),an=(0,p.AG)((0,p.G0)([(0,p.dt)({}),(0,p.Z_)()])),cn=(0,p.dt)({err:an}),ln=(0,p.i0)("receivedSignature"),un=(0,p.dt)({"solana-core":(0,p.Z_)(),"feature-set":(0,p.jt)((0,p.Rx)())}),dn=Qr((0,p.dt)({err:(0,p.AG)((0,p.G0)([(0,p.dt)({}),(0,p.Z_)()])),logs:(0,p.AG)((0,p.IX)((0,p.Z_)())),accounts:(0,p.jt)((0,p.AG)((0,p.IX)((0,p.AG)((0,p.dt)({executable:(0,p.O7)(),owner:(0,p.Z_)(),lamports:(0,p.Rx)(),data:(0,p.IX)((0,p.Z_)()),rentEpoch:(0,p.jt)((0,p.Rx)())}))))),unitsConsumed:(0,p.jt)((0,p.Rx)())})),hn=Qr((0,p.dt)({byIdentity:(0,p.IM)((0,p.Z_)(),(0,p.IX)((0,p.Rx)())),range:(0,p.dt)({firstSlot:(0,p.Rx)(),lastSlot:(0,p.Rx)()})}));const pn=Yr(tn),fn=Yr(nn),gn=Yr(sn),yn=Yr(on),mn=Yr((0,p.Rx)()),wn=Qr((0,p.dt)({total:(0,p.Rx)(),circulating:(0,p.Rx)(),nonCirculating:(0,p.Rx)(),nonCirculatingAccounts:(0,p.IX)(Hr)})),bn=(0,p.dt)({amount:(0,p.Z_)(),uiAmount:(0,p.AG)((0,p.Rx)()),decimals:(0,p.Rx)(),uiAmountString:(0,p.jt)((0,p.Z_)())}),vn=Qr((0,p.IX)((0,p.dt)({address:Hr,amount:(0,p.Z_)(),uiAmount:(0,p.AG)((0,p.Rx)()),decimals:(0,p.Rx)(),uiAmountString:(0,p.jt)((0,p.Z_)())}))),_n=Qr((0,p.IX)((0,p.dt)({pubkey:Hr,account:(0,p.dt)({executable:(0,p.O7)(),owner:Hr,lamports:(0,p.Rx)(),data:Vr,rentEpoch:(0,p.Rx)()})}))),kn=(0,p.dt)({program:(0,p.Z_)(),parsed:(0,p._4)(),space:(0,p.Rx)()}),En=Qr((0,p.IX)((0,p.dt)({pubkey:Hr,account:(0,p.dt)({executable:(0,p.O7)(),owner:Hr,lamports:(0,p.Rx)(),data:kn,rentEpoch:(0,p.Rx)()})}))),In=Qr((0,p.IX)((0,p.dt)({lamports:(0,p.Rx)(),address:Hr}))),Sn=(0,p.dt)({executable:(0,p.O7)(),owner:Hr,lamports:(0,p.Rx)(),data:Vr,rentEpoch:(0,p.Rx)()}),Pn=(0,p.dt)({pubkey:Hr,account:Sn}),An=(0,p.oQ)((0,p.G0)([(0,p.eE)(i.Buffer),kn]),(0,p.G0)([Gr,kn]),(e=>Array.isArray(e)?(0,p.Ue)(e,Vr):e)),Rn=(0,p.dt)({executable:(0,p.O7)(),owner:Hr,lamports:(0,p.Rx)(),data:An,rentEpoch:(0,p.Rx)()}),Cn=(0,p.dt)({pubkey:Hr,account:Rn}),Tn=(0,p.dt)({state:(0,p.G0)([(0,p.i0)("active"),(0,p.i0)("inactive"),(0,p.i0)("activating"),(0,p.i0)("deactivating")]),active:(0,p.Rx)(),inactive:(0,p.Rx)()}),Dn=Yr((0,p.IX)((0,p.dt)({signature:(0,p.Z_)(),slot:(0,p.Rx)(),err:an,memo:(0,p.AG)((0,p.Z_)()),blockTime:(0,p.jt)((0,p.AG)((0,p.Rx)()))}))),Bn=Yr((0,p.IX)((0,p.dt)({signature:(0,p.Z_)(),slot:(0,p.Rx)(),err:an,memo:(0,p.AG)((0,p.Z_)()),blockTime:(0,p.jt)((0,p.AG)((0,p.Rx)()))}))),xn=(0,p.dt)({subscription:(0,p.Rx)(),result:en(Sn)}),Nn=(0,p.dt)({pubkey:Hr,account:Sn}),On=(0,p.dt)({subscription:(0,p.Rx)(),result:en(Nn)}),Ln=(0,p.dt)({parent:(0,p.Rx)(),slot:(0,p.Rx)(),root:(0,p.Rx)()}),Mn=(0,p.dt)({subscription:(0,p.Rx)(),result:Ln}),jn=(0,p.G0)([(0,p.dt)({type:(0,p.G0)([(0,p.i0)("firstShredReceived"),(0,p.i0)("completed"),(0,p.i0)("optimisticConfirmation"),(0,p.i0)("root")]),slot:(0,p.Rx)(),timestamp:(0,p.Rx)()}),(0,p.dt)({type:(0,p.i0)("createdBank"),parent:(0,p.Rx)(),slot:(0,p.Rx)(),timestamp:(0,p.Rx)()}),(0,p.dt)({type:(0,p.i0)("frozen"),slot:(0,p.Rx)(),timestamp:(0,p.Rx)(),stats:(0,p.dt)({numTransactionEntries:(0,p.Rx)(),numSuccessfulTransactions:(0,p.Rx)(),numFailedTransactions:(0,p.Rx)(),maxTransactionsPerEntry:(0,p.Rx)()})}),(0,p.dt)({type:(0,p.i0)("dead"),slot:(0,p.Rx)(),timestamp:(0,p.Rx)(),err:(0,p.Z_)()})]),Un=(0,p.dt)({subscription:(0,p.Rx)(),result:jn}),zn=(0,p.dt)({subscription:(0,p.Rx)(),result:en((0,p.G0)([cn,ln]))}),Wn=(0,p.dt)({subscription:(0,p.Rx)(),result:(0,p.Rx)()}),$n=(0,p.dt)({pubkey:(0,p.Z_)(),gossip:(0,p.AG)((0,p.Z_)()),tpu:(0,p.AG)((0,p.Z_)()),rpc:(0,p.AG)((0,p.Z_)()),version:(0,p.AG)((0,p.Z_)())}),Fn=(0,p.dt)({votePubkey:(0,p.Z_)(),nodePubkey:(0,p.Z_)(),activatedStake:(0,p.Rx)(),epochVoteAccount:(0,p.O7)(),epochCredits:(0,p.IX)((0,p.bc)([(0,p.Rx)(),(0,p.Rx)(),(0,p.Rx)()])),commission:(0,p.Rx)(),lastVote:(0,p.Rx)(),rootSlot:(0,p.AG)((0,p.Rx)())}),Kn=Yr((0,p.dt)({current:(0,p.IX)(Fn),delinquent:(0,p.IX)(Fn)})),qn=(0,p.G0)([(0,p.i0)("processed"),(0,p.i0)("confirmed"),(0,p.i0)("finalized")]),Hn=(0,p.dt)({slot:(0,p.Rx)(),confirmations:(0,p.AG)((0,p.Rx)()),err:an,confirmationStatus:(0,p.jt)(qn)}),Gn=Qr((0,p.IX)((0,p.AG)(Hn))),Vn=Yr((0,p.Rx)()),Xn=(0,p.dt)({signatures:(0,p.IX)((0,p.Z_)()),message:(0,p.dt)({accountKeys:(0,p.IX)((0,p.Z_)()),header:(0,p.dt)({numRequiredSignatures:(0,p.Rx)(),numReadonlySignedAccounts:(0,p.Rx)(),numReadonlyUnsignedAccounts:(0,p.Rx)()}),instructions:(0,p.IX)((0,p.dt)({accounts:(0,p.IX)((0,p.Rx)()),data:(0,p.Z_)(),programIdIndex:(0,p.Rx)()})),recentBlockhash:(0,p.Z_)()})}),Jn=(0,p.dt)({parsed:(0,p._4)(),program:(0,p.Z_)(),programId:Hr}),Zn=(0,p.dt)({accounts:(0,p.IX)(Hr),data:(0,p.Z_)(),programId:Hr}),Yn=(0,p.G0)([Zn,Jn]),Qn=(0,p.G0)([(0,p.dt)({parsed:(0,p._4)(),program:(0,p.Z_)(),programId:(0,p.Z_)()}),(0,p.dt)({accounts:(0,p.IX)((0,p.Z_)()),data:(0,p.Z_)(),programId:(0,p.Z_)()})]),es=(0,p.oQ)(Yn,Qn,(e=>"accounts"in e?(0,p.Ue)(e,Zn):(0,p.Ue)(e,Jn))),ts=(0,p.dt)({signatures:(0,p.IX)((0,p.Z_)()),message:(0,p.dt)({accountKeys:(0,p.IX)((0,p.dt)({pubkey:Hr,signer:(0,p.O7)(),writable:(0,p.O7)()})),instructions:(0,p.IX)(es),recentBlockhash:(0,p.Z_)()})}),rs=(0,p.dt)({accountIndex:(0,p.Rx)(),mint:(0,p.Z_)(),owner:(0,p.jt)((0,p.Z_)()),uiTokenAmount:bn}),ns=(0,p.dt)({err:an,fee:(0,p.Rx)(),innerInstructions:(0,p.jt)((0,p.AG)((0,p.IX)((0,p.dt)({index:(0,p.Rx)(),instructions:(0,p.IX)((0,p.dt)({accounts:(0,p.IX)((0,p.Rx)()),data:(0,p.Z_)(),programIdIndex:(0,p.Rx)()}))})))),preBalances:(0,p.IX)((0,p.Rx)()),postBalances:(0,p.IX)((0,p.Rx)()),logMessages:(0,p.jt)((0,p.AG)((0,p.IX)((0,p.Z_)()))),preTokenBalances:(0,p.jt)((0,p.AG)((0,p.IX)(rs))),postTokenBalances:(0,p.jt)((0,p.AG)((0,p.IX)(rs)))}),ss=(0,p.dt)({err:an,fee:(0,p.Rx)(),innerInstructions:(0,p.jt)((0,p.AG)((0,p.IX)((0,p.dt)({index:(0,p.Rx)(),instructions:(0,p.IX)(es)})))),preBalances:(0,p.IX)((0,p.Rx)()),postBalances:(0,p.IX)((0,p.Rx)()),logMessages:(0,p.jt)((0,p.AG)((0,p.IX)((0,p.Z_)()))),preTokenBalances:(0,p.jt)((0,p.AG)((0,p.IX)(rs))),postTokenBalances:(0,p.jt)((0,p.AG)((0,p.IX)(rs)))}),is=Yr((0,p.AG)((0,p.dt)({blockhash:(0,p.Z_)(),previousBlockhash:(0,p.Z_)(),parentSlot:(0,p.Rx)(),transactions:(0,p.IX)((0,p.dt)({transaction:Xn,meta:(0,p.AG)(ns)})),rewards:(0,p.jt)((0,p.IX)((0,p.dt)({pubkey:(0,p.Z_)(),lamports:(0,p.Rx)(),postBalance:(0,p.AG)((0,p.Rx)()),rewardType:(0,p.AG)((0,p.Z_)())}))),blockTime:(0,p.AG)((0,p.Rx)()),blockHeight:(0,p.AG)((0,p.Rx)())}))),os=Yr((0,p.AG)((0,p.dt)({blockhash:(0,p.Z_)(),previousBlockhash:(0,p.Z_)(),parentSlot:(0,p.Rx)(),transactions:(0,p.IX)((0,p.dt)({transaction:Xn,meta:(0,p.AG)(ns)})),rewards:(0,p.jt)((0,p.IX)((0,p.dt)({pubkey:(0,p.Z_)(),lamports:(0,p.Rx)(),postBalance:(0,p.AG)((0,p.Rx)()),rewardType:(0,p.AG)((0,p.Z_)())}))),blockTime:(0,p.AG)((0,p.Rx)())}))),as=Yr((0,p.AG)((0,p.dt)({blockhash:(0,p.Z_)(),previousBlockhash:(0,p.Z_)(),parentSlot:(0,p.Rx)(),signatures:(0,p.IX)((0,p.Z_)()),blockTime:(0,p.AG)((0,p.Rx)())}))),cs=Yr((0,p.AG)((0,p.dt)({slot:(0,p.Rx)(),meta:ns,blockTime:(0,p.jt)((0,p.AG)((0,p.Rx)())),transaction:Xn}))),ls=Yr((0,p.AG)((0,p.dt)({slot:(0,p.Rx)(),transaction:ts,meta:(0,p.AG)(ss),blockTime:(0,p.jt)((0,p.AG)((0,p.Rx)()))}))),us=Qr((0,p.dt)({blockhash:(0,p.Z_)(),feeCalculator:(0,p.dt)({lamportsPerSignature:(0,p.Rx)()})})),ds=Qr((0,p.dt)({blockhash:(0,p.Z_)(),lastValidBlockHeight:(0,p.Rx)()})),hs=(0,p.dt)({slot:(0,p.Rx)(),numTransactions:(0,p.Rx)(),numSlots:(0,p.Rx)(),samplePeriodSecs:(0,p.Rx)()}),ps=Yr((0,p.IX)(hs)),fs=Qr((0,p.AG)((0,p.dt)({feeCalculator:(0,p.dt)({lamportsPerSignature:(0,p.Rx)()})}))),gs=Yr((0,p.Z_)()),ys=Yr((0,p.Z_)()),ms=(0,p.dt)({err:an,logs:(0,p.IX)((0,p.Z_)()),signature:(0,p.Z_)()}),ws=(0,p.dt)({result:en(ms),subscription:(0,p.Rx)()});class bs{constructor(e,t){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set;let r=new URL(e);r.protocol;let n,s,i,o,a;var c;t&&"string"===typeof t?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,n=t.wsEndpoint,s=t.httpHeaders,i=t.fetch,o=t.fetchMiddleware,a=t.disableRetryOnRateLimit),this._rpcEndpoint=e,this._rpcWsEndpoint=n||function(e){let t=new URL(e);const r="https:"===t.protocol;return t.protocol=r?"wss:":"ws:",t.host="",""!==t.port&&(t.port=String(Number(t.port)+1)),t.toString()}(e),this._rpcClient=function(e,t,r,n,s,i){const o=n||Fr;let a;return s&&(a=async(e,t)=>{const r=await new Promise(((r,n)=>{try{s(e,t,((e,t)=>r([e,t])))}catch(i){n(i)}}));return await o(...r)}),new(y())((async(t,n)=>{const s={method:"POST",body:t,agent:void 0,headers:Object.assign({"Content-Type":"application/json"},r||{})};try{let t,r=5,c=500;for(;t=a?await a(e,s):await o(e,s),429===t.status&&!0!==i&&(r-=1,0!==r);)console.log(`Server responded with ${t.status} ${t.statusText}.  Retrying after ${c}ms delay...`),await mr(c),c*=2;const l=await t.text();t.ok?n(null,l):n(new Error(`${t.status} ${t.statusText}: ${l}`))}catch(c){c instanceof Error&&n(c)}}),{})}(r.toString(),0,s,i,o,a),this._rpcRequest=(c=this._rpcClient,(e,t)=>new Promise(((r,n)=>{c.request(e,t,((e,t)=>{e?n(e):r(t)}))}))),this._rpcBatchRequest=function(e){return t=>new Promise(((r,n)=>{0===t.length&&r([]);const s=t.map((t=>e.request(t.methodName,t.args)));e.request(s,((e,t)=>{e?n(e):r(t)}))}))}(this._rpcClient),this._rpcWebSocket=new f.K(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){const r=this._buildArgs([e.toBase58()],t),n=await this._rpcRequest("getBalance",r),s=(0,p.Ue)(n,Qr((0,p.Rx)()));if("error"in s)throw new Error("failed to get balance for "+e.toBase58()+": "+s.error.message);return s.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then((e=>e.value)).catch((t=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+t)}))}async getBlockTime(e){const t=await this._rpcRequest("getBlockTime",[e]),r=(0,p.Ue)(t,Yr((0,p.AG)((0,p.Rx)())));if("error"in r)throw new Error("failed to get block time for slot "+e+": "+r.error.message);return r.result}async getMinimumLedgerSlot(){const e=await this._rpcRequest("minimumLedgerSlot",[]),t=(0,p.Ue)(e,Yr((0,p.Rx)()));if("error"in t)throw new Error("failed to get minimum ledger slot: "+t.error.message);return t.result}async getFirstAvailableBlock(){const e=await this._rpcRequest("getFirstAvailableBlock",[]),t=(0,p.Ue)(e,mn);if("error"in t)throw new Error("failed to get first available block: "+t.error.message);return t.result}async getSupply(e){let t={};t="string"===typeof e?{commitment:e}:e?{...e,commitment:e&&e.commitment||this.commitment}:{commitment:this.commitment};const r=await this._rpcRequest("getSupply",[t]),n=(0,p.Ue)(r,wn);if("error"in n)throw new Error("failed to get supply: "+n.error.message);return n.result}async getTokenSupply(e,t){const r=this._buildArgs([e.toBase58()],t),n=await this._rpcRequest("getTokenSupply",r),s=(0,p.Ue)(n,Qr(bn));if("error"in s)throw new Error("failed to get token supply: "+s.error.message);return s.result}async getTokenAccountBalance(e,t){const r=this._buildArgs([e.toBase58()],t),n=await this._rpcRequest("getTokenAccountBalance",r),s=(0,p.Ue)(n,Qr(bn));if("error"in s)throw new Error("failed to get token account balance: "+s.error.message);return s.result}async getTokenAccountsByOwner(e,t,r){let n=[e.toBase58()];"mint"in t?n.push({mint:t.mint.toBase58()}):n.push({programId:t.programId.toBase58()});const s=this._buildArgs(n,r,"base64"),i=await this._rpcRequest("getTokenAccountsByOwner",s),o=(0,p.Ue)(i,_n);if("error"in o)throw new Error("failed to get token accounts owned by account "+e.toBase58()+": "+o.error.message);return o.result}async getParsedTokenAccountsByOwner(e,t,r){let n=[e.toBase58()];"mint"in t?n.push({mint:t.mint.toBase58()}):n.push({programId:t.programId.toBase58()});const s=this._buildArgs(n,r,"jsonParsed"),i=await this._rpcRequest("getTokenAccountsByOwner",s),o=(0,p.Ue)(i,En);if("error"in o)throw new Error("failed to get token accounts owned by account "+e.toBase58()+": "+o.error.message);return o.result}async getLargestAccounts(e){const t={...e,commitment:e&&e.commitment||this.commitment},r=t.filter||t.commitment?[t]:[],n=await this._rpcRequest("getLargestAccounts",r),s=(0,p.Ue)(n,In);if("error"in s)throw new Error("failed to get largest accounts: "+s.error.message);return s.result}async getTokenLargestAccounts(e,t){const r=this._buildArgs([e.toBase58()],t),n=await this._rpcRequest("getTokenLargestAccounts",r),s=(0,p.Ue)(n,vn);if("error"in s)throw new Error("failed to get token largest accounts: "+s.error.message);return s.result}async getAccountInfoAndContext(e,t){const r=this._buildArgs([e.toBase58()],t,"base64"),n=await this._rpcRequest("getAccountInfo",r),s=(0,p.Ue)(n,Qr((0,p.AG)(Sn)));if("error"in s)throw new Error("failed to get info about account "+e.toBase58()+": "+s.error.message);return s.result}async getParsedAccountInfo(e,t){const r=this._buildArgs([e.toBase58()],t,"jsonParsed"),n=await this._rpcRequest("getAccountInfo",r),s=(0,p.Ue)(n,Qr((0,p.AG)(Rn)));if("error"in s)throw new Error("failed to get info about account "+e.toBase58()+": "+s.error.message);return s.result}async getAccountInfo(e,t){try{return(await this.getAccountInfoAndContext(e,t)).value}catch(r){throw new Error("failed to get info about account "+e.toBase58()+": "+r)}}async getMultipleAccountsInfoAndContext(e,t){const r=e.map((e=>e.toBase58())),n=this._buildArgs([r],t,"base64"),s=await this._rpcRequest("getMultipleAccounts",n),i=(0,p.Ue)(s,Qr((0,p.IX)((0,p.AG)(Sn))));if("error"in i)throw new Error("failed to get info for accounts "+r+": "+i.error.message);return i.result}async getMultipleAccountsInfo(e,t){return(await this.getMultipleAccountsInfoAndContext(e,t)).value}async getStakeActivation(e,t,r){const n=this._buildArgs([e.toBase58()],t,void 0,void 0!==r?{epoch:r}:void 0),s=await this._rpcRequest("getStakeActivation",n),i=(0,p.Ue)(s,Yr(Tn));if("error"in i)throw new Error(`failed to get Stake Activation ${e.toBase58()}: ${i.error.message}`);return i.result}async getProgramAccounts(e,t){const r={};let n,s;t&&("string"===typeof t?n=t:(n=t.commitment,s=t.encoding,t.dataSlice&&(r.dataSlice=t.dataSlice),t.filters&&(r.filters=t.filters)));const i=this._buildArgs([e.toBase58()],n,s||"base64",r),o=await this._rpcRequest("getProgramAccounts",i),a=(0,p.Ue)(o,Yr((0,p.IX)(Pn)));if("error"in a)throw new Error("failed to get accounts owned by program "+e.toBase58()+": "+a.error.message);return a.result}async getParsedProgramAccounts(e,t){const r={};let n;t&&("string"===typeof t?n=t:(n=t.commitment,t.filters&&(r.filters=t.filters)));const s=this._buildArgs([e.toBase58()],n,"jsonParsed",r),i=await this._rpcRequest("getProgramAccounts",s),o=(0,p.Ue)(i,Yr((0,p.IX)(Cn)));if("error"in o)throw new Error("failed to get accounts owned by program "+e.toBase58()+": "+o.error.message);return o.result}async confirmTransaction(e,t){let r,n;if("string"==typeof e)r=e;else{r=e.signature}try{n=l().decode(r)}catch(p){throw new Error("signature must be base58 encoded: "+r)}rr(64===n.length,"signature has invalid length");const s=t||this.commitment;let i,o,a=!1;const c=new Promise(((e,t)=>{try{o=this.onSignature(r,((t,r)=>{o=void 0;const n={context:r,value:t};a=!0,e({__type:nr.PROCESSED,response:n})}),s)}catch(p){t(p)}})),u=async()=>{try{return await this.getBlockHeight(t)}catch(e){return-1}},d=new Promise((t=>{if("string"===typeof e){let e=this._confirmTransactionInitialTimeout||6e4;switch(s){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":e=this._confirmTransactionInitialTimeout||3e4}i=setTimeout((()=>t({__type:nr.TIMED_OUT,timeoutMs:e})),e)}else{let r=e;(async()=>{let e=await u();if(!a){for(;e<=r.lastValidBlockHeight;){if(await mr(1e3),a)return;if(e=await u(),a)return}t({__type:nr.BLOCKHEIGHT_EXCEEDED})}})()}}));let h;try{const e=await Promise.race([c,d]);switch(e.__type){case nr.BLOCKHEIGHT_EXCEEDED:throw new Kr(r);case nr.PROCESSED:h=e.response;break;case nr.TIMED_OUT:throw new qr(r,e.timeoutMs/1e3)}}finally{clearTimeout(i),o&&this.removeSignatureListener(o)}return h}async getClusterNodes(){const e=await this._rpcRequest("getClusterNodes",[]),t=(0,p.Ue)(e,Yr((0,p.IX)($n)));if("error"in t)throw new Error("failed to get cluster nodes: "+t.error.message);return t.result}async getVoteAccounts(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getVoteAccounts",t),n=(0,p.Ue)(r,Kn);if("error"in n)throw new Error("failed to get vote accounts: "+n.error.message);return n.result}async getSlot(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getSlot",t),n=(0,p.Ue)(r,Yr((0,p.Rx)()));if("error"in n)throw new Error("failed to get slot: "+n.error.message);return n.result}async getSlotLeader(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getSlotLeader",t),n=(0,p.Ue)(r,Yr((0,p.Z_)()));if("error"in n)throw new Error("failed to get slot leader: "+n.error.message);return n.result}async getSlotLeaders(e,t){const r=[e,t],n=await this._rpcRequest("getSlotLeaders",r),s=(0,p.Ue)(n,Yr((0,p.IX)(Hr)));if("error"in s)throw new Error("failed to get slot leaders: "+s.error.message);return s.result}async getSignatureStatus(e,t){const{context:r,value:n}=await this.getSignatureStatuses([e],t);rr(1===n.length);return{context:r,value:n[0]}}async getSignatureStatuses(e,t){const r=[e];t&&r.push(t);const n=await this._rpcRequest("getSignatureStatuses",r),s=(0,p.Ue)(n,Gn);if("error"in s)throw new Error("failed to get signature status: "+s.error.message);return s.result}async getTransactionCount(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getTransactionCount",t),n=(0,p.Ue)(r,Yr((0,p.Rx)()));if("error"in n)throw new Error("failed to get transaction count: "+n.error.message);return n.result}async getTotalSupply(e){return(await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getInflationGovernor",t),n=(0,p.Ue)(r,pn);if("error"in n)throw new Error("failed to get inflation: "+n.error.message);return n.result}async getInflationReward(e,t,r){const n=this._buildArgs([e.map((e=>e.toBase58()))],r,void 0,{epoch:t}),s=await this._rpcRequest("getInflationReward",n),i=(0,p.Ue)(s,rn);if("error"in i)throw new Error("failed to get inflation reward: "+i.error.message);return i.result}async getEpochInfo(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getEpochInfo",t),n=(0,p.Ue)(r,fn);if("error"in n)throw new Error("failed to get epoch info: "+n.error.message);return n.result}async getEpochSchedule(){const e=await this._rpcRequest("getEpochSchedule",[]),t=(0,p.Ue)(e,gn);if("error"in t)throw new Error("failed to get epoch schedule: "+t.error.message);const r=t.result;return new Wr(r.slotsPerEpoch,r.leaderScheduleSlotOffset,r.warmup,r.firstNormalEpoch,r.firstNormalSlot)}async getLeaderSchedule(){const e=await this._rpcRequest("getLeaderSchedule",[]),t=(0,p.Ue)(e,yn);if("error"in t)throw new Error("failed to get leader schedule: "+t.error.message);return t.result}async getMinimumBalanceForRentExemption(e,t){const r=this._buildArgs([e],t),n=await this._rpcRequest("getMinimumBalanceForRentExemption",r),s=(0,p.Ue)(n,Vn);return"error"in s?(console.warn("Unable to fetch minimum balance for rent exemption"),0):s.result}async getRecentBlockhashAndContext(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getRecentBlockhash",t),n=(0,p.Ue)(r,us);if("error"in n)throw new Error("failed to get recent blockhash: "+n.error.message);return n.result}async getRecentPerformanceSamples(e){const t=this._buildArgs(e?[e]:[]),r=await this._rpcRequest("getRecentPerformanceSamples",t),n=(0,p.Ue)(r,ps);if("error"in n)throw new Error("failed to get recent performance samples: "+n.error.message);return n.result}async getFeeCalculatorForBlockhash(e,t){const r=this._buildArgs([e],t),n=await this._rpcRequest("getFeeCalculatorForBlockhash",r),s=(0,p.Ue)(n,fs);if("error"in s)throw new Error("failed to get fee calculator: "+s.error.message);const{context:i,value:o}=s.result;return{context:i,value:null!==o?o.feeCalculator:null}}async getFeeForMessage(e,t){const r=e.serialize().toString("base64"),n=this._buildArgs([r],t),s=await this._rpcRequest("getFeeForMessage",n),i=(0,p.Ue)(s,Qr((0,p.AG)((0,p.Rx)())));if("error"in i)throw new Error("failed to get slot: "+i.error.message);if(null===i.result)throw new Error("invalid blockhash");return i.result}async getRecentBlockhash(e){try{return(await this.getRecentBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(e){try{return(await this.getLatestBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getLatestBlockhash",t),n=(0,p.Ue)(r,ds);if("error"in n)throw new Error("failed to get latest blockhash: "+n.error.message);return n.result}async getVersion(){const e=await this._rpcRequest("getVersion",[]),t=(0,p.Ue)(e,Yr(un));if("error"in t)throw new Error("failed to get version: "+t.error.message);return t.result}async getGenesisHash(){const e=await this._rpcRequest("getGenesisHash",[]),t=(0,p.Ue)(e,Yr((0,p.Z_)()));if("error"in t)throw new Error("failed to get genesis hash: "+t.error.message);return t.result}async getBlock(e,t){const r=this._buildArgsAtLeastConfirmed([e],t&&t.commitment),n=await this._rpcRequest("getBlock",r),s=(0,p.Ue)(n,is);if("error"in s)throw new Error("failed to get confirmed block: "+s.error.message);const i=s.result;return i?{...i,transactions:i.transactions.map((e=>{let{transaction:t,meta:r}=e;const n=new tr(t.message);return{meta:r,transaction:{...t,message:n}}}))}:i}async getBlockHeight(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getBlockHeight",t),n=(0,p.Ue)(r,Yr((0,p.Rx)()));if("error"in n)throw new Error("failed to get block height information: "+n.error.message);return n.result}async getBlockProduction(e){let t,r;if("string"===typeof e)r=e;else if(e){const{commitment:n,...s}=e;r=n,t=s}const n=this._buildArgs([],r,"base64",t),s=await this._rpcRequest("getBlockProduction",n),i=(0,p.Ue)(s,hn);if("error"in i)throw new Error("failed to get block production information: "+i.error.message);return i.result}async getTransaction(e,t){const r=this._buildArgsAtLeastConfirmed([e],t&&t.commitment),n=await this._rpcRequest("getTransaction",r),s=(0,p.Ue)(n,cs);if("error"in s)throw new Error("failed to get transaction: "+s.error.message);const i=s.result;return i?{...i,transaction:{...i.transaction,message:new tr(i.transaction.message)}}:i}async getParsedTransaction(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),n=await this._rpcRequest("getTransaction",r),s=(0,p.Ue)(n,ls);if("error"in s)throw new Error("failed to get transaction: "+s.error.message);return s.result}async getParsedTransactions(e,t){const r=e.map((e=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([e],t,"jsonParsed")})));return(await this._rpcBatchRequest(r)).map((e=>{const t=(0,p.Ue)(e,ls);if("error"in t)throw new Error("failed to get transactions: "+t.error.message);return t.result}))}async getTransactions(e,t){const r=e.map((e=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([e],t)})));return(await this._rpcBatchRequest(r)).map((e=>{const t=(0,p.Ue)(e,cs);if("error"in t)throw new Error("failed to get transactions: "+t.error.message);return t.result}))}async getConfirmedBlock(e,t){const r=this._buildArgsAtLeastConfirmed([e],t),n=await this._rpcRequest("getConfirmedBlock",r),s=(0,p.Ue)(n,os);if("error"in s)throw new Error("failed to get confirmed block: "+s.error.message);const i=s.result;if(!i)throw new Error("Confirmed block "+e+" not found");const o={...i,transactions:i.transactions.map((e=>{let{transaction:t,meta:r}=e;const n=new tr(t.message);return{meta:r,transaction:{...t,message:n}}}))};return{...o,transactions:o.transactions.map((e=>{let{transaction:t,meta:r}=e;return{meta:r,transaction:or.populate(t.message,t.signatures)}}))}}async getBlocks(e,t,r){const n=this._buildArgsAtLeastConfirmed(void 0!==t?[e,t]:[e],r),s=await this._rpcRequest("getBlocks",n),i=(0,p.Ue)(s,Yr((0,p.IX)((0,p.Rx)())));if("error"in i)throw new Error("failed to get blocks: "+i.error.message);return i.result}async getBlockSignatures(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),n=await this._rpcRequest("getBlock",r),s=(0,p.Ue)(n,as);if("error"in s)throw new Error("failed to get block: "+s.error.message);const i=s.result;if(!i)throw new Error("Block "+e+" not found");return i}async getConfirmedBlockSignatures(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),n=await this._rpcRequest("getConfirmedBlock",r),s=(0,p.Ue)(n,as);if("error"in s)throw new Error("failed to get confirmed block: "+s.error.message);const i=s.result;if(!i)throw new Error("Confirmed block "+e+" not found");return i}async getConfirmedTransaction(e,t){const r=this._buildArgsAtLeastConfirmed([e],t),n=await this._rpcRequest("getConfirmedTransaction",r),s=(0,p.Ue)(n,cs);if("error"in s)throw new Error("failed to get transaction: "+s.error.message);const i=s.result;if(!i)return i;const o=new tr(i.transaction.message),a=i.transaction.signatures;return{...i,transaction:or.populate(o,a)}}async getParsedConfirmedTransaction(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),n=await this._rpcRequest("getConfirmedTransaction",r),s=(0,p.Ue)(n,ls);if("error"in s)throw new Error("failed to get confirmed transaction: "+s.error.message);return s.result}async getParsedConfirmedTransactions(e,t){const r=e.map((e=>({methodName:"getConfirmedTransaction",args:this._buildArgsAtLeastConfirmed([e],t,"jsonParsed")})));return(await this._rpcBatchRequest(r)).map((e=>{const t=(0,p.Ue)(e,ls);if("error"in t)throw new Error("failed to get confirmed transactions: "+t.error.message);return t.result}))}async getConfirmedSignaturesForAddress(e,t,r){let n={},s=await this.getFirstAvailableBlock();for(;!("until"in n)&&!(--t<=0||t<s);)try{const e=await this.getConfirmedBlockSignatures(t,"finalized");e.signatures.length>0&&(n.until=e.signatures[e.signatures.length-1].toString())}catch(o){if(o instanceof Error&&o.message.includes("skipped"))continue;throw o}let i=await this.getSlot("finalized");for(;!("before"in n)&&!(++r>i);)try{const e=await this.getConfirmedBlockSignatures(r);e.signatures.length>0&&(n.before=e.signatures[e.signatures.length-1].toString())}catch(o){if(o instanceof Error&&o.message.includes("skipped"))continue;throw o}return(await this.getConfirmedSignaturesForAddress2(e,n)).map((e=>e.signature))}async getConfirmedSignaturesForAddress2(e,t,r){const n=this._buildArgsAtLeastConfirmed([e.toBase58()],r,void 0,t),s=await this._rpcRequest("getConfirmedSignaturesForAddress2",n),i=(0,p.Ue)(s,Dn);if("error"in i)throw new Error("failed to get confirmed signatures for address: "+i.error.message);return i.result}async getSignaturesForAddress(e,t,r){const n=this._buildArgsAtLeastConfirmed([e.toBase58()],r,void 0,t),s=await this._rpcRequest("getSignaturesForAddress",n),i=(0,p.Ue)(s,Bn);if("error"in i)throw new Error("failed to get signatures for address: "+i.error.message);return i.result}async getNonceAndContext(e,t){const{context:r,value:n}=await this.getAccountInfoAndContext(e,t);let s=null;return null!==n&&(s=Er.fromAccountData(n.data)),{context:r,value:s}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then((e=>e.value)).catch((t=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+t)}))}async requestAirdrop(e,t){const r=await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),n=(0,p.Ue)(r,gs);if("error"in n)throw new Error("airdrop to "+e.toBase58()+" failed: "+n.error.message);return n.result}async _blockhashWithExpiryBlockHeight(e){if(!e){for(;this._pollingBlockhash;)await mr(100);const e=Date.now()-this._blockhashInfo.lastFetch>=Xr;if(null!==this._blockhashInfo.latestBlockhash&&!e)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const e=Date.now(),t=this._blockhashInfo.latestBlockhash,r=t?t.blockhash:null;for(let n=0;n<50;n++){const e=await this.getLatestBlockhash("finalized");if(r!==e.blockhash)return this._blockhashInfo={latestBlockhash:e,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},e;await mr(200)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async simulateTransaction(e,t,r){let n;if(e instanceof or){let t=e;n=new or,n.feePayer=t.feePayer,n.instructions=e.instructions,n.nonceInfo=t.nonceInfo,n.signatures=t.signatures}else n=or.populate(e),n._message=n._json=void 0;if(n.nonceInfo&&t)n.sign(...t);else{let e=this._disableBlockhashCaching;for(;;){const r=await this._blockhashWithExpiryBlockHeight(e);if(n.lastValidBlockHeight=r.lastValidBlockHeight,n.recentBlockhash=r.blockhash,!t)break;if(n.sign(...t),!n.signature)throw new Error("!signature");const s=n.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(s)&&!this._blockhashInfo.transactionSignatures.includes(s)){this._blockhashInfo.simulatedSignatures.push(s);break}e=!0}}const s=n._compile(),i=s.serialize(),o=n._serialize(i).toString("base64"),a={encoding:"base64",commitment:this.commitment};if(r){const e=(Array.isArray(r)?r:s.nonProgramIds()).map((e=>e.toBase58()));a.accounts={encoding:"base64",addresses:e}}t&&(a.sigVerify=!0);const c=[o,a],l=await this._rpcRequest("simulateTransaction",c),u=(0,p.Ue)(l,dn);if("error"in u){let e;if("data"in u.error&&(e=u.error.data.logs,e&&Array.isArray(e))){const t="\n    ",r=t+e.join(t);console.error(u.error.message,r)}throw new $r("failed to simulate transaction: "+u.error.message,e)}return u.result}async sendTransaction(e,t,r){if(e.nonceInfo)e.sign(...t);else{let r=this._disableBlockhashCaching;for(;;){const n=await this._blockhashWithExpiryBlockHeight(r);if(e.lastValidBlockHeight=n.lastValidBlockHeight,e.recentBlockhash=n.blockhash,e.sign(...t),!e.signature)throw new Error("!signature");const s=e.signature.toString("base64");if(!this._blockhashInfo.transactionSignatures.includes(s)){this._blockhashInfo.transactionSignatures.push(s);break}r=!0}}const n=e.serialize();return await this.sendRawTransaction(n,r)}async sendRawTransaction(e,t){const r=_(e).toString("base64");return await this.sendEncodedTransaction(r,t)}async sendEncodedTransaction(e,t){const r={encoding:"base64"},n=t&&t.skipPreflight,s=t&&t.preflightCommitment||this.commitment;t&&t.maxRetries&&(r.maxRetries=t.maxRetries),n&&(r.skipPreflight=n),s&&(r.preflightCommitment=s);const i=[e,r],o=await this._rpcRequest("sendTransaction",i),a=(0,p.Ue)(o,ys);if("error"in a){let e;throw"data"in a.error&&(e=a.error.data.logs),new $r("failed to send transaction: "+a.error.message,e)}return a.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval((()=>{this._rpcWebSocket.notify("ping").catch((()=>{}))}),5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration++,this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),1e3!==e?(this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach((e=>{let[t,r]=e;this._subscriptionsByHash[t]={...r,state:"pending"}}))):this._updateSubscriptions()}async _updateSubscriptions(){if(0===Object.keys(this._subscriptionsByHash).length)return void(this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout((()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(e){e instanceof Error&&console.log(`Error when closing socket connection: ${e.message}`)}}),500)));if(null!==this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected)return void this._rpcWebSocket.connect();const e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map((async e=>{const r=this._subscriptionsByHash[e];if(void 0!==r)switch(r.state){case"pending":case"unsubscribed":if(0===r.callbacks.size)return delete this._subscriptionsByHash[e],"unsubscribed"===r.state&&delete this._subscriptionCallbacksByServerSubscriptionId[r.serverSubscriptionId],void await this._updateSubscriptions();await(async()=>{const{args:n,method:s}=r;try{this._subscriptionsByHash[e]={...r,state:"subscribing"};const t=await this._rpcWebSocket.call(s,n);this._subscriptionsByHash[e]={...r,serverSubscriptionId:t,state:"subscribed"},this._subscriptionCallbacksByServerSubscriptionId[t]=r.callbacks,await this._updateSubscriptions()}catch(i){if(i instanceof Error&&console.error(`${s} error for argument`,n,i.message),!t())return;this._subscriptionsByHash[e]={...r,state:"pending"},await this._updateSubscriptions()}})();break;case"subscribed":0===r.callbacks.size&&await(async()=>{const{serverSubscriptionId:n,unsubscribeMethod:s}=r;if(this._subscriptionsAutoDisposedByRpc.has(n))this._subscriptionsAutoDisposedByRpc.delete(n);else{this._subscriptionsByHash[e]={...r,state:"unsubscribing"};try{await this._rpcWebSocket.call(s,[n])}catch(i){if(i instanceof Error&&console.error(`${s} error:`,i.message),!t())return;return this._subscriptionsByHash[e]={...r,state:"subscribed"},void await this._updateSubscriptions()}}this._subscriptionsByHash[e]={...r,state:"unsubscribed"},await this._updateSubscriptions()})()}})))}_handleServerNotification(e,t){const r=this._subscriptionCallbacksByServerSubscriptionId[e];void 0!==r&&r.forEach((e=>{try{e(...t)}catch(r){console.error(r)}}))}_wsOnAccountNotification(e){const{result:t,subscription:r}=(0,p.Ue)(e,xn);this._handleServerNotification(r,[t.value,t.context])}_makeSubscription(e,t){const r=this._nextClientSubscriptionId++,n=Ur([e.method,t],!0),s=this._subscriptionsByHash[n];return void 0===s?this._subscriptionsByHash[n]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:s.callbacks.add(e.callback),this._subscriptionDisposeFunctionsByClientSubscriptionId[r]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[r];const t=this._subscriptionsByHash[n];rr(void 0!==t,`Could not find a \`Subscription\` when tearing down client subscription #${r}`),t.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),r}onAccountChange(e,t,r){const n=this._buildArgs([e.toBase58()],r||this._commitment||"finalized","base64");return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},n)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){const{result:t,subscription:r}=(0,p.Ue)(e,On);this._handleServerNotification(r,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,r,n){const s=this._buildArgs([e.toBase58()],r||this._commitment||"finalized","base64",n?{filters:n}:void 0);return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},s)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,r){const n=this._buildArgs(["object"===typeof e?{mentions:[e.toString()]}:e],r||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},n)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){const{result:t,subscription:r}=(0,p.Ue)(e,ws);this._handleServerNotification(r,[t.value,t.context])}_wsOnSlotNotification(e){const{result:t,subscription:r}=(0,p.Ue)(e,Mn);this._handleServerNotification(r,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){const{result:t,subscription:r}=(0,p.Ue)(e,Un);this._handleServerNotification(r,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){const r=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];r?await r():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)}_buildArgs(e,t,r,n){const s=t||this._commitment;if(s||r||n){let t={};r&&(t.encoding=r),s&&(t.commitment=s),n&&(t=Object.assign(t,n)),e.push(t)}return e}_buildArgsAtLeastConfirmed(e,t,r,n){const s=t||this._commitment;if(s&&!["confirmed","finalized"].includes(s))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,r,n)}_wsOnSignatureNotification(e){const{result:t,subscription:r}=(0,p.Ue)(e,zn);"receivedSignature"!==t.value&&this._subscriptionsAutoDisposedByRpc.add(r),this._handleServerNotification(r,"receivedSignature"===t.value?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,r){const n=this._buildArgs([e],r||this._commitment||"finalized"),s=this._makeSubscription({callback:(e,r)=>{if("status"===e.type){t(e.result,r);try{this.removeSignatureListener(s)}catch(n){}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},n);return s}onSignatureWithOptions(e,t,r){const{commitment:n,...s}={...r,commitment:r&&r.commitment||this._commitment||"finalized"},i=this._buildArgs([e],n,void 0,s),o=this._makeSubscription({callback:(e,r)=>{t(e,r);try{this.removeSignatureListener(o)}catch(n){}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},i);return o}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){const{result:t,subscription:r}=(0,p.Ue)(e,Wn);this._handleServerNotification(r,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}class vs{constructor(e){this._keypair=void 0,this._keypair=e||s().sign.keyPair()}static generate(){return new vs(s().sign.keyPair())}static fromSecretKey(e,t){const r=s().sign.keyPair.fromSecretKey(e);if(!t||!t.skipValidation){const e=(new TextEncoder).encode("@solana/web3.js-validation-v1"),t=s().sign.detached(e,r.secretKey);if(!s().sign.detached.verify(e,t,r.publicKey))throw new Error("provided secretKey is invalid")}return new vs(r)}static fromSeed(e){return new vs(s().sign.keyPair.fromSeed(e))}get publicKey(){return new Wt(this._keypair.publicKey)}get secretKey(){return this._keypair.secretKey}}const _s=d.n_([d.u8("numSignatures"),d.u8("padding"),d.KB("signatureOffset"),d.KB("signatureInstructionIndex"),d.KB("publicKeyOffset"),d.KB("publicKeyInstructionIndex"),d.KB("messageDataOffset"),d.KB("messageDataSize"),d.KB("messageInstructionIndex")]);class ks{constructor(){}static createInstructionWithPublicKey(e){const{publicKey:t,message:r,signature:n,instructionIndex:s}=e;rr(32===t.length,`Public Key must be 32 bytes but received ${t.length} bytes`),rr(64===n.length,`Signature must be 64 bytes but received ${n.length} bytes`);const o=_s.span,a=o+t.length,c=a+n.length,l=i.Buffer.alloc(c+r.length),u=null==s?65535:s;return _s.encode({numSignatures:1,padding:0,signatureOffset:a,signatureInstructionIndex:u,publicKeyOffset:o,publicKeyInstructionIndex:u,messageDataOffset:c,messageDataSize:r.length,messageInstructionIndex:u},l),l.fill(t,o),l.fill(n,a),l.fill(r,c),new ir({keys:[],programId:ks.programId,data:l})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:r,instructionIndex:n}=e;rr(64===t.length,`Private key must be 64 bytes but received ${t.length} bytes`);try{const e=vs.fromSecretKey(t),i=e.publicKey.toBytes(),o=s().sign.detached(r,e.secretKey);return this.createInstructionWithPublicKey({publicKey:i,message:r,signature:o,instructionIndex:n})}catch(i){throw new Error(`Error creating instruction; ${i}`)}}}ks.programId=new Wt("Ed25519SigVerify111111111111111111111111111");const Es=new Wt("StakeConfig11111111111111111111111111111111");class Is{constructor(e,t){this.staker=void 0,this.withdrawer=void 0,this.staker=e,this.withdrawer=t}}class Ss{constructor(e,t,r){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=r}}Ss.default=new Ss(0,0,Wt.default);class Ps{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=d.Jq("instruction").decode(e.data);let r;for(const[n,s]of Object.entries(As))if(s.index==t){r=n;break}if(!r)throw new Error("Instruction type incorrect; not a StakeInstruction");return r}static decodeInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t,lockup:r}=br(As.Initialize,e.data);return{stakePubkey:e.keys[0].pubkey,authorized:new Is(new Wt(t.staker),new Wt(t.withdrawer)),lockup:new Ss(r.unixTimestamp,r.epoch,new Wt(r.custodian))}}static decodeDelegate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,6),br(As.Delegate,e.data),{stakePubkey:e.keys[0].pubkey,votePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[5].pubkey}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:t,stakeAuthorizationType:r}=br(As.Authorize,e.data),n={stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new Wt(t),stakeAuthorizationType:{index:r}};return e.keys.length>3&&(n.custodianPubkey=e.keys[3].pubkey),n}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{newAuthorized:t,stakeAuthorizationType:r,authoritySeed:n,authorityOwner:s}=br(As.AuthorizeWithSeed,e.data),i={stakePubkey:e.keys[0].pubkey,authorityBase:e.keys[1].pubkey,authoritySeed:n,authorityOwner:new Wt(s),newAuthorizedPubkey:new Wt(t),stakeAuthorizationType:{index:r}};return e.keys.length>3&&(i.custodianPubkey=e.keys[3].pubkey),i}static decodeSplit(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t}=br(As.Split,e.data);return{stakePubkey:e.keys[0].pubkey,splitStakePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[2].pubkey,lamports:t}}static decodeMerge(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),br(As.Merge,e.data),{stakePubkey:e.keys[0].pubkey,sourceStakePubKey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=br(As.Withdraw,e.data),r={stakePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t};return e.keys.length>5&&(r.custodianPubkey=e.keys[5].pubkey),r}static decodeDeactivate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),br(As.Deactivate,e.data),{stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static checkProgramId(e){if(!e.equals(Cs.programId))throw new Error("invalid instruction; programId is not StakeProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const As=Object.freeze({Initialize:{index:0,layout:d.n_([d.Jq("instruction"),function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"authorized";return d.n_([Zt("staker"),Zt("withdrawer")],e)}(),function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"lockup";return d.n_([d.gM("unixTimestamp"),d.gM("epoch"),Zt("custodian")],e)}()])},Authorize:{index:1,layout:d.n_([d.Jq("instruction"),Zt("newAuthorized"),d.Jq("stakeAuthorizationType")])},Delegate:{index:2,layout:d.n_([d.Jq("instruction")])},Split:{index:3,layout:d.n_([d.Jq("instruction"),d.gM("lamports")])},Withdraw:{index:4,layout:d.n_([d.Jq("instruction"),d.gM("lamports")])},Deactivate:{index:5,layout:d.n_([d.Jq("instruction")])},Merge:{index:7,layout:d.n_([d.Jq("instruction")])},AuthorizeWithSeed:{index:8,layout:d.n_([d.Jq("instruction"),Zt("newAuthorized"),d.Jq("stakeAuthorizationType"),Yt("authoritySeed"),Zt("authorityOwner")])}}),Rs=Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class Cs{constructor(){}static initialize(e){const{stakePubkey:t,authorized:r,lockup:n}=e,s=n||Ss.default,i=wr(As.Initialize,{authorized:{staker:_(r.staker.toBuffer()),withdrawer:_(r.withdrawer.toBuffer())},lockup:{unixTimestamp:s.unixTimestamp,epoch:s.epoch,custodian:_(s.custodian.toBuffer())}}),o={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:dr,isSigner:!1,isWritable:!1}],programId:this.programId,data:i};return new ir(o)}static createAccountWithSeed(e){const t=new or;t.add(Rr.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:n,lockup:s}=e;return t.add(this.initialize({stakePubkey:r,authorized:n,lockup:s}))}static createAccount(e){const t=new or;t.add(Rr.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:n,lockup:s}=e;return t.add(this.initialize({stakePubkey:r,authorized:n,lockup:s}))}static delegate(e){const{stakePubkey:t,authorizedPubkey:r,votePubkey:n}=e,s=wr(As.Delegate);return(new or).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:ar,isSigner:!1,isWritable:!1},{pubkey:gr,isSigner:!1,isWritable:!1},{pubkey:Es,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:s})}static authorize(e){const{stakePubkey:t,authorizedPubkey:r,newAuthorizedPubkey:n,stakeAuthorizationType:s,custodianPubkey:i}=e,o=wr(As.Authorize,{newAuthorized:_(n.toBuffer()),stakeAuthorizationType:s.index}),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:ar,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return i&&a.push({pubkey:i,isSigner:!1,isWritable:!1}),(new or).add({keys:a,programId:this.programId,data:o})}static authorizeWithSeed(e){const{stakePubkey:t,authorityBase:r,authoritySeed:n,authorityOwner:s,newAuthorizedPubkey:i,stakeAuthorizationType:o,custodianPubkey:a}=e,c=wr(As.AuthorizeWithSeed,{newAuthorized:_(i.toBuffer()),stakeAuthorizationType:o.index,authoritySeed:n,authorityOwner:_(s.toBuffer())}),l=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:ar,isSigner:!1,isWritable:!1}];return a&&l.push({pubkey:a,isSigner:!1,isWritable:!1}),(new or).add({keys:l,programId:this.programId,data:c})}static splitInstruction(e){const{stakePubkey:t,authorizedPubkey:r,splitStakePubkey:n,lamports:s}=e,i=wr(As.Split,{lamports:s});return new ir({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static split(e){const t=new or;return t.add(Rr.createAccount({fromPubkey:e.authorizedPubkey,newAccountPubkey:e.splitStakePubkey,lamports:0,space:this.space,programId:this.programId})),t.add(this.splitInstruction(e))}static splitWithSeed(e){const{stakePubkey:t,authorizedPubkey:r,splitStakePubkey:n,basePubkey:s,seed:i,lamports:o}=e,a=new or;return a.add(Rr.allocate({accountPubkey:n,basePubkey:s,seed:i,space:this.space,programId:this.programId})),a.add(this.splitInstruction({stakePubkey:t,authorizedPubkey:r,splitStakePubkey:n,lamports:o}))}static merge(e){const{stakePubkey:t,sourceStakePubKey:r,authorizedPubkey:n}=e,s=wr(As.Merge);return(new or).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:ar,isSigner:!1,isWritable:!1},{pubkey:gr,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:s})}static withdraw(e){const{stakePubkey:t,authorizedPubkey:r,toPubkey:n,lamports:s,custodianPubkey:i}=e,o=wr(As.Withdraw,{lamports:s}),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:ar,isSigner:!1,isWritable:!1},{pubkey:gr,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return i&&a.push({pubkey:i,isSigner:!1,isWritable:!1}),(new or).add({keys:a,programId:this.programId,data:o})}static deactivate(e){const{stakePubkey:t,authorizedPubkey:r}=e,n=wr(As.Deactivate);return(new or).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:ar,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}}Cs.programId=new Wt("Stake11111111111111111111111111111111111111"),Cs.space=200;const{publicKeyCreate:Ts,ecdsaSign:Ds}=w(),Bs=d.n_([d.u8("numSignatures"),d.KB("signatureOffset"),d.u8("signatureInstructionIndex"),d.KB("ethAddressOffset"),d.u8("ethAddressInstructionIndex"),d.KB("messageDataOffset"),d.KB("messageDataSize"),d.u8("messageInstructionIndex"),d.Ik(20,"ethAddress"),d.Ik(64,"signature"),d.u8("recoveryId")]);class xs{constructor(){}static publicKeyToEthAddress(e){rr(64===e.length,`Public key must be 64 bytes but received ${e.length} bytes`);try{return i.Buffer.from(v().keccak_256.update(_(e)).digest()).slice(-20)}catch(t){throw new Error(`Error constructing Ethereum address: ${t}`)}}static createInstructionWithPublicKey(e){const{publicKey:t,message:r,signature:n,recoveryId:s,instructionIndex:i}=e;return xs.createInstructionWithEthAddress({ethAddress:xs.publicKeyToEthAddress(t),message:r,signature:n,recoveryId:s,instructionIndex:i})}static createInstructionWithEthAddress(e){const{ethAddress:t,message:r,signature:n,recoveryId:s,instructionIndex:o=0}=e;let a;a="string"===typeof t?t.startsWith("0x")?i.Buffer.from(t.substr(2),"hex"):i.Buffer.from(t,"hex"):t,rr(20===a.length,`Address must be 20 bytes but received ${a.length} bytes`);const c=12+a.length,l=c+n.length+1,u=i.Buffer.alloc(Bs.span+r.length);return Bs.encode({numSignatures:1,signatureOffset:c,signatureInstructionIndex:o,ethAddressOffset:12,ethAddressInstructionIndex:o,messageDataOffset:l,messageDataSize:r.length,messageInstructionIndex:o,signature:_(n),ethAddress:_(a),recoveryId:s},u),u.fill(_(r),Bs.span),new ir({keys:[],programId:xs.programId,data:u})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:r,instructionIndex:n}=e;rr(32===t.length,`Private key must be 32 bytes but received ${t.length} bytes`);try{const e=_(t),s=Ts(e,!1).slice(1),o=i.Buffer.from(v().keccak_256.update(_(r)).digest()),{signature:a,recid:c}=Ds(o,e);return this.createInstructionWithPublicKey({publicKey:s,message:r,signature:a,recoveryId:c,instructionIndex:n})}catch(s){throw new Error(`Error creating instruction; ${s}`)}}}xs.programId=new Wt("KeccakSecp256k11111111111111111111111111111");const Ns=new Wt("Va1idator1nfo111111111111111111111111111111"),Os=(0,p.dt)({name:(0,p.Z_)(),website:(0,p.jt)((0,p.Z_)()),details:(0,p.jt)((0,p.Z_)()),keybaseUsername:(0,p.jt)((0,p.Z_)())});class Ls{constructor(e,t){this.key=void 0,this.info=void 0,this.key=e,this.info=t}static fromConfigData(e){let t=[...e];if(2!==Qt(t))return null;const r=[];for(let n=0;n<2;n++){const e=new Wt(t.slice(0,32));t=t.slice(32);const n=1===t.slice(0,1)[0];t=t.slice(1),r.push({publicKey:e,isSigner:n})}if(r[0].publicKey.equals(Ns)&&r[1].isSigner){const e=Yt().decode(i.Buffer.from(t)),n=JSON.parse(e);return(0,p.hu)(n,Os),new Ls(r[1].publicKey,n)}return null}}const Ms=new Wt("Vote111111111111111111111111111111111111111"),js=d.n_([Zt("nodePubkey"),Zt("authorizedWithdrawer"),d.u8("commission"),d._O(),d.A9(d.n_([d._O("slot"),d.Jq("confirmationCount")]),d.cv(d.Jq(),-8),"votes"),d.u8("rootSlotValid"),d._O("rootSlot"),d._O(),d.A9(d.n_([d._O("epoch"),Zt("authorizedVoter")]),d.cv(d.Jq(),-8),"authorizedVoters"),d.n_([d.A9(d.n_([Zt("authorizedPubkey"),d._O("epochOfLastAuthorizedSwitch"),d._O("targetEpoch")]),32,"buf"),d._O("idx"),d.u8("isEmpty")],"priorVoters"),d._O(),d.A9(d.n_([d._O("epoch"),d._O("credits"),d._O("prevCredits")]),d.cv(d.Jq(),-8),"epochCredits"),d.n_([d._O("slot"),d._O("timestamp")],"lastTimestamp")]);class Us{constructor(e){this.nodePubkey=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.rootSlot=void 0,this.votes=void 0,this.authorizedVoters=void 0,this.priorVoters=void 0,this.epochCredits=void 0,this.lastTimestamp=void 0,this.nodePubkey=e.nodePubkey,this.authorizedWithdrawer=e.authorizedWithdrawer,this.commission=e.commission,this.rootSlot=e.rootSlot,this.votes=e.votes,this.authorizedVoters=e.authorizedVoters,this.priorVoters=e.priorVoters,this.epochCredits=e.epochCredits,this.lastTimestamp=e.lastTimestamp}static fromAccountData(e){const t=js.decode(_(e),4);let r=t.rootSlot;return t.rootSlotValid||(r=null),new Us({nodePubkey:new Wt(t.nodePubkey),authorizedWithdrawer:new Wt(t.authorizedWithdrawer),commission:t.commission,votes:t.votes,rootSlot:r,authorizedVoters:t.authorizedVoters.map(zs),priorVoters:$s(t.priorVoters),epochCredits:t.epochCredits,lastTimestamp:t.lastTimestamp})}}function zs(e){let{authorizedVoter:t,epoch:r}=e;return{epoch:r,authorizedVoter:new Wt(t)}}function Ws(e){let{authorizedPubkey:t,epochOfLastAuthorizedSwitch:r,targetEpoch:n}=e;return{authorizedPubkey:new Wt(t),epochOfLastAuthorizedSwitch:r,targetEpoch:n}}function $s(e){let{buf:t,idx:r,isEmpty:n}=e;return n?[]:[...t.slice(r+1).map(Ws),...t.slice(0,r).map(Ws)]}class Fs{constructor(e,t,r,n){this.nodePubkey=void 0,this.authorizedVoter=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.nodePubkey=e,this.authorizedVoter=t,this.authorizedWithdrawer=r,this.commission=n}}class Ks{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=d.Jq("instruction").decode(e.data);let r;for(const[n,s]of Object.entries(qs))if(s.index==t){r=n;break}if(!r)throw new Error("Instruction type incorrect; not a VoteInstruction");return r}static decodeInitializeAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,4);const{voteInit:t}=br(qs.InitializeAccount,e.data);return{votePubkey:e.keys[0].pubkey,nodePubkey:e.keys[3].pubkey,voteInit:new Fs(new Wt(t.nodePubkey),new Wt(t.authorizedVoter),new Wt(t.authorizedWithdrawer),t.commission)}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:t,voteAuthorizationType:r}=br(qs.Authorize,e.data);return{votePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new Wt(t),voteAuthorizationType:{index:r}}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t}=br(qs.Withdraw,e.data);return{votePubkey:e.keys[0].pubkey,authorizedWithdrawerPubkey:e.keys[2].pubkey,lamports:t,toPubkey:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(Gs.programId))throw new Error("invalid instruction; programId is not VoteProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const qs=Object.freeze({InitializeAccount:{index:0,layout:d.n_([d.Jq("instruction"),function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"voteInit";return d.n_([Zt("nodePubkey"),Zt("authorizedVoter"),Zt("authorizedWithdrawer"),d.u8("commission")],e)}()])},Authorize:{index:1,layout:d.n_([d.Jq("instruction"),Zt("newAuthorized"),d.Jq("voteAuthorizationType")])},Withdraw:{index:3,layout:d.n_([d.Jq("instruction"),d.gM("lamports")])}}),Hs=Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class Gs{constructor(){}static initializeAccount(e){const{votePubkey:t,nodePubkey:r,voteInit:n}=e,s=wr(qs.InitializeAccount,{voteInit:{nodePubkey:_(n.nodePubkey.toBuffer()),authorizedVoter:_(n.authorizedVoter.toBuffer()),authorizedWithdrawer:_(n.authorizedWithdrawer.toBuffer()),commission:n.commission}}),i={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:dr,isSigner:!1,isWritable:!1},{pubkey:ar,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:s};return new ir(i)}static createAccount(e){const t=new or;return t.add(Rr.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.votePubkey,lamports:e.lamports,space:this.space,programId:this.programId})),t.add(this.initializeAccount({votePubkey:e.votePubkey,nodePubkey:e.voteInit.nodePubkey,voteInit:e.voteInit}))}static authorize(e){const{votePubkey:t,authorizedPubkey:r,newAuthorizedPubkey:n,voteAuthorizationType:s}=e,i=wr(qs.Authorize,{newAuthorized:_(n.toBuffer()),voteAuthorizationType:s.index}),o=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:ar,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return(new or).add({keys:o,programId:this.programId,data:i})}static withdraw(e){const{votePubkey:t,authorizedWithdrawerPubkey:r,lamports:n,toPubkey:s}=e,i=wr(qs.Withdraw,{lamports:n}),o=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return(new or).add({keys:o,programId:this.programId,data:i})}}async function Vs(e,t,r,n){let s,i;r&&Object.prototype.hasOwnProperty.call(r,"lastValidBlockHeight")?(s=r,i=n):i=r;const o=i&&{skipPreflight:i.skipPreflight,preflightCommitment:i.preflightCommitment||i.commitment},a=await e.sendRawTransaction(t,o),c=i&&i.commitment,l=s?e.confirmTransaction(s,c):e.confirmTransaction(a,c),u=(await l).value;if(u.err)throw new Error(`Raw transaction ${a} failed (${JSON.stringify(u)})`);return a}Gs.programId=new Wt("Vote111111111111111111111111111111111111111"),Gs.space=3731;const Xs={http:{devnet:"http://api.devnet.solana.com",testnet:"http://api.testnet.solana.com","mainnet-beta":"http://api.mainnet-beta.solana.com/"},https:{devnet:"https://api.devnet.solana.com",testnet:"https://api.testnet.solana.com","mainnet-beta":"https://api.mainnet-beta.solana.com/"}};function Js(e,t){const r=!1===t?"http":"https";if(!e)return Xs[r].devnet;const n=Xs[r][e];if(!n)throw new Error(`Unknown ${r} cluster: ${e}`);return n}const Zs=1e9},40316:(e,t)=>{"use strict";const r=Math.exp;e.exports=function(e){if("number"!==typeof e)throw new Error("must provide a timespan to the moving average constructor");if(e<=0)throw new Error("must provide a timespan > 0 to the moving average constructor");let t,n,s=0,i=0,o=0,a={};return a.push=function(a,c){if(n){const l=1-r(-(a-n)/e),u=c-t;t=l*c+(1-l)*t,s=(1-l)*(s+u*(l*u)),i=Math.sqrt(s),o=t+l*u}else t=c;n=a},a.movingAverage=function(){return t},a.variance=function(){return s},a.deviation=function(){return i},a.forecast=function(){return o},a}},98691:e=>{function t(e){const t=new globalThis.AbortController;function r(){t.abort();for(const t of e)t&&t.removeEventListener&&t.removeEventListener("abort",r)}for(const n of e)if(n&&n.addEventListener){if(n.aborted){r();break}n.addEventListener("abort",r)}return t.signal}e.exports=t,e.exports.anySignal=t},76297:e=>{"use strict";e.exports=e=>{if(!Array.isArray(e))throw new TypeError("Expected an array, got "+typeof e);for(let t=(e=[...e]).length-1;t>0;t--){const r=Math.floor(Math.random()*(t+1));[e[t],e[r]]=[e[r],e[t]]}return e}},12009:(e,t)=>{"use strict";t.byteLength=function(e){var t=c(e),r=t[0],n=t[1];return 3*(r+n)/4-n},t.toByteArray=function(e){var t,r,i=c(e),o=i[0],a=i[1],l=new s(function(e,t,r){return 3*(t+r)/4-r}(0,o,a)),u=0,d=a>0?o-4:o;for(r=0;r<d;r+=4)t=n[e.charCodeAt(r)]<<18|n[e.charCodeAt(r+1)]<<12|n[e.charCodeAt(r+2)]<<6|n[e.charCodeAt(r+3)],l[u++]=t>>16&255,l[u++]=t>>8&255,l[u++]=255&t;2===a&&(t=n[e.charCodeAt(r)]<<2|n[e.charCodeAt(r+1)]>>4,l[u++]=255&t);1===a&&(t=n[e.charCodeAt(r)]<<10|n[e.charCodeAt(r+1)]<<4|n[e.charCodeAt(r+2)]>>2,l[u++]=t>>8&255,l[u++]=255&t);return l},t.fromByteArray=function(e){for(var t,n=e.length,s=n%3,i=[],o=16383,a=0,c=n-s;a<c;a+=o)i.push(l(e,a,a+o>c?c:a+o));1===s?(t=e[n-1],i.push(r[t>>2]+r[t<<4&63]+"==")):2===s&&(t=(e[n-2]<<8)+e[n-1],i.push(r[t>>10]+r[t>>4&63]+r[t<<2&63]+"="));return i.join("")};for(var r=[],n=[],s="undefined"!==typeof Uint8Array?Uint8Array:Array,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",o=0,a=i.length;o<a;++o)r[o]=i[o],n[i.charCodeAt(o)]=o;function c(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=e.indexOf("=");return-1===r&&(r=t),[r,r===t?0:4-r%4]}function l(e,t,n){for(var s,i,o=[],a=t;a<n;a+=3)s=(e[a]<<16&16711680)+(e[a+1]<<8&65280)+(255&e[a+2]),o.push(r[(i=s)>>18&63]+r[i>>12&63]+r[i>>6&63]+r[63&i]);return o.join("")}n["-".charCodeAt(0)]=62,n["_".charCodeAt(0)]=63},31156:(e,t,r)=>{"use strict";const n=r(55194);e.exports=function(e){return"function"===typeof e.stream?n(e.stream()):n(new Response(e).body)}},55194:e=>{"use strict";e.exports=async function*(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const r=e.getReader();try{for(;;){const e=await r.read();if(e.done)return;yield e.value}}finally{!0!==t.preventCancel&&r.cancel(),r.releaseLock()}}},77073:e=>{"use strict";e.exports=function(e,t){if("string"===typeof e)return o(e);if("number"===typeof e)return i(e,t);return null},e.exports.format=i,e.exports.parse=o;var t=/\B(?=(\d{3})+(?!\d))/g,r=/(?:\.0*|(\.[^0]+)0+)$/,n={b:1,kb:1024,mb:1<<20,gb:1<<30,tb:Math.pow(1024,4),pb:Math.pow(1024,5)},s=/^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;function i(e,s){if(!Number.isFinite(e))return null;var i=Math.abs(e),o=s&&s.thousandsSeparator||"",a=s&&s.unitSeparator||"",c=s&&void 0!==s.decimalPlaces?s.decimalPlaces:2,l=Boolean(s&&s.fixedDecimals),u=s&&s.unit||"";u&&n[u.toLowerCase()]||(u=i>=n.pb?"PB":i>=n.tb?"TB":i>=n.gb?"GB":i>=n.mb?"MB":i>=n.kb?"KB":"B");var d=(e/n[u.toLowerCase()]).toFixed(c);return l||(d=d.replace(r,"$1")),o&&(d=d.split(".").map((function(e,r){return 0===r?e.replace(t,o):e})).join(".")),d+a+u}function o(e){if("number"===typeof e&&!isNaN(e))return e;if("string"!==typeof e)return null;var t,r=s.exec(e),i="b";return r?(t=parseFloat(r[1]),i=r[4].toLowerCase()):(t=parseInt(e,10),i="b"),isNaN(t)?null:Math.floor(n[i]*t)}},58735:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),s=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&n(t,e,r);return s(t,e),t},o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.decode=t.encode=t.toGeneral=t.code=t.name=void 0;const a=o(r(53692)),c=o(r(515)),l=i(r(86888));function u(e){return"payload"in e&&"string"===typeof e.payload&&"signatures"in e&&Array.isArray(e.signatures)}function d(e){return"ciphertext"in e&&"string"===typeof e.ciphertext&&"iv"in e&&"string"===typeof e.iv&&"protected"in e&&"string"===typeof e.protected&&"tag"in e&&"string"===typeof e.tag}function h(e){if("string"===typeof e){const t=e.split(".");if(3===t.length)return a.default.fromSplit(t);if(5===t.length)return c.default.fromSplit(t);throw new Error("Not a valid JOSE string")}if(u(e)||d(e))return e;throw new Error("Not a valid unencoded JOSE object")}t.name="dag-jose",t.code=133,t.toGeneral=h,t.encode=function(e){let t;if("string"===typeof e&&(e=h(e)),u(e))t=a.default.encode(e);else{if(!d(e))throw new Error("Not a valid JOSE object");t=c.default.encode(e)}return new Uint8Array(l.encode(t))},t.decode=function(e){let t;try{t=l.decode(e)}catch(n){throw new Error("Not a valid DAG-JOSE object")}if("payload"in(r=t)&&r.payload instanceof Uint8Array&&"signatures"in r&&Array.isArray(r.signatures))return a.default.decode(t);if(function(e){return"ciphertext"in e&&e.ciphertext instanceof Uint8Array&&"iv"in e&&e.iv instanceof Uint8Array&&"protected"in e&&e.protected instanceof Uint8Array&&"tag"in e&&e.tag instanceof Uint8Array}(t))return c.default.decode(t);throw new Error("Not a valid DAG-JOSE object");var r}},60720:(e,t,r)=>{t.formatArgs=function(t){if(t[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+t[0]+(this.useColors?"%c ":" ")+"+"+e.exports.humanize(this.diff),!this.useColors)return;const r="color: "+this.color;t.splice(1,0,r,"color: inherit");let n=0,s=0;t[0].replace(/%[a-zA-Z%]/g,(e=>{"%%"!==e&&(n++,"%c"===e&&(s=n))})),t.splice(s,0,r)},t.save=function(e){try{e?t.storage.setItem("debug",e):t.storage.removeItem("debug")}catch(r){}},t.load=function(){let e;try{e=t.storage.getItem("debug")}catch(r){}!e&&"undefined"!==typeof process&&"env"in process&&(e={NODE_ENV:"production",PUBLIC_URL:"",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0,REACT_APP_ENV:"production",REACT_APP_ID:"interdao",REACT_APP_NAME:"InterDAO",REACT_APP_AUTHOR_NAME:"Descartes Network",REACT_APP_AUTHOR_EMAIL:"hello@descartes.network",REACT_APP_TAGS:"dapps,dao",REACT_APP_DESCRIPTION:"\ud83c\udf0f InterDAO is a universal DAO solution that projects on Solana can seamlessly construct their owned DAO.",REACT_APP_URL:"https://descartesnetwork.github.io/interdao.so/index.js"}.DEBUG);return e},t.useColors=function(){if("undefined"!==typeof window&&window.process&&("renderer"===window.process.type||window.process.__nwjs))return!0;if("undefined"!==typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))return!1;return"undefined"!==typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!==typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!==typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!==typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)},t.storage=function(){try{return localStorage}catch(e){}}(),t.destroy=(()=>{let e=!1;return()=>{e||(e=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),t.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],t.log=console.debug||console.log||(()=>{}),e.exports=r(87565)(t);const{formatters:n}=e.exports;n.j=function(e){try{return JSON.stringify(e)}catch(t){return"[UnexpectedJSONParseError]: "+t.message}}},21613:function(e){e.exports=function(e,t,r,n,s){for(t=t.split?t.split("."):t,n=0;n<t.length;n++)e=e?e[t[n]]:s;return e===s?r:e}},15504:e=>{"use strict";function t(e,t){for(const r in t)Object.defineProperty(e,r,{value:t[r],enumerable:!0,configurable:!0});return e}e.exports=function(e,r,n){if(!e||"string"===typeof e)throw new TypeError("Please pass an Error to err-code");n||(n={}),"object"===typeof r&&(n=r,r=""),r&&(n.code=r);try{return t(e,n)}catch(s){n.message=e.message,n.stack=e.stack;const r=function(){};r.prototype=Object.create(Object.getPrototypeOf(e));return t(new r,n)}}},48449:e=>{"use strict";var t=Object.prototype.hasOwnProperty,r="~";function n(){}function s(e,t,r){this.fn=e,this.context=t,this.once=r||!1}function i(e,t,n,i,o){if("function"!==typeof n)throw new TypeError("The listener must be a function");var a=new s(n,i||e,o),c=r?r+t:t;return e._events[c]?e._events[c].fn?e._events[c]=[e._events[c],a]:e._events[c].push(a):(e._events[c]=a,e._eventsCount++),e}function o(e,t){0===--e._eventsCount?e._events=new n:delete e._events[t]}function a(){this._events=new n,this._eventsCount=0}Object.create&&(n.prototype=Object.create(null),(new n).__proto__||(r=!1)),a.prototype.eventNames=function(){var e,n,s=[];if(0===this._eventsCount)return s;for(n in e=this._events)t.call(e,n)&&s.push(r?n.slice(1):n);return Object.getOwnPropertySymbols?s.concat(Object.getOwnPropertySymbols(e)):s},a.prototype.listeners=function(e){var t=r?r+e:e,n=this._events[t];if(!n)return[];if(n.fn)return[n.fn];for(var s=0,i=n.length,o=new Array(i);s<i;s++)o[s]=n[s].fn;return o},a.prototype.listenerCount=function(e){var t=r?r+e:e,n=this._events[t];return n?n.fn?1:n.length:0},a.prototype.emit=function(e,t,n,s,i,o){var a=r?r+e:e;if(!this._events[a])return!1;var c,l,u=this._events[a],d=arguments.length;if(u.fn){switch(u.once&&this.removeListener(e,u.fn,void 0,!0),d){case 1:return u.fn.call(u.context),!0;case 2:return u.fn.call(u.context,t),!0;case 3:return u.fn.call(u.context,t,n),!0;case 4:return u.fn.call(u.context,t,n,s),!0;case 5:return u.fn.call(u.context,t,n,s,i),!0;case 6:return u.fn.call(u.context,t,n,s,i,o),!0}for(l=1,c=new Array(d-1);l<d;l++)c[l-1]=arguments[l];u.fn.apply(u.context,c)}else{var h,p=u.length;for(l=0;l<p;l++)switch(u[l].once&&this.removeListener(e,u[l].fn,void 0,!0),d){case 1:u[l].fn.call(u[l].context);break;case 2:u[l].fn.call(u[l].context,t);break;case 3:u[l].fn.call(u[l].context,t,n);break;case 4:u[l].fn.call(u[l].context,t,n,s);break;default:if(!c)for(h=1,c=new Array(d-1);h<d;h++)c[h-1]=arguments[h];u[l].fn.apply(u[l].context,c)}}return!0},a.prototype.on=function(e,t,r){return i(this,e,t,r,!1)},a.prototype.once=function(e,t,r){return i(this,e,t,r,!0)},a.prototype.removeListener=function(e,t,n,s){var i=r?r+e:e;if(!this._events[i])return this;if(!t)return o(this,i),this;var a=this._events[i];if(a.fn)a.fn!==t||s&&!a.once||n&&a.context!==n||o(this,i);else{for(var c=0,l=[],u=a.length;c<u;c++)(a[c].fn!==t||s&&!a[c].once||n&&a[c].context!==n)&&l.push(a[c]);l.length?this._events[i]=1===l.length?l[0]:l:o(this,i)}return this},a.prototype.removeAllListeners=function(e){var t;return e?(t=r?r+e:e,this._events[t]&&o(this,t)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=r,a.EventEmitter=a,e.exports=a},36571:e=>{"use strict";var t,r="object"===typeof Reflect?Reflect:null,n=r&&"function"===typeof r.apply?r.apply:function(e,t,r){return Function.prototype.apply.call(e,t,r)};t=r&&"function"===typeof r.ownKeys?r.ownKeys:Object.getOwnPropertySymbols?function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:function(e){return Object.getOwnPropertyNames(e)};var s=Number.isNaN||function(e){return e!==e};function i(){i.init.call(this)}e.exports=i,e.exports.once=function(e,t){return new Promise((function(r,n){function s(r){e.removeListener(t,i),n(r)}function i(){"function"===typeof e.removeListener&&e.removeListener("error",s),r([].slice.call(arguments))}g(e,t,i,{once:!0}),"error"!==t&&function(e,t,r){"function"===typeof e.on&&g(e,"error",t,r)}(e,s,{once:!0})}))},i.EventEmitter=i,i.prototype._events=void 0,i.prototype._eventsCount=0,i.prototype._maxListeners=void 0;var o=10;function a(e){if("function"!==typeof e)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof e)}function c(e){return void 0===e._maxListeners?i.defaultMaxListeners:e._maxListeners}function l(e,t,r,n){var s,i,o,l;if(a(r),void 0===(i=e._events)?(i=e._events=Object.create(null),e._eventsCount=0):(void 0!==i.newListener&&(e.emit("newListener",t,r.listener?r.listener:r),i=e._events),o=i[t]),void 0===o)o=i[t]=r,++e._eventsCount;else if("function"===typeof o?o=i[t]=n?[r,o]:[o,r]:n?o.unshift(r):o.push(r),(s=c(e))>0&&o.length>s&&!o.warned){o.warned=!0;var u=new Error("Possible EventEmitter memory leak detected. "+o.length+" "+String(t)+" listeners added. Use emitter.setMaxListeners() to increase limit");u.name="MaxListenersExceededWarning",u.emitter=e,u.type=t,u.count=o.length,l=u,console&&console.warn&&console.warn(l)}return e}function u(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function d(e,t,r){var n={fired:!1,wrapFn:void 0,target:e,type:t,listener:r},s=u.bind(n);return s.listener=r,n.wrapFn=s,s}function h(e,t,r){var n=e._events;if(void 0===n)return[];var s=n[t];return void 0===s?[]:"function"===typeof s?r?[s.listener||s]:[s]:r?function(e){for(var t=new Array(e.length),r=0;r<t.length;++r)t[r]=e[r].listener||e[r];return t}(s):f(s,s.length)}function p(e){var t=this._events;if(void 0!==t){var r=t[e];if("function"===typeof r)return 1;if(void 0!==r)return r.length}return 0}function f(e,t){for(var r=new Array(t),n=0;n<t;++n)r[n]=e[n];return r}function g(e,t,r,n){if("function"===typeof e.on)n.once?e.once(t,r):e.on(t,r);else{if("function"!==typeof e.addEventListener)throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof e);e.addEventListener(t,(function s(i){n.once&&e.removeEventListener(t,s),r(i)}))}}Object.defineProperty(i,"defaultMaxListeners",{enumerable:!0,get:function(){return o},set:function(e){if("number"!==typeof e||e<0||s(e))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+e+".");o=e}}),i.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},i.prototype.setMaxListeners=function(e){if("number"!==typeof e||e<0||s(e))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+e+".");return this._maxListeners=e,this},i.prototype.getMaxListeners=function(){return c(this)},i.prototype.emit=function(e){for(var t=[],r=1;r<arguments.length;r++)t.push(arguments[r]);var s="error"===e,i=this._events;if(void 0!==i)s=s&&void 0===i.error;else if(!s)return!1;if(s){var o;if(t.length>0&&(o=t[0]),o instanceof Error)throw o;var a=new Error("Unhandled error."+(o?" ("+o.message+")":""));throw a.context=o,a}var c=i[e];if(void 0===c)return!1;if("function"===typeof c)n(c,this,t);else{var l=c.length,u=f(c,l);for(r=0;r<l;++r)n(u[r],this,t)}return!0},i.prototype.addListener=function(e,t){return l(this,e,t,!1)},i.prototype.on=i.prototype.addListener,i.prototype.prependListener=function(e,t){return l(this,e,t,!0)},i.prototype.once=function(e,t){return a(t),this.on(e,d(this,e,t)),this},i.prototype.prependOnceListener=function(e,t){return a(t),this.prependListener(e,d(this,e,t)),this},i.prototype.removeListener=function(e,t){var r,n,s,i,o;if(a(t),void 0===(n=this._events))return this;if(void 0===(r=n[e]))return this;if(r===t||r.listener===t)0===--this._eventsCount?this._events=Object.create(null):(delete n[e],n.removeListener&&this.emit("removeListener",e,r.listener||t));else if("function"!==typeof r){for(s=-1,i=r.length-1;i>=0;i--)if(r[i]===t||r[i].listener===t){o=r[i].listener,s=i;break}if(s<0)return this;0===s?r.shift():function(e,t){for(;t+1<e.length;t++)e[t]=e[t+1];e.pop()}(r,s),1===r.length&&(n[e]=r[0]),void 0!==n.removeListener&&this.emit("removeListener",e,o||t)}return this},i.prototype.off=i.prototype.removeListener,i.prototype.removeAllListeners=function(e){var t,r,n;if(void 0===(r=this._events))return this;if(void 0===r.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==r[e]&&(0===--this._eventsCount?this._events=Object.create(null):delete r[e]),this;if(0===arguments.length){var s,i=Object.keys(r);for(n=0;n<i.length;++n)"removeListener"!==(s=i[n])&&this.removeAllListeners(s);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"===typeof(t=r[e]))this.removeListener(e,t);else if(void 0!==t)for(n=t.length-1;n>=0;n--)this.removeListener(e,t[n]);return this},i.prototype.listeners=function(e){return h(this,e,!0)},i.prototype.rawListeners=function(e){return h(this,e,!1)},i.listenerCount=function(e,t){return"function"===typeof e.listenerCount?e.listenerCount(t):p.call(e,t)},i.prototype.listenerCount=p,i.prototype.eventNames=function(){return this._eventsCount>0?t(this._events):[]}},87167:e=>{e.exports=function(e){if(!e)throw Error("hashlru must have a max value, of type number, greater than 0");var t=0,r=Object.create(null),n=Object.create(null);function s(s,i){r[s]=i,++t>=e&&(t=0,n=r,r=Object.create(null))}return{has:function(e){return void 0!==r[e]||void 0!==n[e]},remove:function(e){void 0!==r[e]&&(r[e]=void 0),void 0!==n[e]&&(n[e]=void 0)},get:function(e){var t=r[e];return void 0!==t?t:void 0!==(t=n[e])?(s(e,t),t):void 0},set:function(e,t){void 0!==r[e]?r[e]=t:s(e,t)},clear:function(){r=Object.create(null),n=Object.create(null)}}}},4813:(e,t,r)=>{"use strict";var n={};(0,r(11824).assign)(n,r(60961),r(11829),r(52168)),e.exports=n},41257:(e,t,r)=>{"use strict";const n=r(46861),s="object"===typeof window&&"object"===typeof document&&9===document.nodeType,i=n(),o=s&&!i,a=i&&!s,c=i&&s,l="undefined"!==typeof globalThis.process&&"undefined"!==typeof globalThis.process.release&&"node"===globalThis.process.release.name&&!i,u="function"===typeof importScripts&&"undefined"!==typeof self&&"undefined"!==typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope,d="undefined"!==typeof globalThis.process&&"undefined"!==typeof globalThis.process.env&&"test"===globalThis.process.env.NODE_ENV,h="undefined"!==typeof navigator&&"ReactNative"===navigator.product;e.exports={isTest:d,isElectron:i,isElectronMain:a,isElectronRenderer:c,isNode:l,isBrowser:o,isWebWorker:u,isEnvWithDom:s,isReactNative:h}},68170:(e,t,r)=>{"use strict";const{fetch:n,Request:s,Headers:i}=r(42453),{TimeoutError:o,HTTPError:a}=r(90140),c=r(47250).bind({ignoreUndefined:!0}),{URL:l,URLSearchParams:u}=r(41094),d=r(98691),h={throwHttpErrors:!0,credentials:"same-origin"};class p{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.opts=c(h,e)}async fetch(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const r=c(this.opts,t),h=new i(r.headers);if("string"!==typeof e&&!(e instanceof l||e instanceof s))throw new TypeError("`resource` must be a string, URL, or Request");const p=new l(e.toString(),r.base),{searchParams:y,transformSearchParams:m,json:w}=r;y&&(p.search="function"===typeof m?m(new u(r.searchParams)):new u(r.searchParams)),w&&(r.body=JSON.stringify(r.json),h.set("content-type","application/json"));const b=new AbortController,v=d([b.signal,r.signal]),_=await((e,t,r)=>{if(void 0===t)return e;const n=Date.now(),s=()=>Date.now()-n>=t;return new Promise(((n,i)=>{const a=setTimeout((()=>{s()&&(i(new o),r.abort())}),t),c=e=>t=>{clearTimeout(a),s()?i(new o):e(t)};e.then(c(n),c(i))}))})(n(p.toString(),{...r,signal:v,timeout:void 0,headers:h}),r.timeout,b);if(!_.ok&&r.throwHttpErrors)throw r.handleError&&await r.handleError(_),new a(_);return _.iterator=function(){return g(_.body)},_.ndjson=async function*(){for await(const e of f(_.iterator()))t.transform?yield t.transform(e):yield e},_}post(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.fetch(e,{...t,method:"POST"})}get(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.fetch(e,{...t,method:"GET"})}put(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.fetch(e,{...t,method:"PUT"})}delete(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.fetch(e,{...t,method:"DELETE"})}options(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.fetch(e,{...t,method:"OPTIONS"})}}const f=async function*(e){const t=new TextDecoder;let r="";for await(const n of e){r+=t.decode(n,{stream:!0});const e=r.split(/\r?\n/);for(let t=0;t<e.length-1;t++){const r=e[t].trim();r.length>0&&(yield JSON.parse(r))}r=e[e.length-1]}r+=t.decode(),r=r.trim(),0!==r.length&&(yield JSON.parse(r))},g=e=>{if(w(e)){const t=e[Symbol.asyncIterator]();return{[Symbol.asyncIterator]:()=>({next:t.next.bind(t),return:r=>(e.destroy(),"function"===typeof t.return?t.return():Promise.resolve({done:!0,value:r}))})}}if(m(e)){const t=e.getReader();return async function*(){try{for(;;){const{done:e,value:r}=await t.read();if(e)return;r&&(yield r)}}finally{t.releaseLock()}}()}if(y(e))return e;throw new TypeError("Body can't be converted to AsyncIterable")},y=e=>"object"===typeof e&&null!==e&&"function"===typeof e[Symbol.asyncIterator],m=e=>e&&"function"===typeof e.getReader,w=e=>Object.prototype.hasOwnProperty.call(e,"readable")&&Object.prototype.hasOwnProperty.call(e,"writable");p.HTTPError=a,p.TimeoutError=o,p.streamToAsyncIterator=g,p.post=(e,t)=>new p(t).post(e,t),p.get=(e,t)=>new p(t).get(e,t),p.put=(e,t)=>new p(t).put(e,t),p.delete=(e,t)=>new p(t).delete(e,t),p.options=(e,t)=>new p(t).options(e,t),e.exports=p},47937:e=>{"use strict";var t=/^(?:[a-z0-9](?:[a-z0-9\-]{0,61}[a-z0-9])?\.){0,126}(?:[a-z0-9](?:[a-z0-9\-]{0,61}[a-z0-9]))\.?$/i;e.exports=function(e,r){if(null==r&&(r=!1),e.length<2)return!1;if(e.length>255)return!1;var n=e[e.length-1];if(r){if("."!==n)return!1}else if("."===n)return!1;return t.test(e)}},21958:e=>{"use strict";e.exports=async e=>{const t=[];for await(const r of e)t.push(r);return t}},20838:e=>{"use strict";e.exports=async e=>{for await(const t of e);}},45454:e=>{"use strict";e.exports=async e=>{for await(const t of e)return t}},16586:e=>{"use strict";e.exports=async e=>{let t;for await(const r of e)t=r;return t}},7213:(e,t,r)=>{"use strict";t.encode=r(57158),t.decode=r(16811),t.varintEncode=r(16225),t.varintDecode=r(67369),t.int32BEEncode=r(9538),t.int32BEDecode=r(25012)},88411:(e,t,r)=>{"use strict";const n=r(19635);e.exports=async function*(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;for await(const r of n(e,t)){const e=r.map((e=>e().then((e=>({ok:!0,value:e})),(e=>({ok:!1,err:e})))));for(let t=0;t<e.length;t++){const r=await e[t];if(!r.ok)throw r.err;yield r.value}}}},1833:(e,t,r)=>{"use strict";const n=r(61135),s=r(36571).EventEmitter;e.exports=async function*(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=t.concurrency||1/0;r<1&&(r=1/0);const i=null!=t.ordered&&t.ordered,o=new s,a=[];let c,l=n(),u=n(),d=!1,h=!1;function p(){return i?Boolean(a[0]&&a[0].done):Boolean(a.find((e=>e.done)))}function*f(){for(;a.length&&a[0].done;){const e=a[0];if(a.shift(),!e.ok)throw h=!0,l.resolve(),e.err;yield e.value,l.resolve()}}function*g(){for(;p();)for(let e=0;e<a.length;e++)if(a[e].done){const t=a[e];if(a.splice(e,1),e--,!t.ok)throw h=!0,l.resolve(),t.err;yield t.value,l.resolve()}}for(o.on("task-complete",(()=>{u.resolve()})),Promise.resolve().then((async()=>{try{for await(const t of e){if(a.length===r&&(l=n(),await l.promise),h)break;const e={done:!1};a.push(e),t().then((t=>{e.done=!0,e.ok=!0,e.value=t,o.emit("task-complete")}),(t=>{e.done=!0,e.err=t,o.emit("task-complete")}))}d=!0,o.emit("task-complete")}catch(t){c=t,o.emit("task-complete")}}));;){if(p()||(u=n(),await u.promise),c)throw c;if(i?yield*f():yield*g(),d&&0===a.length)break}}},62469:e=>{"use strict";e.exports=function(e){const[t,r]=e[Symbol.asyncIterator]?[e[Symbol.asyncIterator](),Symbol.asyncIterator]:[e[Symbol.iterator](),Symbol.iterator],n=[];return{peek:()=>t.next(),push:e=>{n.push(e)},next:()=>n.length?{done:!1,value:n.shift()}:t.next(),[r](){return this}}}},31730:(e,t,r)=>{const n=r(39047);e.exports=e=>{let t;"function"===typeof(e=e||{})?(t=e,e={}):t=e.onEnd;let r,s,i,o=new n;const a=e=>s?s(e):(o.push(e),r),c=e=>i?r:a({done:!1,value:e}),l=e=>i?r:(i=!0,e?(e=>(o=new n,s?s({error:e}):(o.push({error:e}),r)))(e):a({done:!0}));if(r={[Symbol.asyncIterator](){return this},next:()=>{if(!o.isEmpty()){if(e.writev){let e;const t=[];for(;!o.isEmpty();){if(e=o.shift(),e.error)throw e.error;t.push(e.value)}return{done:e.done,value:t}}const t=o.shift();if(t.error)throw t.error;return t}return i?{done:!0}:new Promise(((t,n)=>{s=i=>(s=null,i.error?n(i.error):e.writev&&!i.done?t({done:i.done,value:[i.value]}):t(i),r)}))},return:()=>(o=new n,l(),{done:!0}),throw:e=>(l(e),{done:!0}),push:c,end:l},!t)return r;const u=r;return r={[Symbol.asyncIterator](){return this},next:()=>u.next(),throw:e=>(u.throw(e),t&&(t(e),t=null),{done:!0}),return:()=>(u.return(),t&&(t(),t=null),{done:!0}),push:c,end:e=>(u.end(e),t&&(t(e),t=null),r)},r}},91703:(e,t,r)=>{"use strict";const n=r(21958);e.exports=async function*(e,t){const r=await n(e);yield*r.sort(t)}},53659:(e,t,r)=>{r(89869),t.pack=r(56113)},56113:(e,t,r)=>{const{Buffer:n}=r(97429),s=r(74439),{S_IFMT:i,S_IFBLK:o,S_IFCHR:a,S_IFDIR:c,S_IFIFO:l,S_IFLNK:u}=r(24416),d=r(46905),h=r(95336),p=parseInt("755",8),f=parseInt("644",8),g=n.alloc(1024);function y(e){switch(e&i){case o:return"block-device";case a:return"character-device";case c:return"directory";case l:return"fifo";case u:return"symlink"}return"file"}function m(e){if(e&=511)return new s(g.slice(0,512-e))}function w(e){if(!e.pax){const t=h.encode(e);if(t)return t}return function(e){const t=h.encodePax({name:e.name,linkname:e.linkname,pax:e.pax}),r={name:"PaxHeader",mode:e.mode,uid:e.uid,gid:e.gid,size:t.length,mtime:e.mtime,type:"pax-header",linkname:e.linkname&&"PaxHeader",uname:e.uname,gname:e.gname,devmajor:e.devmajor,devminor:e.devminor};return new s([h.encode(r),t,m(t.length),h.encode({...r,size:e.size,type:e.type})])}(e)}e.exports=()=>async function*(e){for await(let{header:t,body:r}of e){if(t.size&&"symlink"!==t.type||(t.size=0),t.type||(t.type=y(t.mode)),t.mode||(t.mode="directory"===t.type?p:f),t.uid||(t.uid=0),t.gid||(t.gid=0),t.mtime||(t.mtime=new Date),"string"===typeof r&&(r=n.from(r)),n.isBuffer(r)||s.isBufferList(r)){t.size=r.length,yield new s([w(t),r,m(t.size)]);continue}if("symlink"===t.type&&!t.linkname){t.linkname=(await d(r)).toString(),yield w(t);continue}if(yield w(t),"file"!==t.type&&"contiguous-file"!==t.type)continue;let e=0;for await(const t of r)e+=t.length,yield s.isBufferList(t)?t:new s(t);if(e!==t.size)throw new Error("size mismatch");const i=m(t.size);i&&(yield i)}yield new s(g)}},42407:(e,t,r)=>{"use strict";const{concat:n}=r(52769);e.exports=async function(e){let t=new Uint8Array(0);for await(const r of e)t=n([t,r],t.length+r.length);return t}},88898:e=>{e.exports=function(e,t,r){var n=null,s=null,i=function(){n&&(clearTimeout(n),s=null,n=null)},o=function(){if(!t)return e.apply(this,arguments);var o=this,a=arguments,c=r&&!n;return i(),s=function(){e.apply(o,a)},n=setTimeout((function(){if(n=null,!c){var e=s;return s=null,e()}}),t),c?s():void 0};return o.cancel=i,o.flush=function(){var e=s;i(),e&&e()},o}},2548:e=>{e.exports=function(e,t,r){if(!e)return r;var n,s;Array.isArray(t)&&(n=t.slice(0));"string"==typeof t&&(n=t.split("."));"symbol"==typeof t&&(n=[t]);if(!Array.isArray(n))throw new Error("props arg must be an array, a string or a symbol");for(;n.length;){if(s=n.shift(),!e)return r;if(void 0===(e=e[s]))return r}return e}},69201:e=>{function t(e){if("__proto__"===e||"constructor"===e||"prototype"===e)throw new Error("setting of prototype values not supported")}e.exports=function(e,r,n){var s,i,o;Array.isArray(r)&&(s=r.slice(0));"string"==typeof r&&(s=r.split("."));"symbol"==typeof r&&(s=[r]);if(!Array.isArray(s))throw new Error("props arg must be an array, a string or a symbol");if(!(i=s.pop()))return!1;t(i);for(;o=s.shift();)if(t(o),"undefined"==typeof e[o]&&(e[o]={}),!(e=e[o])||"object"!=typeof e)return!1;return e[i]=n,!0}},77420:(e,t,r)=>{e.exports=r(67469)(r(39850))},95067:(e,t,r)=>{"use strict";const n=r(91401),{Multiaddr:s}=r(10006),i=r(44021),{EventEmitter:o}=r(36571),a=r(60720),c=Object.assign(a("libp2p:bootstrap"),{error:a("libp2p:bootstrap:error")});(e.exports=class extends o{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{list:[]};if(!e.list||!e.list.length)throw new Error("Bootstrap requires a list of peer addresses");super(),this._list=e.list,this._interval=e.interval||1e4,this._timer=null}start(){this._timer||(this._timer=setInterval((()=>this._discoverBootstrapPeers()),this._interval),c("Starting bootstrap node discovery"),this._discoverBootstrapPeers())}_discoverBootstrapPeers(){this._timer&&this._list.forEach((e=>{if(!i.P2P.matches(e))return c.error("Invalid multiaddr");const t=new s(e),r=t.getPeerId();if(!r)return void c.error("Invalid bootstrap multiaddr without peer id");const o=n.createFromB58String(r);try{this.emit("peer",{id:o,multiaddrs:[t]})}catch(a){c.error("Invalid bootstrap peer id",a)}}))}stop(){this._timer&&clearInterval(this._timer),this._timer=null}}).tag="bootstrap"},8711:(e,t,r)=>{"use strict";const n=r(60720),s=r(91401),i=r(20838),{default:o}=r(60185),a=r(61135),c=n("libp2p-delegated-content-routing");c.error=n("libp2p-delegated-content-routing:error");e.exports=class{constructor(e,t){if(null==e)throw new Error("missing self peerId");if(null==t)throw new Error("missing ipfs http client");this._client=t,this.peerId=e;const r={concurrency:4};this._httpQueue=new o(r),this._httpQueueRefs=new o(Object.assign({},r,{concurrency:2}));const{protocol:n,host:s,port:i}=t.getEndpointConfig();c(`enabled DelegatedContentRouting via ${n}://${s}:${i}`)}async*findProviders(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};c(`findProviders starts: ${e}`),t.timeout=t.timeout||3e4;let r=0;const n=a(),i=a();this._httpQueue.add((()=>(n.resolve(),i.promise)));try{await n.promise;for await(const{id:n,addrs:i}of this._client.dht.findProvs(e,{numProviders:t.numProviders,timeout:t.timeout}))yield{id:s.parse(n),multiaddrs:i},r++}catch(o){throw c.error("findProviders errored:",o),o}finally{i.resolve(),c(`findProviders finished: ${e} found ${r} providers`)}}async provide(e){c(`provide starts: ${e}`),await this._httpQueueRefs.add((async()=>{await this._client.block.stat(e),await i(this._client.dht.provide(e))})),c(`provide finished: ${e}`)}}},55585:(e,t,r)=>{"use strict";const n=r(91401),{base58btc:s}=r(43019),{default:i}=r(60185),o=r(61135),a=r(60720),c=a("libp2p-delegated-peer-routing");c.error=a("libp2p-delegated-peer-routing:error");e.exports=class{constructor(e){if(null==e)throw new Error("missing ipfs http client");this._client=e,this._httpQueue=new i({concurrency:4});const{protocol:t,host:r,port:n}=e.getEndpointConfig();c(`enabled DelegatedPeerRouting via ${t}://${r}:${n}`)}async findPeer(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=e;n.isPeerId(r)&&(r=e.toB58String()),c("findPeer starts: "+e),t.timeout=t.timeout||3e4;try{return await this._httpQueue.add((async()=>{const{addrs:n}=await this._client.dht.findPeer(r,{timeout:t.timeout});return{id:e,multiaddrs:n}}))}catch(s){if(s.message.includes("not found"))return;throw s}finally{c("findPeer finished: "+e)}}async*getClosestPeers(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const r=s.encode(e).substring(1);c("getClosestPeers starts:",r),t.timeout=t.timeout||3e4;const i=o(),a=o();this._httpQueue.add((()=>(i.resolve(),a.promise)));try{await i.promise;for await(const e of this._client.dht.query(r,{timeout:t.timeout}))if(1===e.type)for(const t of e.responses)yield{id:n.parse(t.id),multiaddrs:t.addrs};else c("getClosestPeers unhandled response",e)}catch(l){throw c.error("getClosestPeers errored:",l),l}finally{a.resolve(),c("getClosestPeers finished:",r)}}}},97153:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),s=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&n(t,e,r);return s(t,e),t},o=this&&this.__awaiter||function(e,t,r,n){return new(r||(r=Promise))((function(s,i){function o(e){try{c(n.next(e))}catch(t){i(t)}}function a(e){try{c(n.throw(e))}catch(t){i(t)}}function c(e){var t;e.done?s(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(o,a)}c((n=n.apply(e,t||[])).next())}))};const a=i(r(20008)),c=r(57904),l=r(19971),u=i(r(76371)),d=r(29519),h=r(22687),p=r(38071),f=r(97389),g=r(99375),y=r(53112),m=r(91401),w=r(50650),b=r(76371);class v extends a.default{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};var r;const n=[u.GossipsubIDv11,u.GossipsubIDv10],s=Object.assign(Object.assign({gossipIncoming:!0,fallbackToFloodsub:!0,floodPublish:!0,doPX:!1,directPeers:[],D:u.GossipsubD,Dlo:u.GossipsubDlo,Dhi:u.GossipsubDhi,Dscore:u.GossipsubDscore,Dout:u.GossipsubDout,Dlazy:u.GossipsubDlazy,heartbeatInterval:u.GossipsubHeartbeatInterval,fanoutTTL:u.GossipsubFanoutTTL,mcacheLength:u.GossipsubHistoryLength,mcacheGossip:u.GossipsubHistoryGossip,seenTTL:u.GossipsubSeenTTL},t),{scoreParams:f.createPeerScoreParams(t.scoreParams),scoreThresholds:f.createPeerScoreThresholds(t.scoreThresholds)});s.fallbackToFloodsub&&n.push(u.FloodsubID),super(Object.assign({debugName:"libp2p:gossipsub",multicodecs:n,libp2p:e},s)),this._options=s,this.direct=new Set(s.directPeers.map((e=>e.id.toB58String()))),this.acceptFromWhitelist=new Map,s.directPeers.forEach((t=>{e.peerStore.addressBook.add(t.id,t.addrs)})),this.seenCache=new y.SimpleTimeCache({validityMs:s.seenTTL}),this.mesh=new Map,this.fanout=new Map,this.lastpub=new Map,this.gossip=new Map,this.control=new Map,this.peerhave=new Map,this.iasked=new Map,this.backoff=new Map,this.outbound=new Map,this.messageCache=t.messageCache||new c.MessageCache(s.mcacheGossip,s.mcacheLength),this.getFastMsgIdStr=null!==(r=t.fastMsgIdFn)&&void 0!==r?r:void 0,this.fastMsgIdCache=t.fastMsgIdFn?new y.SimpleTimeCache({validityMs:s.seenTTL}):void 0,this.heartbeat=new d.Heartbeat(this),this.heartbeatTicks=0,this.gossipTracer=new g.IWantTracer,this._libp2p=e,this.score=new f.PeerScore(this._options.scoreParams,e.connectionManager)}_decodeRpc(e){return l.RPC.decode(e)}_encodeRpc(e){return l.RPC.encode(e).finish()}_addPeer(e,t){const r=super._addPeer(e,t);this.score.addPeer(e.toB58String());let n=!1;for(const s of this._libp2p.connectionManager.getAll(e))if("outbound"===s.stat.direction&&Array.from(s.registry.values()).some((e=>t===e.protocol))){n=!0;break}return this.outbound.set(r.id.toB58String(),n),r}_removePeer(e){const t=super._removePeer(e),r=e.toB58String();for(const n of this.mesh.values())n.delete(r);for(const n of this.fanout.values())n.delete(r);return this.gossip.delete(r),this.control.delete(r),this.outbound.delete(r),this.score.removePeer(r),this.acceptFromWhitelist.delete(r),t}_processRpc(e,t,r){const n=Object.create(null,{_processRpc:{get:()=>super._processRpc}});return o(this,void 0,void 0,(function*(){return!!(yield n._processRpc.call(this,e,t,r))&&(r.control&&(yield this._processRpcControlMessage(e,r.control)),!0)}))}_processRpcControlMessage(e,t){return o(this,void 0,void 0,(function*(){if(!t)return;const r=t.ihave?this._handleIHave(e,t.ihave):[],n=t.iwant?this._handleIWant(e,t.iwant):[],s=t.graft?yield this._handleGraft(e,t.graft):[];if(t.prune&&this._handlePrune(e,t.prune),!r.length&&!n.length&&!s.length)return;const i=p.createGossipRpc(n,{iwant:r,prune:s});this._sendRpc(e,i)}))}_processRpcMessage(e){const t=Object.create(null,{_processRpcMessage:{get:()=>super._processRpcMessage}});return o(this,void 0,void 0,(function*(){let r;if(this.getFastMsgIdStr&&this.fastMsgIdCache){const t=yield this.getFastMsgIdStr(e);if(r=this.fastMsgIdCache.get(t),void 0!==r)return void this.score.duplicateMessage(e,r);r=p.messageIdToString(yield this.getMsgId(e)),this.fastMsgIdCache.put(t,r)}else if(r=p.messageIdToString(yield this.getMsgId(e)),this.seenCache.has(r))return void this.score.duplicateMessage(e,r);this.seenCache.put(r),yield this.score.validateMessage(r),yield t._processRpcMessage.call(this,e)}))}_acceptFrom(e){if(this.direct.has(e))return!0;const t=Date.now(),r=this.acceptFromWhitelist.get(e);if(r&&r.messagesAccepted<b.ACCEPT_FROM_WHITELIST_MAX_MESSAGES&&r.acceptUntil>=t)return r.messagesAccepted+=1,!0;const n=this.score.score(e);return n>=b.ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE?this.acceptFromWhitelist.set(e,{messagesAccepted:0,acceptUntil:t+b.ACCEPT_FROM_WHITELIST_DURATION_MS}):this.acceptFromWhitelist.delete(e),n>=this._options.scoreThresholds.graylistThreshold}validate(e){const t=Object.create(null,{validate:{get:()=>super.validate}});return o(this,void 0,void 0,(function*(){try{yield t.validate.call(this,e)}catch(r){const t=yield this.getCanonicalMsgIdStr(e);throw this.score.rejectMessage(e,t,r.code),this.gossipTracer.rejectMessage(t,r.code),r}}))}_handleIHave(e,t){if(!t.length)return[];const r=this.score.score(e);if(r<this._options.scoreThresholds.gossipThreshold)return this.log("IHAVE: ignoring peer %s with score below threshold [ score = %d ]",e,r),[];const n=(this.peerhave.get(e)||0)+1;if(this.peerhave.set(e,n),n>u.GossipsubMaxIHaveMessages)return this.log("IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring",e,n),[];const s=this.iasked.get(e)||0;if(s>=u.GossipsubMaxIHaveLength)return this.log("IHAVE: peer %s has already advertised too many messages (%d); ignoring",e,s),[];const i=new Map;if(t.forEach((e=>{let{topicID:t,messageIDs:r}=e;t&&r&&this.mesh.has(t)&&r.forEach((e=>{const t=p.messageIdToString(e);this.seenCache.has(t)||i.set(t,e)}))})),!i.size)return[];let o=i.size;o+s>u.GossipsubMaxIHaveLength&&(o=u.GossipsubMaxIHaveLength-s),this.log("IHAVE: Asking for %d out of %d messages from %s",o,i.size,e);let a=Array.from(i.values());return p.shuffle(a),a=a.slice(0,o),this.iasked.set(e,s+o),this.gossipTracer.addPromise(e,a),[{messageIDs:a}]}_handleIWant(e,t){if(!t.length)return[];const r=this.score.score(e);if(r<this._options.scoreThresholds.gossipThreshold)return this.log("IWANT: ignoring peer %s with score below threshold [score = %d]",e,r),[];const n=new Map;return t.forEach((t=>{let{messageIDs:r}=t;r&&r.forEach((t=>{const r=p.messageIdToString(t),[s,i]=this.messageCache.getForPeer(r,e);s&&(i>u.GossipsubGossipRetransmission?this.log("IWANT: Peer %s has asked for message %s too many times: ignoring request",e,t):n.set(r,s))}))})),n.size?(this.log("IWANT: Sending %d messages to %s",n.size,e),Array.from(n.values()).map(a.utils.normalizeOutRpcMessage)):[]}_handleGraft(e,t){return o(this,void 0,void 0,(function*(){const r=[],n=this.score.score(e),s=this._now();let i=this._options.doPX;return t.forEach((t=>{let{topicID:o}=t;var a;if(!o)return;const c=this.mesh.get(o);if(!c)return void(i=!1);if(c.has(e))return;if(this.direct.has(e))return this.log("GRAFT: ignoring request from direct peer %s",e),r.push(o),void(i=!1);const l=null===(a=this.backoff.get(o))||void 0===a?void 0:a.get(e);if("number"===typeof l&&s<l){this.log("GRAFT: ignoring backed off peer %s",e),this.score.addPenalty(e,1),i=!1;const t=l+u.GossipsubGraftFloodThreshold-u.GossipsubPruneBackoff;return s<t&&this.score.addPenalty(e,1),this._addBackoff(e,o),void r.push(o)}return n<0?(this.log("GRAFT: ignoring peer %s with negative score: score=%d, topic=%s",e,n,o),r.push(o),i=!1,void this._addBackoff(e,o)):c.size>=this._options.Dhi&&!this.outbound.get(e)?(r.push(o),void this._addBackoff(e,o)):(this.log("GRAFT: Add mesh link from %s in %s",e,o),this.score.graft(e,o),void c.add(e))})),r.length?Promise.all(r.map((t=>this._makePrune(e,t,i)))):[]}))}_handlePrune(e,t){const r=this.score.score(e);t.forEach((t=>{let{topicID:n,backoff:s,peers:i}=t;if(!n)return;const o=this.mesh.get(n);if(o&&(this.log("PRUNE: Remove mesh link to %s in %s",e,n),this.score.prune(e,n),o.delete(e),"number"===typeof s&&s>0?this._doAddBackoff(e,n,1e3*s):this._addBackoff(e,n),i&&i.length)){if(r<this._options.scoreThresholds.acceptPXThreshold)return void this.log("PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]",e,r,n);this._pxConnect(i)}}))}_addBackoff(e,t){this._doAddBackoff(e,t,u.GossipsubPruneBackoff)}_doAddBackoff(e,t,r){let n=this.backoff.get(t);n||(n=new Map,this.backoff.set(t,n));const s=this._now()+r;(n.get(e)||0)<s&&n.set(e,s)}_applyIwantPenalties(){this.gossipTracer.getBrokenPromises().forEach(((e,t)=>{this.log("peer %s didn't follow up in %d IWANT requests; adding penalty",t,e),this.score.addPenalty(t,e)}))}_clearBackoff(){if(this.heartbeatTicks%u.GossipsubPruneBackoffTicks!==0)return;const e=this._now();this.backoff.forEach(((t,r)=>{t.forEach(((r,n)=>{r<e&&t.delete(n)})),0===t.size&&this.backoff.delete(r)}))}_directConnect(){if(this.heartbeatTicks%u.GossipsubDirectConnectTicks!==0)return;const e=[];this.direct.forEach((t=>{const r=this.peers.get(t);r&&r.isWritable||e.push(t)})),e.length&&e.forEach((e=>{this._connect(e)}))}_pxConnect(e){return o(this,void 0,void 0,(function*(){e.length>u.GossipsubPrunePeers&&(p.shuffle(e),e=e.slice(0,u.GossipsubPrunePeers));const t=[];yield Promise.all(e.map((e=>o(this,void 0,void 0,(function*(){if(!e.peerID)return;const r=m.createFromBytes(e.peerID).toB58String();if(!this.peers.has(r))if(e.signedPeerRecord)try{const n=yield w.openAndCertify(e.signedPeerRecord,"libp2p-peer-record"),s=n.peerId.toB58String();if(r!==s)return void this.log("bogus peer record obtained through px: peer ID %s doesn't match expected peer %s",s,r);if(!this._libp2p.peerStore.addressBook.consumePeerRecord(n))return void this.log("bogus peer record obtained through px: could not add peer record to address book");t.push(r)}catch(n){this.log("bogus peer record obtained through px: invalid signature or not a peer record")}else t.push(r)}))))),t.length&&t.forEach((e=>this._connect(e)))}))}start(){const e=Object.create(null,{start:{get:()=>super.start}});return o(this,void 0,void 0,(function*(){yield e.start.call(this),this.heartbeat.start(),this.score.start(),this._directPeerInitial=setTimeout((()=>{this.direct.forEach((e=>{this._connect(e)}))}),u.GossipsubDirectConnectInitialDelay)}))}stop(){const e=Object.create(null,{stop:{get:()=>super.stop}});return o(this,void 0,void 0,(function*(){yield e.stop.call(this),this.heartbeat.stop(),this.score.stop(),this.mesh=new Map,this.fanout=new Map,this.lastpub=new Map,this.gossip=new Map,this.control=new Map,this.peerhave=new Map,this.iasked=new Map,this.backoff=new Map,this.outbound=new Map,this.gossipTracer.clear(),this.seenCache.clear(),this.fastMsgIdCache&&this.fastMsgIdCache.clear(),clearTimeout(this._directPeerInitial)}))}_connect(e){this.log("Initiating connection with %s",e),this._libp2p.dialProtocol(m.createFromB58String(e),this.multicodecs)}subscribe(e){super.subscribe(e),this.join(e)}unsubscribe(e){super.unsubscribe(e),this.leave(e)}join(e){if(!this.started)throw new Error("Gossipsub has not started");this.log("JOIN %s",e);const t=this.fanout.get(e);if(t)t.forEach((e=>{this.score.score(e)<0&&t.delete(e)})),t.size<this._options.D&&h.getGossipPeers(this,e,this._options.D-t.size,(e=>!t.has(e)&&!this.direct.has(e)&&this.score.score(e)>=0)).forEach((e=>t.add(e))),this.mesh.set(e,t),this.fanout.delete(e),this.lastpub.delete(e);else{const t=h.getGossipPeers(this,e,this._options.D,(e=>!this.direct.has(e)&&this.score.score(e)>=0));this.mesh.set(e,t)}this.mesh.get(e).forEach((t=>{this.log("JOIN: Add mesh link to %s in %s",t,e),this._sendGraft(t,e)}))}leave(e){if(!this.started)throw new Error("Gossipsub has not started");this.log("LEAVE %s",e);const t=this.mesh.get(e);t&&(t.forEach((t=>{this.log("LEAVE: Remove mesh link to %s in %s",t,e),this._sendPrune(t,e)})),this.mesh.delete(e))}getCanonicalMsgIdStr(e){var t,r;return o(this,void 0,void 0,(function*(){return this.fastMsgIdCache&&this.getFastMsgIdStr&&null!==(r=null!==(t=this.getCachedMsgIdStr(e))&&void 0!==t?t:this.fastMsgIdCache.get(this.getFastMsgIdStr(e)))&&void 0!==r?r:p.messageIdToString(yield this.getMsgId(e))}))}getCachedMsgIdStr(e){}_publish(e){return o(this,void 0,void 0,(function*(){const t=yield this.getCanonicalMsgIdStr(e);e.receivedFrom!==this.peerId.toB58String()&&(this.score.deliverMessage(e,t),this.gossipTracer.deliverMessage(t)),this.seenCache.put(t),this.messageCache.put(e,t);const r=new Set;e.topicIDs.forEach((t=>{const n=this.topics.get(t);if(n)if(this._options.floodPublish&&e.from===this.peerId.toB58String())n.forEach((e=>{(this.direct.has(e)||this.score.score(e)>=this._options.scoreThresholds.publishThreshold)&&r.add(e)}));else{this.direct.forEach((e=>{r.add(e)})),n.forEach((e=>{const t=this.score.score(e),n=this.peers.get(e);n&&n.protocol===u.FloodsubID&&t>=this._options.scoreThresholds.publishThreshold&&r.add(e)}));let e=this.mesh.get(t);if(!e||!e.size){if(e=this.fanout.get(t),!e){const r=h.getGossipPeers(this,t,this._options.D,(e=>this.score.score(e)>=this._options.scoreThresholds.publishThreshold));r.size>0?(e=r,this.fanout.set(t,r)):e=new Set}this.lastpub.set(t,this._now())}e.forEach((e=>{r.add(e)}))}}));const n=p.createGossipRpc([a.utils.normalizeOutRpcMessage(e)]);r.forEach((t=>{t!==e.from&&this._sendRpc(t,n)}))}))}_sendGraft(e,t){const r=[{topicID:t}],n=p.createGossipRpc([],{graft:r});this._sendRpc(e,n)}_sendPrune(e,t){return o(this,void 0,void 0,(function*(){const r=[yield this._makePrune(e,t,this._options.doPX)],n=p.createGossipRpc([],{prune:r});this._sendRpc(e,n)}))}_sendRpc(e,t){const r=this.peers.get(e);if(!r||!r.isWritable)return;const n=this.control.get(e);n&&(this._piggybackControl(e,t,n),this.control.delete(e));const s=this.gossip.get(e);s&&(this._piggybackGossip(e,t,s),this.gossip.delete(e)),r.write(l.RPC.encode(t).finish())}_piggybackControl(e,t,r){const n=(r.graft||[]).filter((t=>{let{topicID:r}=t;return(r&&this.mesh.get(r)||new Set).has(e)})),s=(r.prune||[]).filter((t=>{let{topicID:r}=t;return!(r&&this.mesh.get(r)||new Set).has(e)}));(n.length||s.length)&&(t.control?(t.control.graft=t.control.graft&&t.control.graft.concat(n),t.control.prune=t.control.prune&&t.control.prune.concat(s)):t.control={ihave:[],iwant:[],graft:n,prune:s})}_piggybackGossip(e,t,r){t.control||(t.control={ihave:[],iwant:[],graft:[],prune:[]}),t.control.ihave=r}_sendGraftPrune(e,t,r){return o(this,void 0,void 0,(function*(){const n=this._options.doPX;for(const[s,i]of e){const e=i.map((e=>({topicID:e})));let o=[];const a=t.get(s);a&&(o=yield Promise.all(a.map((e=>this._makePrune(s,e,n&&!r.get(s))))),t.delete(s));const c=p.createGossipRpc([],{graft:e,prune:o});this._sendRpc(s,c)}for(const[e,s]of t){const t=yield Promise.all(s.map((t=>this._makePrune(e,t,n&&!r.get(e))))),i=p.createGossipRpc([],{prune:t});this._sendRpc(e,i)}}))}_emitGossip(e,t){const r=this.messageCache.getGossipIDs(e);if(!r.length)return;p.shuffle(r),r.length>u.GossipsubMaxIHaveLength&&this.log("too many messages for gossip; will truncate IHAVE list (%d messages)",r.length);const n=[],s=this.topics.get(e);if(!s)return;s.forEach((e=>{const r=this.peers.get(e);r&&!t.has(e)&&!this.direct.has(e)&&p.hasGossipProtocol(r.protocol)&&this.score.score(e)>=this._options.scoreThresholds.gossipThreshold&&n.push(e)}));let i=this._options.Dlazy;const o=u.GossipsubGossipFactor*n.length;o>i&&(i=o),i>n.length?i=n.length:p.shuffle(n),n.slice(0,i).forEach((t=>{let n=r;r.length>u.GossipsubMaxIHaveLength&&(n=p.shuffle(n.slice()).slice(0,u.GossipsubMaxIHaveLength)),this._pushGossip(t,{topicID:e,messageIDs:n})}))}_flush(){for(const[e,t]of this.gossip.entries()){this.gossip.delete(e);const r=p.createGossipRpc([],{ihave:t});this._sendRpc(e,r)}for(const[e,t]of this.control.entries()){this.control.delete(e);const r=p.createGossipRpc([],{graft:t.graft,prune:t.prune});this._sendRpc(e,r)}}_pushGossip(e,t){this.log("Add gossip to %s",e);const r=this.gossip.get(e)||[];this.gossip.set(e,r.concat(t))}_now(){return Date.now()}_makePrune(e,t,r){return o(this,void 0,void 0,(function*(){if(this.peers.get(e).protocol===u.GossipsubIDv10)return{topicID:t,peers:[]};const n=u.GossipsubPruneBackoff/1e3;if(!r)return{topicID:t,peers:[],backoff:n};const s=h.getGossipPeers(this,t,u.GossipsubPrunePeers,(t=>t!==e&&this.score.score(t)>=0)),i=yield Promise.all(Array.from(s).map((e=>o(this,void 0,void 0,(function*(){const t=m.createFromB58String(e);return{peerID:t.toBytes(),signedPeerRecord:yield this._libp2p.peerStore.addressBook.getRawEnvelope(t)}})))));return{topicID:t,peers:i,backoff:n}}))}}v.multicodec=u.GossipsubIDv11,e.exports=v},90983:(e,t,r)=>{"use strict";const n=r(37567),s=Symbol.for("@libp2p/js-interfaces/topology/multicodec-topology"),i=r(60720),o=Object.assign(i("libp2p:topology:multicodec-topology"),{error:i("libp2p:topology:multicodec-topology:error")});class a extends n{constructor(e){let{min:t,max:r,multicodecs:n,handlers:s}=e;if(super({min:t,max:r,handlers:s}),!n)throw new Error("one or more multicodec should be provided");if(!s)throw new Error("the handlers should be provided");if("function"!==typeof s.onConnect)throw new Error("the 'onConnect' handler must be provided");if("function"!==typeof s.onDisconnect)throw new Error("the 'onDisconnect' handler must be provided");this.multicodecs=Array.isArray(n)?n:[n],this._registrar=void 0,this._onProtocolChange=this._onProtocolChange.bind(this),this._onPeerConnect=this._onPeerConnect.bind(this)}get[Symbol.toStringTag](){return"Topology"}get[s](){return!0}static isMulticodecTopology(e){return Boolean(e&&e[s])}async setRegistrar(e){this._registrar=e,this._registrar.peerStore.on("change:protocols",this._onProtocolChange),this._registrar.connectionManager.on("peer:connect",this._onPeerConnect),await this._updatePeers(this._registrar.peerStore.getPeers())}async _updatePeers(e){for await(const{id:t,protocols:r}of e)if(this.multicodecs.filter((e=>r.includes(e))).length){this.peers.add(t.toB58String());const e=this._registrar.getConnection(t);e&&this._onConnect(t,e)}else this.peers.delete(t.toB58String())}async _onProtocolChange(e){let{peerId:t,protocols:r}=e;try{const e=this.peers.has(t.toB58String()),n=r.filter((e=>this.multicodecs.includes(e)));e&&0===n.length&&this._onDisconnect(t);for(const s of r)if(this.multicodecs.includes(s)){const e=await this._registrar.peerStore.get(t);return void await this._updatePeers([e])}}catch(n){o.error(n)}}async _onPeerConnect(e){try{const t=e.remotePeer,r=await this._registrar.peerStore.protoBook.get(t);if(!r)return;this.multicodecs.find((e=>r.includes(e)))&&(this.peers.add(t.toB58String()),this._onConnect(t,e))}catch(t){o.error(t)}}}e.exports=a},49616:(e,t,r)=>{"use strict";const{KadDHT:n}=r(58415),{DualKadDHT:s}=r(70022);e.exports={create:e=>new s(new n({...e,protocol:"/ipfs/kad/1.0.0",lan:!1}),new n({...e,protocol:"/ipfs/lan/kad/1.0.0",clientMode:!1,lan:!0}),e.libp2p)}},48402:(e,t,r)=>{"use strict";e.exports=r(64736)},64736:(e,t,r)=>{"use strict";const n=r(89962),s=r(31730),i=r(60720)("libp2p:mplex"),o=r(7155),a=r(14910),c=r(11999),{MessageTypes:l,MessageTypeNames:u}=r(88809),d=r(91126);class h{constructor(e){e="function"===typeof(e=e||{})?{onStream:e}:e,this._streamId=0,this._streams={initiators:new Map,receivers:new Map},this._options=e,this.sink=this._createSink(),this.source=this._createSource(),this.onStream=e.onStream,this.onStreamEnd=e.onStreamEnd}get streams(){const e=[];return this._streams.initiators.forEach((t=>{e.push(t)})),this._streams.receivers.forEach((t=>{e.push(t)})),e}newStream(e){const t=this._streamId++;e=null==e?t.toString():String(e);const r=this._streams.initiators;return this._newStream({id:t,name:e,type:"initiator",registry:r})}_newReceiverStream(e){let{id:t,name:r}=e;const n=this._streams.receivers;return this._newStream({id:t,name:r,type:"receiver",registry:n})}_newStream(e){let{id:t,name:r,type:n,registry:s}=e;if(s.has(t))throw new Error(`${n} stream ${t} already exists!`);i("new %s stream %s %s",n,t,r);const o=d({id:t,name:r,send:e=>(i.enabled&&i("%s stream %s %s send",n,t,r,{...e,type:u[e.type],data:e.data&&e.data.slice()}),this.source.push(e)),type:n,onEnd:()=>{i("%s stream %s %s ended",n,t,r),s.delete(t),this.onStreamEnd&&this.onStreamEnd(o)},maxMsgSize:this._options.maxMsgSize});return s.set(t,o),o}_createSink(){return async e=>{this._options.signal&&(e=o(e,this._options.signal));try{await n(e,a.decode,c(this._options.maxMsgSize),(async e=>{for await(const t of e)for(const e of t)this._handleIncoming(e)}))}catch(t){return i("error in sink",t),this.source.end(t)}this.source.end()}}_createSource(){const e=s({onEnd:e=>{const{initiators:t,receivers:r}=this._streams;for(const n of t.values())n.abort(e);for(const n of r.values())n.abort(e)},writev:!0});return Object.assign(a.encode(e),{push:e.push,end:e.end,return:e.return})}_handleIncoming(e){let{id:t,type:r,data:n}=e;if(i.enabled&&i("incoming message",{id:t,type:u[r],data:n.slice()}),r===l.NEW_STREAM&&this.onStream){const e=this._newReceiverStream({id:t,name:n.toString()});return this.onStream(e)}const s=(1&r?this._streams.initiators:this._streams.receivers).get(t);if(!s)return i("missing stream %s",t);switch(r){case l.MESSAGE_INITIATOR:case l.MESSAGE_RECEIVER:s.source.push(n);break;case l.CLOSE_INITIATOR:case l.CLOSE_RECEIVER:s.close();break;case l.RESET_INITIATOR:case l.RESET_RECEIVER:s.reset();break;default:i("unknown message type %s",r)}}}h.multicodec="/mplex/6.7.0",e.exports=h},16758:(e,t,r)=>{"use strict";e.exports={Record:r(91453),validator:r(36782),selection:r(55980)}},84856:(e,t,r)=>{"use strict";const n=r(60720),s=n("libp2p:webrtc-star");s.error=n("libp2p:webrtc-star:error");const{EventEmitter:i}=r(36571),o=r(15504),a=r(24177),{AbortError:c}=r(7155),l=r(33192),{supportsWebRTCDataChannels:u}=r(11747),{Multiaddr:d}=r(10006),h=r(44021),p=r(91401),{CODE_CIRCUIT:f}=r(85146),g=r(17931),y=r(92380),{cleanMultiaddr:m,cleanUrlSIO:w}=r(480);function b(){}e.exports=a(class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!e.upgrader)throw new Error("An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.");this._upgrader=e.upgrader,this.sioOptions={transports:["websocket"],"force new connection":!0},e.wrtc&&(this.wrtc=e.wrtc),this.sigReferences=new Map,this.discovery=new i,this.discovery.tag="webRTCStar",this.discovery._isStarted=!1,this.discovery.start=()=>{this.discovery._isStarted=!0},this.discovery.stop=()=>{this.discovery._isStarted=!1},this._peerDiscovered=this._peerDiscovered.bind(this)}async dial(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const r=await this._connect(e,t),n=y(r,{remoteAddr:e,signal:t.signal});s("new outbound connection %s",n.remoteAddr);const i=await this._upgrader.upgradeOutbound(n);return s("outbound connection %s upgraded",n.remoteAddr),i}_connect(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.signal&&t.signal.aborted)throw new c;const r={initiator:!0,trickle:!1,...t.spOptions||{}};this.wrtc&&(r.wrtc=this.wrtc);const n=e.toOptions(),i=(~~(1e9*Math.random())).toString(36)+Date.now();return new Promise(((a,u)=>{const d=this.sigReferences.get(w(e));if(!d||!d.listener)return u(o(new Error("unknown signal server to use"),"ERR_UNKNOWN_SIGNAL_SERVER"));const h=d.listener.io,p=Date.now();let f;s("dialing %s:%s",n.host,n.port);const g=new l(r),y=e=>{if(!f){const t=`connection error ${n.host}:${n.port}: ${e.message}`;s.error(t),_(e)}},m=()=>{s("connnection timeout %s:%s",n.host,n.port);const e=o(new Error(`connection timeout after ${Date.now()-p}ms`),"ERR_CONNECT_TIMEOUT");g.emit("error",e)},b=()=>{f=!0,s("connection opened %s:%s",n.host,n.port),_(null)},v=()=>{s.error("connection aborted %s:%s",n.host,n.port),g.destroy(),_(new c)},_=e=>{g.removeListener("timeout",m),g.removeListener("connect",b),t.signal&&t.signal.removeEventListener("abort",v),e?u(e):a(g)};g.on("error",y),g.once("timeout",m),g.once("connect",b),g.on("close",(()=>{g.removeListener("error",y)})),t.signal&&t.signal.addEventListener("abort",v),g.on("signal",(t=>{h.emit("ss-handshake",{intentId:i,srcMultiaddr:d.signallingAddr.toString(),dstMultiaddr:e.toString(),signal:t})})),h.on("ws-handshake",(e=>{e.intentId===i&&e.err&&(g.destroy(),u(o(e.err instanceof Error?e.err:new Error(e.err),"ERR_SIGNALLING_FAILED"))),e.intentId===i&&e.answer&&!g.destroyed&&g.signal(e.signal)}))}))}createListener(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1?arguments[1]:void 0;if(!u&&!this.wrtc)throw o(new Error("no WebRTC support"),"ERR_NO_WEBRTC_SUPPORT");return"function"===typeof e&&(t=e,e={}),t=t||b,g({handler:t,upgrader:this._upgrader},this,e)}filter(e){return(e=Array.isArray(e)?e:[e]).filter((e=>!e.protoCodes().includes(f)&&h.WebRTCStar.matches(e)))}_peerDiscovered(e){if(!this.discovery._isStarted)return;s("Peer Discovered:",e),e=m(e);const t=new d(e),r=p.createFromB58String(t.getPeerId());this.discovery.emit("peer",{id:r,multiaddrs:[t]})}},{className:"WebRTCStar",symbolName:"@libp2p/js-libp2p-webrtc-star/webrtcstar"})},62162:(e,t,r)=>{"use strict";const n=r(8317),s=r(24177),i=r(36381),{AbortError:o}=r(7155),a=r(61135),c=r(60720),l=c("libp2p:websockets");l.error=c("libp2p:websockets:error");const u=r(41257),d=r(53779),h=r(63221),p=r(17946);e.exports=s(class{constructor(e){let{upgrader:t,filter:r}=e;if(!t)throw new Error("An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.");this._upgrader=t,this._filter=r}async dial(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};l("dialing %s",e);const r=await this._connect(e,t),n=h(r,{remoteAddr:e,signal:t.signal});l("new outbound connection %s",n.remoteAddr);const s=await this._upgrader.upgradeOutbound(n);return l("outbound connection %s upgraded",n.remoteAddr),s}async _connect(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.signal&&t.signal.aborted)throw new o;const r=e.toOptions();l("dialing %s:%s",r.host,r.port);const s=a(),c=e=>{const t=`connection error: ${e.message}`;l.error(t),s.reject(e)},u=n(i(e),Object.assign({binary:!0},t));if(u.socket.on?u.socket.on("error",c):u.socket.onerror=c,!t.signal)return await Promise.race([u.connected(),s.promise]),l("connected %s",e),u;let d;const h=new Promise(((e,r)=>{if(d=()=>{r(new o),setTimeout((()=>{u.close()}))},t.signal.aborted)return d();t.signal.addEventListener("abort",d)}));try{await Promise.race([h,s.promise,u.connected()])}finally{t.signal.removeEventListener("abort",d)}return l("connected %s",e),u}createListener(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1?arguments[1]:void 0;return"function"===typeof e&&(t=e,e={}),d({handler:t,upgrader:this._upgrader},e)}filter(e){return e=Array.isArray(e)?e:[e],this._filter?this._filter(e):u.isBrowser||u.isWebWorker?p.dnsWss(e):p.all(e)}},{className:"WebSockets",symbolName:"@libp2p/js-libp2p-websockets/websockets"})},60403:(e,t,r)=>{"use strict";const n=r(60720),s=Object.assign(n("libp2p"),{error:n("libp2p:err")}),{EventEmitter:i}=r(36571),o=r(15504),a=r(91401),{Multiaddr:c}=r(10006),{MemoryDatastore:l}=r(51854),u=r(41216),d=r(34646),h=r(95096),{validate:p}=r(22586),{codes:f,messages:g}=r(90707),y=r(41404),m=r(27069),w=r(27202),b=r(66537),v=r(12271),_=r(44546),k=r(71464),E=r(67340),I=r(69725),S=r(61704),P=r(28623),A=r(80796),R=r(30324),C=r(74166),T=r(55763),D=r(6944),B=r(80850),{updateSelfPeerRecord:x}=r(23055);class N extends i{static async create(e){if(e.peerId)return new N(e);const t=await a.create();return e.peerId=t,new N(e)}constructor(e){if(super(),this._options=p(e),this.peerId=this._options.peerId,this.datastore=this._options.datastore,this._options.metrics.enabled){const e=new E({...this._options.metrics});this.metrics=e}if(this.connectionGater={denyDialPeer:async()=>Promise.resolve(!1),denyDialMultiaddr:async()=>Promise.resolve(!1),denyInboundConnection:async()=>Promise.resolve(!1),denyOutboundConnection:async()=>Promise.resolve(!1),denyInboundEncryptedConnection:async()=>Promise.resolve(!1),denyOutboundEncryptedConnection:async()=>Promise.resolve(!1),denyInboundUpgradedConnection:async()=>Promise.resolve(!1),denyOutboundUpgradedConnection:async()=>Promise.resolve(!1),filterMultiaddrForPeer:async()=>Promise.resolve(!0),...this._options.connectionGater},this.peerStore=new P({peerId:this.peerId,datastore:this.datastore&&this._options.peerStore.persistence?this.datastore:new l,addressFilter:this.connectionGater.filterMultiaddrForPeer}),this.addresses=this._options.addresses,this.addressManager=new y(this.peerId,this._options.addresses),this.addressManager.on("change:addresses",(()=>{x(this).catch((e=>{s.error("Error updating self peer record",e)}))})),this._modules=this._options.modules,this._config=this._options.config,this._transport=[],this._discovery=new Map,this.connectionManager=new m(this,{...this._options.connectionManager}),this._autodialler=new w(this,{enabled:this._config.peerDiscovery.autoDial,minConnections:this._options.connectionManager.minConnections,autoDialInterval:this._options.connectionManager.autoDialInterval}),this._options.keychain&&this._options.keychain.datastore){s("creating keychain");const e=k.generateOptions();this.keychain=new k(this._options.keychain.datastore,{...e,...this._options.keychain}),s("keychain constructed")}if(this.upgrader=new S({connectionGater:this.connectionGater,localPeer:this.peerId,metrics:this.metrics,onConnection:e=>this.connectionManager.onConnect(e),onConnectionEnd:e=>this.connectionManager.onDisconnect(e)}),this.transportManager=new I({libp2p:this,upgrader:this.upgrader,faultTolerance:this._options.transportManager.faultTolerance}),this.natManager=new B({peerId:this.peerId,addressManager:this.addressManager,transportManager:this.transportManager,...this._options.config.nat}),this.registrar=new R({peerStore:this.peerStore,connectionManager:this.connectionManager}),this.handle=this.handle.bind(this),this.registrar.handle=this.handle,!this._modules.connEncryption||!this._modules.connEncryption.length)throw o(new Error(g.CONN_ENCRYPTION_REQUIRED),f.CONN_ENCRYPTION_REQUIRED);if(this._modules.connEncryption.forEach((e=>{this.upgrader.cryptos.set(e.protocol,e)})),this.dialer=new _({transportManager:this.transportManager,connectionGater:this.connectionGater,peerStore:this.peerStore,metrics:this.metrics,...this._options.dialer}),this._modules.transport.forEach((e=>{const t=e.prototype[Symbol.toStringTag],r=this._config.transport[t];this.transportManager.add(t,e,r)})),this._config.relay.enabled&&(this.transportManager.add(b.prototype[Symbol.toStringTag],b),this.relay=new v(this)),this._modules.streamMuxer){this._modules.streamMuxer.forEach((e=>{this.upgrader.muxers.set(e.multicodec,e)})),this.identifyService=new C({libp2p:this})}if(this._modules.connProtector)this.upgrader.protector=this._modules.connProtector;else if(void 0!==globalThis.process&&globalThis.process.env&&globalThis.process.env.LIBP2P_FORCE_PNET)throw new Error("Private network is enforced, but no protector was provided");if(this._modules.dht){const e=this._modules.dht;this._dht=e.create({libp2p:this,...this._config.dht})}if(this._modules.pubsub){const e=this._modules.pubsub;this.pubsub=A(e,this,this._config.pubsub)}this.peerRouting=new u(this),this.contentRouting=new d(this),this._onDiscoveryPeer=this._onDiscoveryPeer.bind(this),this.fetchService=new T(this),this.pingService=new D(this)}emit(e){for(var t=arguments.length,r=new Array(t>1?t-1:0),n=1;n<t;n++)r[n-1]=arguments[n];return"error"!==e||this._events.error?super.emit(e,...r):(s.error(r),!1)}async start(){s("libp2p is starting"),this.identifyService&&await this.handle(Object.values(C.getProtocolStr(this)),this.identifyService.handleMessage),this.fetchService&&await this.handle(T.PROTOCOL,this.fetchService.handleMessage),this.pingService&&await this.handle(D.getProtocolStr(this),this.pingService.handleMessage);try{await this._onStarting(),await this._onDidStart(),s("libp2p has started")}catch(e){throw this.emit("error",e),s.error("An error occurred starting libp2p",e),await this.stop(),e}}async stop(){s("libp2p is stopping");try{this._isStarted=!1,this.identifyService&&await this.identifyService.stop(),this.relay&&this.relay.stop(),this.peerRouting.stop(),await this._autodialler.stop(),await(this._dht&&this._dht.stop());for(const e of this._discovery.values())e.removeListener("peer",this._onDiscoveryPeer);await Promise.all(Array.from(this._discovery.values(),(e=>e.stop()))),this._discovery=new Map,await this.connectionManager.stop(),await Promise.all([this.pubsub&&this.pubsub.stop(),this.metrics&&this.metrics.stop()]),await this.natManager.stop(),await this.transportManager.close(),await this.unhandle(T.PROTOCOL),await this.unhandle(D.getProtocolStr(this)),this.dialer.destroy()}catch(e){e&&(s.error(e),this.emit("error",e))}s("libp2p has stopped")}async loadKeychain(){if(this.keychain)try{await this.keychain.findKeyByName("self")}catch(e){await this.keychain.importPeer("self",this.peerId)}}isStarted(){return this._isStarted}get connections(){return this.connectionManager.connections}dial(e,t){return this._dial(e,t)}async dialProtocol(e,t,r){if(!t||!t.length)throw o(new Error("no protocols were provided to open a stream"),f.ERR_INVALID_PROTOCOLS_FOR_STREAM);return(await this._dial(e,r)).newStream(t)}async _dial(e,t){const{id:r,multiaddrs:n}=h(e);if(r.equals(this.peerId))throw o(new Error("Cannot dial self"),f.ERR_DIALED_SELF);let s=this.connectionManager.get(r);return s?n&&await this.peerStore.addressBook.add(r,n):s=await this.dialer.connectToPeer(e,t),s}get multiaddrs(){let e=this.addressManager.getAnnounceAddrs().map((e=>e.toString()));e.length||(e=this.transportManager.getAddrs().map((e=>e.toString()))),e=e.concat(this.addressManager.getObservedAddrs().map((e=>e.toString())));const t=this._options.addresses.announceFilter,r=new Set(e);return t(Array.from(r).map((e=>new c(e))))}async hangUp(e){const{id:t}=h(e),r=this.connectionManager.connections.get(t.toB58String());r&&await Promise.all(r.map((e=>e.close())))}fetch(e,t){return this.fetchService.fetch(e,t)}ping(e){const{id:t,multiaddrs:r}=h(e);return r?this.pingService.ping(r[0]):this.pingService.ping(t)}async handle(e,t){(e=Array.isArray(e)?e:[e]).forEach((e=>{this.upgrader.protocols.set(e,t)})),await this.peerStore.protoBook.add(this.peerId,e)}async unhandle(e){(e=Array.isArray(e)?e:[e]).forEach((e=>{this.upgrader.protocols.delete(e)})),await this.peerStore.protoBook.remove(this.peerId,e)}async _onStarting(){const e=this.addressManager.getListenAddrs();await this.transportManager.listen(e),this.natManager.start(),this._config.pubsub.enabled&&this.pubsub&&await this.pubsub.start(),this._config.dht.enabled&&(this._dht&&await this._dht.start(),this._dht.on("peer",this._onDiscoveryPeer)),this.metrics&&this.metrics.start(),this.identifyService&&await this.identifyService.start()}async _onDidStart(){this._isStarted=!0,this.peerStore.on("peer",(e=>{this.emit("peer:discovery",e),this._maybeConnect(e).catch((e=>{s.error(e)}))}));for await(const e of this.peerStore.getPeers())this.emit("peer:discovery",e.id);this.connectionManager.start(),await this._autodialler.start(),await this._setupPeerDiscovery(),this.relay&&this.relay.start(),this.peerRouting.start()}_onDiscoveryPeer(e){e.id.toB58String()!==this.peerId.toB58String()?(e.multiaddrs&&this.peerStore.addressBook.add(e.id,e.multiaddrs).catch((e=>s.error(e))),e.protocols&&this.peerStore.protoBook.set(e.id,e.protocols).catch((e=>s.error(e)))):s.error(new Error(f.ERR_DISCOVERED_SELF))}async _maybeConnect(e){if(!0===this._config.peerDiscovery.autoDial&&!this.connectionManager.get(e)){if((this._options.connectionManager.minConnections||0)>this.connectionManager.size){s("connecting to discovered peer %s",e.toB58String());try{await this.dialer.connectToPeer(e)}catch(t){s.error(`could not connect to discovered peer ${e.toB58String()} with ${t}`)}}}}async _setupPeerDiscovery(){const e=e=>{let t={enabled:!0};if(e.tag&&this._config.peerDiscovery&&this._config.peerDiscovery[e.tag]&&(t={...t,...this._config.peerDiscovery[e.tag]}),t.enabled&&!this._discovery.has(e.tag)){let r;r="function"===typeof e?new e(Object.assign({},t,{peerId:this.peerId,libp2p:this})):e,r.on("peer",this._onDiscoveryPeer),this._discovery.set(e.tag,r)}};for(const t of this._modules.peerDiscovery||[])e(t);for(const t of this.transportManager.getTransports())t.discovery&&e(t.discovery);await Promise.all(Array.from(this._discovery.values(),(e=>e.start())))}}e.exports=N},71038:e=>{"use strict";class t extends Map{constructor(e){super();const{system:t,component:r,metric:n,metrics:s}=e;this._system=t,this._component=r,this._metric=n,this._metrics=s,this._metrics.updateComponentMetric({system:this._system,component:this._component,metric:this._metric,value:this.size})}set(e,t){return super.set(e,t),this._metrics.updateComponentMetric({system:this._system,component:this._component,metric:this._metric,value:this.size}),this}delete(e){const t=super.delete(e);return this._metrics.updateComponentMetric({system:this._system,component:this._component,metric:this._metric,value:this.size}),t}clear(){super.clear(),this._metrics.updateComponentMetric({system:this._system,component:this._component,metric:this._metric,value:this.size})}}e.exports=e=>{let r,{system:n="libp2p",component:s,metric:i,metrics:o}=e;return r=o?new t({system:n,component:s,metric:i,metrics:o}):new Map,r}},44021:(e,t,r)=>{"use strict";const{Multiaddr:n}=r(10006),s=T("dns4"),i=T("dns6"),o=T("dnsaddr"),a=C(T("dns"),o,s,i),c=C(T("ip4"),T("ip6")),l=C(R(c,T("tcp")),R(a,T("tcp"))),u=R(c,T("udp")),d=R(u,T("utp")),h=R(u,T("quic")),p=C(R(l,T("ws")),R(a,T("ws"))),f=C(R(l,T("wss")),R(a,T("wss"))),g=C(R(l,T("http")),R(c,T("http")),R(a,T("http"))),y=C(R(l,T("https")),R(c,T("https")),R(a,T("https"))),m=C(R(p,T("p2p-webrtc-star"),T("p2p")),R(f,T("p2p-webrtc-star"),T("p2p")),R(p,T("p2p-webrtc-star")),R(f,T("p2p-webrtc-star"))),w=C(R(p,T("p2p-websocket-star"),T("p2p")),R(f,T("p2p-websocket-star"),T("p2p")),R(p,T("p2p-websocket-star")),R(f,T("p2p-websocket-star"))),b=C(R(g,T("p2p-webrtc-direct"),T("p2p")),R(y,T("p2p-webrtc-direct"),T("p2p")),R(g,T("p2p-webrtc-direct")),R(y,T("p2p-webrtc-direct"))),v=C(p,f,g,y,m,b,l,d,h,a),_=C(R(v,T("p2p-stardust"),T("p2p")),R(v,T("p2p-stardust"))),k=C(R(v,T("p2p")),m,b,T("p2p")),E=C(R(k,T("p2p-circuit"),k),R(k,T("p2p-circuit")),R(T("p2p-circuit"),k),R(v,T("p2p-circuit")),R(T("p2p-circuit"),v),T("p2p-circuit")),I=()=>C(R(E,I),E),S=I(),P=C(R(S,k,S),R(k,S),R(S,k),S,k);function A(e){return function(t){if(!n.isMultiaddr(t))try{t=new n(t)}catch(s){return!1}const r=e(t.protoNames());return null!==r&&(!0===r||!1===r?r:0===r.length)}}function R(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];function n(e){if(e.length<t.length)return null;let r=e;return t.some((t=>(r="function"===typeof t?t().partialMatch(e):t.partialMatch(e),Array.isArray(r)&&(e=r),null===r))),r}return{toString:function(){return"{ "+t.join(" ")+" }"},input:t,matches:A(n),partialMatch:n}}function C(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];function n(e){let r=null;return t.some((t=>{const n="function"===typeof t?t().partialMatch(e):t.partialMatch(e);return!!n&&(r=n,!0)})),r}const s={toString:function(){return"{ "+t.join(" ")+" }"},input:t,matches:A(n),partialMatch:n};return s}function T(e){const t=e;return{toString:function(){return t},matches:function(e){let r;if("string"===typeof e||e instanceof Uint8Array)try{r=new n(e)}catch(i){return!1}else r=e;const s=r.protoNames();return 1===s.length&&s[0]===t},partialMatch:function(e){return 0===e.length?null:e[0]===t?e.slice(1):null}}}e.exports={DNS:a,DNS4:s,DNS6:i,DNSADDR:o,IP:c,TCP:l,UDP:u,QUIC:h,UTP:d,HTTP:g,HTTPS:y,WebSockets:p,WebSocketsSecure:f,WebSocketStar:w,WebRTCStar:m,WebRTCDirect:b,Reliable:v,Stardust:_,Circuit:S,P2P:P,IPFS:P}},26494:(e,t,r)=>{const n=r(46338),s=r(23432),{default:i}=r(60185),{timeout:o}=r(17474),a=r(548),c={};let l;function u(e,t){let r;const n=new Promise((e=>{r=e}));return e.add((()=>o(new Promise((e=>{r((()=>{e()}))})),t.timeout))),n}const d={concurrency:1/0,timeout:846e5,global:r.g,singleProcess:!1};e.exports=(e,t)=>(t||(t={}),"object"===typeof e&&(t=e,e="lock"),e||(e="lock"),t=Object.assign({},d,t),l||(l=n(t)||s(t),l.isWorker||(l.on("requestReadLock",((e,t)=>{c[e]&&c[e].readLock().then((e=>t().finally((()=>e()))))})),l.on("requestWriteLock",(async(e,t)=>{c[e]&&c[e].writeLock().then((e=>t().finally((()=>e()))))})))),c[e]||(c[e]=((e,t)=>{if(l.isWorker)return{readLock:l.readLock(e,t),writeLock:l.writeLock(e,t)};const r=new i({concurrency:1});let n=null;return{readLock:()=>{if(n)return u(n,t);n=new i({concurrency:t.concurrency,autoStart:!1});const e=n,s=u(n,t);return r.add((()=>(e.start(),e.onIdle().then((()=>{n===e&&(n=null)}))))),s},writeLock:()=>(n=null,u(r,t))}})(e,t)),c[e]),e.exports.Worker=function(e,t){let n;t=t||r.g.Worker;try{n=new t(e)}catch(s){s.message.includes("not a constructor")&&(n=t(e))}if(!n)throw new Error("Could not create Worker from",t);return a(n),n}},36381:(e,t,r)=>{const{Multiaddr:n}=r(10006),s=(e,t)=>t,i={ip4:s,ip6:(e,t,r,n)=>1===n.length&&"ip6"===n[0].protocol?t:`[${t}]`,tcp:(e,t,r,n,s)=>n.some((e=>["http","https","ws","wss"].includes(e.protocol)))?`${e}:${t}`:((e,t,r,n)=>{if(n&&!1===n.assumeHttp)return`tcp://${e}:${t}`;let s="tcp",i=`:${t}`;return"tcp"===r[r.length-1].protocol&&(s="443"===t?"https":"http",i="443"===t||"80"===t?"":i),`${s}://${e}${i}`})(e,t,n,s),udp:(e,t)=>`udp://${e}:${t}`,dnsaddr:s,dns4:s,dns6:s,ipfs:(e,t)=>`${e}/ipfs/${t}`,p2p:(e,t)=>`${e}/p2p/${t}`,http:e=>`http://${e}`,https:e=>`https://${e}`,ws:e=>`ws://${e}`,wss:e=>`wss://${e}`,"p2p-websocket-star":e=>`${e}/p2p-websocket-star`,"p2p-webrtc-star":e=>`${e}/p2p-webrtc-star`,"p2p-webrtc-direct":e=>`${e}/p2p-webrtc-direct`};e.exports=(e,t)=>{const r=new n(e),s=e.toString().split("/").slice(1);return r.tuples().map((e=>({protocol:s.shift(),content:e[1]?s.shift():null}))).reduce(((e,r,n,s)=>{const o=i[r.protocol];if(!o)throw new Error(`Unsupported protocol ${r.protocol}`);return o(e,r.content,n,s,t)}),"")}},45263:(e,t,r)=>{"use strict";e.exports=r(62175)},31579:(e,t,r)=>{"use strict";const n=r(61558);e.exports=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!n(e)&&!Array.isArray(e))throw new TypeError("Expected a plain object or array");const{deep:r}=t,s=[],i=[],o=e=>{const t=s.indexOf(e);if(-1!==t)return i[t];const r=[];return s.push(e),i.push(r),r.push(...e.map((e=>Array.isArray(e)?o(e):n(e)?a(e):e))),r},a=e=>{const c=s.indexOf(e);if(-1!==c)return i[c];const l={},u=Object.keys(e).sort(t.compare);s.push(e),i.push(l);for(const t of u){const s=e[t];let i;i=r&&Array.isArray(s)?o(s):r&&n(s)?a(s):s,Object.defineProperty(l,t,{...Object.getOwnPropertyDescriptor(e,t),value:i})}return l};return Array.isArray(e)?r?o(e):e.slice():a(e)}},98767:(e,t,r)=>{"use strict";const{AbortController:n}=globalThis,s=r(46094);class i extends n{constructor(e){super(),this._ms=e,this._timer=s((()=>this.abort()),e),Object.setPrototypeOf(this,i.prototype)}abort(){return this._timer.clear(),super.abort()}clear(){this._timer.clear()}reset(){this._timer.clear(),this._timer=s((()=>this.abort()),this._ms)}}e.exports={TimeoutController:i}},75617:(e,t,r)=>{e.exports={encode:r(84243),decode:r(69504),encodingLength:r(83754)}},60372:(e,t,r)=>{"use strict";r.r(t),r.d(t,{code:()=>c,decode:()=>u,encode:()=>l,name:()=>a});var n=r(64429),s=r(32743);const i={float64:!0,typeEncoders:{Object:function(e){if(e.asCID!==e)return null;const t=s.CID.asCID(e);if(!t)return null;const r=new Uint8Array(t.bytes.byteLength+1);return r.set(t.bytes,1),[new n.WU(n.Dy.tag,42),new n.WU(n.Dy.bytes,r)]},undefined:function(){throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")},number:function(e){if(Number.isNaN(e))throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");if(e===1/0||e===-1/0)throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");return null}}};const o={allowIndefinite:!1,coerceUndefinedToNull:!0,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,tags:[]};o.tags[42]=function(e){if(0!==e[0])throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");return s.CID.decode(e.subarray(1))};const a="dag-cbor",c=113,l=e=>n.cv(e,i),u=e=>n.Jx(e,o)},47922:(e,t,r)=>{"use strict";r.r(t),r.d(t,{code:()=>R,createLink:()=>P,createNode:()=>S,decode:()=>T,encode:()=>C,name:()=>A,prepare:()=>E,validate:()=>I});var n=r(32743);const s=new TextDecoder;function i(e,t){let r=0;for(let n=0;;n+=7){if(n>=64)throw new Error("protobuf: varint overflow");if(t>=e.length)throw new Error("protobuf: unexpected end of data");const s=e[t++];if(r+=n<28?(127&s)<<n:(127&s)*2**n,s<128)break}return[r,t]}function o(e,t){let r;[r,t]=i(e,t);const n=t+r;if(r<0||n<0)throw new Error("protobuf: invalid length");if(n>e.length)throw new Error("protobuf: unexpected end of data");return[e.subarray(t,n),n]}function a(e,t){let r;return[r,t]=i(e,t),[7&r,r>>3,t]}function c(e){const t={},r=e.length;let n=0;for(;n<r;){let r,c;if([r,c,n]=a(e,n),1===c){if(t.Hash)throw new Error("protobuf: (PBLink) duplicate Hash section");if(2!==r)throw new Error(`protobuf: (PBLink) wrong wireType (${r}) for Hash`);if(void 0!==t.Name)throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");if(void 0!==t.Tsize)throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");[t.Hash,n]=o(e,n)}else if(2===c){if(void 0!==t.Name)throw new Error("protobuf: (PBLink) duplicate Name section");if(2!==r)throw new Error(`protobuf: (PBLink) wrong wireType (${r}) for Name`);if(void 0!==t.Tsize)throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");let i;[i,n]=o(e,n),t.Name=s.decode(i)}else{if(3!==c)throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${c}`);if(void 0!==t.Tsize)throw new Error("protobuf: (PBLink) duplicate Tsize section");if(0!==r)throw new Error(`protobuf: (PBLink) wrong wireType (${r}) for Tsize`);[t.Tsize,n]=i(e,n)}}if(n>r)throw new Error("protobuf: (PBLink) unexpected end of data");return t}const l=new TextEncoder,u=2**32;function d(e,t){let r=t.length;if("number"===typeof e.Tsize){if(e.Tsize<0)throw new Error("Tsize cannot be negative");if(!Number.isSafeInteger(e.Tsize))throw new Error("Tsize too large for encoding");r=f(t,r,e.Tsize)-1,t[r]=24}if("string"===typeof e.Name){const n=l.encode(e.Name);r-=n.length,t.set(n,r),r=f(t,r,n.length)-1,t[r]=18}return e.Hash&&(r-=e.Hash.length,t.set(e.Hash,r),r=f(t,r,e.Hash.length)-1,t[r]=10),t.length-r}function h(e){const t=function(e){let t=0;if(e.Data){const r=e.Data.length;t+=1+r+g(r)}if(e.Links)for(const r of e.Links){const e=p(r);t+=1+e+g(e)}return t}(e),r=new Uint8Array(t);let n=t;if(e.Data&&(n-=e.Data.length,r.set(e.Data,n),n=f(r,n,e.Data.length)-1,r[n]=10),e.Links)for(let s=e.Links.length-1;s>=0;s--){const t=d(e.Links[s],r.subarray(0,n));n-=t,n=f(r,n,t)-1,r[n]=18}return r}function p(e){let t=0;if(e.Hash){const r=e.Hash.length;t+=1+r+g(r)}if("string"===typeof e.Name){const r=l.encode(e.Name).length;t+=1+r+g(r)}return"number"===typeof e.Tsize&&(t+=1+g(e.Tsize)),t}function f(e,t,r){const n=t-=g(r);for(;r>=2147483648;)e[t++]=127&r|128,r/=128;for(;r>=128;)e[t++]=127&r|128,r>>>=7;return e[t]=r,n}function g(e){return e%2===0&&e++,Math.floor((function(e){let t=0;e>=u&&(e=Math.floor(e/u),t=32);e>=65536&&(e>>>=16,t+=16);e>=256&&(e>>>=8,t+=8);return t+y[e]}(e)+6)/7)}const y=[0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8],m=["Data","Links"],w=["Hash","Name","Tsize"],b=new TextEncoder;function v(e,t){if(e===t)return 0;const r=e.Name?b.encode(e.Name):[],n=t.Name?b.encode(t.Name):[];let s=r.length,i=n.length;for(let o=0,a=Math.min(s,i);o<a;++o)if(r[o]!==n[o]){s=r[o],i=n[o];break}return s<i?-1:i<s?1:0}function _(e,t){return!Object.keys(e).some((e=>!t.includes(e)))}function k(e){if("object"===typeof e.asCID){const t=n.CID.asCID(e);if(!t)throw new TypeError("Invalid DAG-PB form");return{Hash:t}}if("object"!==typeof e||Array.isArray(e))throw new TypeError("Invalid DAG-PB form");const t={};if(e.Hash){let s=n.CID.asCID(e.Hash);try{s||("string"===typeof e.Hash?s=n.CID.parse(e.Hash):e.Hash instanceof Uint8Array&&(s=n.CID.decode(e.Hash)))}catch(r){throw new TypeError(`Invalid DAG-PB form: ${r.message}`)}s&&(t.Hash=s)}if(!t.Hash)throw new TypeError("Invalid DAG-PB form");return"string"===typeof e.Name&&(t.Name=e.Name),"number"===typeof e.Tsize&&(t.Tsize=e.Tsize),t}function E(e){if((e instanceof Uint8Array||"string"===typeof e)&&(e={Data:e}),"object"!==typeof e||Array.isArray(e))throw new TypeError("Invalid DAG-PB form");const t={};if(void 0!==e.Data)if("string"===typeof e.Data)t.Data=b.encode(e.Data);else{if(!(e.Data instanceof Uint8Array))throw new TypeError("Invalid DAG-PB form");t.Data=e.Data}if(void 0!==e.Links){if(!Array.isArray(e.Links))throw new TypeError("Invalid DAG-PB form");t.Links=e.Links.map(k),t.Links.sort(v)}else t.Links=[];return t}function I(e){if(!e||"object"!==typeof e||Array.isArray(e))throw new TypeError("Invalid DAG-PB form");if(!_(e,m))throw new TypeError("Invalid DAG-PB form (extraneous properties)");if(void 0!==e.Data&&!(e.Data instanceof Uint8Array))throw new TypeError("Invalid DAG-PB form (Data must be a Uint8Array)");if(!Array.isArray(e.Links))throw new TypeError("Invalid DAG-PB form (Links must be an array)");for(let t=0;t<e.Links.length;t++){const r=e.Links[t];if(!r||"object"!==typeof r||Array.isArray(r))throw new TypeError("Invalid DAG-PB form (bad link object)");if(!_(r,w))throw new TypeError("Invalid DAG-PB form (extraneous properties on link object)");if(!r.Hash)throw new TypeError("Invalid DAG-PB form (link must have a Hash)");if(r.Hash.asCID!==r.Hash)throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");if(void 0!==r.Name&&"string"!==typeof r.Name)throw new TypeError("Invalid DAG-PB form (link Name must be a string)");if(void 0!==r.Tsize&&("number"!==typeof r.Tsize||r.Tsize%1!==0))throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");if(t>0&&-1===v(r,e.Links[t-1]))throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)")}}function S(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return E({Data:e,Links:t})}function P(e,t,r){return k({Hash:r,Name:e,Tsize:t})}const A="dag-pb",R=112;function C(e){I(e);const t={};return e.Links&&(t.Links=e.Links.map((e=>{const t={};return e.Hash&&(t.Hash=e.Hash.bytes),void 0!==e.Name&&(t.Name=e.Name),void 0!==e.Tsize&&(t.Tsize=e.Tsize),t}))),e.Data&&(t.Data=e.Data),h(t)}function T(e){const t=function(e){const t=e.length;let r,n,s=0,i=!1;for(;s<t;){let t,l;if([t,l,s]=a(e,s),2!==t)throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${t}`);if(1===l){if(n)throw new Error("protobuf: (PBNode) duplicate Data section");[n,s]=o(e,s),r&&(i=!0)}else{if(2!==l)throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${l}`);{if(i)throw new Error("protobuf: (PBNode) duplicate Links section");let t;r||(r=[]),[t,s]=o(e,s),r.push(c(t))}}}if(s>t)throw new Error("protobuf: (PBNode) unexpected end of data");const l={};return n&&(l.Data=n),l.Links=r||[],l}(e),r={};return t.Data&&(r.Data=t.Data),t.Links&&(r.Links=t.Links.map((e=>{const t={};try{t.Hash=n.CID.decode(e.Hash)}catch(r){}if(!t.Hash)throw new Error("Invalid Hash field found in link, expected CID");return void 0!==e.Name&&(t.Name=e.Name),void 0!==e.Tsize&&(t.Tsize=e.Tsize),t}))),r}},24349:(e,t,r)=>{"use strict";r.d(t,{Ed:()=>s.E});var n=r(8266),s=r(8511);r(37464)},64429:(e,t,r)=>{"use strict";r.d(t,{Dy:()=>i.D,Jx:()=>s.Jx,WU:()=>i.W,cv:()=>n.cv});var n=r(61041),s=r(4712),i=r(96585)},53460:(e,t,r)=>{"use strict";r.d(t,{BB:()=>c,Dz:()=>a,Pu:()=>m,mL:()=>l,nI:()=>u,qu:()=>f,tP:()=>d,un:()=>p,zo:()=>h});const n=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&"function"===typeof globalThis.Buffer.isBuffer,s=new TextDecoder,i=new TextEncoder;function o(e){return n&&globalThis.Buffer.isBuffer(e)}function a(e){return e instanceof Uint8Array?o(e)?new Uint8Array(e.buffer,e.byteOffset,e.byteLength):e:Uint8Array.from(e)}const c=n?(e,t,r)=>r-t>64?globalThis.Buffer.from(e.subarray(t,r)).toString("utf8"):y(e,t,r):(e,t,r)=>r-t>64?s.decode(e.subarray(t,r)):y(e,t,r),l=n?e=>e.length>64?globalThis.Buffer.from(e):g(e):e=>e.length>64?i.encode(e):g(e),u=e=>Uint8Array.from(e),d=n?(e,t,r)=>o(e)?new Uint8Array(e.subarray(t,r)):e.slice(t,r):(e,t,r)=>e.slice(t,r),h=n?(e,t)=>(e=e.map((e=>e instanceof Uint8Array?e:globalThis.Buffer.from(e))),a(globalThis.Buffer.concat(e,t))):(e,t)=>{const r=new Uint8Array(t);let n=0;for(let s of e)n+s.length>r.length&&(s=s.subarray(0,r.length-n)),r.set(s,n),n+=s.length;return r},p=n?e=>globalThis.Buffer.allocUnsafe(e):e=>new Uint8Array(e);function f(e,t){if(o(e)&&o(t))return e.compare(t);for(let r=0;r<e.length;r++)if(e[r]!==t[r])return e[r]<t[r]?-1:1;return 0}function g(e){let t,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1/0;const n=e.length;let s=null;const i=[];for(let o=0;o<n;++o){if(t=e.charCodeAt(o),t>55295&&t<57344){if(!s){if(t>56319){(r-=3)>-1&&i.push(239,191,189);continue}if(o+1===n){(r-=3)>-1&&i.push(239,191,189);continue}s=t;continue}if(t<56320){(r-=3)>-1&&i.push(239,191,189),s=t;continue}t=65536+(s-55296<<10|t-56320)}else s&&(r-=3)>-1&&i.push(239,191,189);if(s=null,t<128){if((r-=1)<0)break;i.push(t)}else if(t<2048){if((r-=2)<0)break;i.push(t>>6|192,63&t|128)}else if(t<65536){if((r-=3)<0)break;i.push(t>>12|224,t>>6&63|128,63&t|128)}else{if(!(t<1114112))throw new Error("Invalid code point");if((r-=4)<0)break;i.push(t>>18|240,t>>12&63|128,t>>6&63|128,63&t|128)}}return i}function y(e,t,r){const n=[];for(;t<r;){const s=e[t];let i=null,o=s>239?4:s>223?3:s>191?2:1;if(t+o<=r){let r,n,a,c;switch(o){case 1:s<128&&(i=s);break;case 2:r=e[t+1],128===(192&r)&&(c=(31&s)<<6|63&r,c>127&&(i=c));break;case 3:r=e[t+1],n=e[t+2],128===(192&r)&&128===(192&n)&&(c=(15&s)<<12|(63&r)<<6|63&n,c>2047&&(c<55296||c>57343)&&(i=c));break;case 4:r=e[t+1],n=e[t+2],a=e[t+3],128===(192&r)&&128===(192&n)&&128===(192&a)&&(c=(15&s)<<18|(63&r)<<12|(63&n)<<6|63&a,c>65535&&c<1114112&&(i=c))}}null===i?(i=65533,o=1):i>65535&&(i-=65536,n.push(i>>>10&1023|55296),i=56320|1023&i),n.push(i),t+=o}return m(n)}function m(e){const t=e.length;if(t<=4096)return String.fromCharCode.apply(String,e);let r="",n=0;for(;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=4096));return r}},92526:(e,t,r)=>{"use strict";r.d(t,{DO:()=>o,IR:()=>n,OO:()=>s});const n="CBOR decode error:",s="CBOR encode error:",i=[];function o(e,t,r){if(e.length-t<r)throw new Error(`${n} not enough data for type`)}i[23]=1,i[24]=2,i[25]=3,i[26]=5,i[27]=9},4712:(e,t,r)=>{"use strict";r.d(t,{Jx:()=>d});var n=r(92526),s=r(96585),i=r(14829);const o={strict:!1,allowIndefinite:!0,allowUndefined:!0,allowBigInt:!0};class a{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.pos=0,this.data=e,this.options=t}done(){return this.pos>=this.data.length}next(){const e=this.data[this.pos];let t=i.PS[e];if(void 0===t){const r=i.cW[e];if(!r)throw new Error(`${n.IR} no decoder for major type ${e>>>5} (byte 0x${e.toString(16).padStart(2,"0")})`);const s=31&e;t=r(this.data,this.pos,s,this.options)}return this.pos+=t.encodedLength,t}}const c=Symbol.for("DONE"),l=Symbol.for("BREAK");function u(e,t){if(e.done())return c;const r=e.next();if(r.type===s.D.break)return l;if(r.type.terminal)return r.value;if(r.type===s.D.array)return function(e,t,r){const s=[];for(let i=0;i<e.value;i++){const o=u(t,r);if(o===l){if(e.value===1/0)break;throw new Error(`${n.IR} got unexpected break to lengthed array`)}if(o===c)throw new Error(`${n.IR} found array but not enough entries (got ${i}, expected ${e.value})`);s[i]=o}return s}(r,e,t);if(r.type===s.D.map)return function(e,t,r){const s=!0===r.useMaps,i=s?void 0:{},o=s?new Map:void 0;for(let a=0;a<e.value;a++){const d=u(t,r);if(d===l){if(e.value===1/0)break;throw new Error(`${n.IR} got unexpected break to lengthed map`)}if(d===c)throw new Error(`${n.IR} found map but not enough entries (got ${a} [no key], expected ${e.value})`);if(!0!==s&&"string"!==typeof d)throw new Error(`${n.IR} non-string keys not supported (got ${typeof d})`);const h=u(t,r);if(h===c)throw new Error(`${n.IR} found map but not enough entries (got ${a} [no value], expected ${e.value})`);s?o.set(d,h):i[d]=h}return s?o:i}(r,e,t);if(r.type===s.D.tag){if(t.tags&&"function"===typeof t.tags[r.value]){const n=u(e,t);return t.tags[r.value](n)}throw new Error(`${n.IR} tag not supported (${r.value})`)}throw new Error("unsupported")}function d(e,t){if(!(e instanceof Uint8Array))throw new Error(`${n.IR} data to decode must be a Uint8Array`);const r=(t=Object.assign({},o,t)).tokenizer||new a(e,t),s=u(r,t);if(s===c)throw new Error(`${n.IR} did not find any content to decode`);if(s===l)throw new Error(`${n.IR} got unexpected break`);if(!r.done())throw new Error(`${n.IR} too many terminals, data makes no sense`);return s}},61041:(e,t,r)=>{"use strict";r.d(t,{cv:()=>P,w$:()=>S});var n=r(86525),s=r(96585),i=r(56130),o=r(92526),a=r(14829),c=r(53460),l=r(9679),u=r(26421),d=r(99609),h=r(95665),p=r(88925),f=r(68613),g=r(50688),y=r(46947);const m={float64:!1,mapSorter:function(e,t){const r=Array.isArray(e[0])?e[0][0]:e[0],n=Array.isArray(t[0])?t[0][0]:t[0];if(r.type!==n.type)return r.type.compare(n.type);const s=r.type.major,i=w[s].compareTokens(r,n);0===i&&console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");return i},quickEncodeToken:a.JN};const w=function(){const e=[];return e[s.D.uint.major]=l.Fh,e[s.D.negint.major]=u.UT,e[s.D.bytes.major]=d.hg,e[s.D.string.major]=h.YW,e[s.D.array.major]=p.HF,e[s.D.map.major]=f.KI,e[s.D.tag.major]=g.xy,e[s.D.float.major]=y.tA,e}(),b=new i.Bl;class v{constructor(e,t){this.obj=e,this.parent=t}includes(e){let t=this;do{if(t.obj===e)return!0}while(t=t.parent);return!1}static createCheck(e,t){if(e&&e.includes(t))throw new Error(`${o.OO} object contains circular references`);return new v(t,e)}}const _={null:new s.W(s.D.null,null),undefined:new s.W(s.D.undefined,void 0),true:new s.W(s.D.true,!0),false:new s.W(s.D.false,!1),emptyArray:new s.W(s.D.array,0),emptyMap:new s.W(s.D.map,0)},k={number:(e,t,r,n)=>Number.isInteger(e)&&Number.isSafeInteger(e)?e>=0?new s.W(s.D.uint,e):new s.W(s.D.negint,e):new s.W(s.D.float,e),bigint:(e,t,r,n)=>e>=BigInt(0)?new s.W(s.D.uint,e):new s.W(s.D.negint,e),Uint8Array:(e,t,r,n)=>new s.W(s.D.bytes,e),string:(e,t,r,n)=>new s.W(s.D.string,e),boolean:(e,t,r,n)=>e?_.true:_.false,null:(e,t,r,n)=>_.null,undefined:(e,t,r,n)=>_.undefined,ArrayBuffer:(e,t,r,n)=>new s.W(s.D.bytes,new Uint8Array(e)),DataView:(e,t,r,n)=>new s.W(s.D.bytes,new Uint8Array(e.buffer,e.byteOffset,e.byteLength)),Array(e,t,r,n){if(!e.length)return!0===r.addBreakTokens?[_.emptyArray,new s.W(s.D.break)]:_.emptyArray;n=v.createCheck(n,e);const i=[];let o=0;for(const s of e)i[o++]=E(s,r,n);return r.addBreakTokens?[new s.W(s.D.array,e.length),i,new s.W(s.D.break)]:[new s.W(s.D.array,e.length),i]},Object(e,t,r,n){const i="Object"!==t,o=i?e.keys():Object.keys(e),a=i?e.size:o.length;if(!a)return!0===r.addBreakTokens?[_.emptyMap,new s.W(s.D.break)]:_.emptyMap;n=v.createCheck(n,e);const c=[];let l=0;for(const s of o)c[l++]=[E(s,r,n),E(i?e.get(s):e[s],r,n)];return function(e,t){t.mapSorter&&e.sort(t.mapSorter)}(c,r),r.addBreakTokens?[new s.W(s.D.map,a),c,new s.W(s.D.break)]:[new s.W(s.D.map,a),c]}};k.Map=k.Object,k.Buffer=k.Uint8Array;for(const A of"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))k[`${A}Array`]=k.DataView;function E(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=arguments.length>2?arguments[2]:void 0;const s=(0,n.is)(e),i=t&&t.typeEncoders&&t.typeEncoders[s]||k[s];if("function"===typeof i){const n=i(e,s,t,r);if(null!=n)return n}const a=k[s];if(!a)throw new Error(`${o.OO} unsupported type: ${s}`);return a(e,s,t,r)}function I(e,t,r,n){if(Array.isArray(t))for(const s of t)I(e,s,r,n);else r[t.type.major](e,t,n)}function S(e,t,r){const n=E(e,r);if(!Array.isArray(n)&&r.quickEncodeToken){const e=r.quickEncodeToken(n);if(e)return e;const s=t[n.type.major];if(s.encodedSize){const e=s.encodedSize(n,r),t=new i.Bl(e);if(s(t,n,r),1!==t.chunks.length)throw new Error(`Unexpected error: pre-calculated length for ${n} was wrong`);return(0,c.Dz)(t.chunks[0])}}return b.reset(),I(b,n,t,r),b.toBytes(!0)}function P(e,t){return t=Object.assign({},m,t),S(e,w,t)}},25937:(e,t,r)=>{"use strict";r.d(t,{c:()=>l});var n=r(96585),s=r(61041),i=r(92526),o=r(53460);class a extends Array{constructor(){super(),this.inRecursive=[]}prefix(e){const t=this.inRecursive[this.inRecursive.length-1];t&&(t.type===n.D.array&&(t.elements++,1!==t.elements&&e.push([44])),t.type===n.D.map&&(t.elements++,1!==t.elements&&(t.elements%2===1?e.push([44]):e.push([58]))))}[n.D.uint.major](e,t){this.prefix(e);const r=String(t.value),n=[];for(let s=0;s<r.length;s++)n[s]=r.charCodeAt(s);e.push(n)}[n.D.negint.major](e,t){this[n.D.uint.major](e,t)}[n.D.bytes.major](e,t){throw new Error(`${i.OO} unsupported type: Uint8Array`)}[n.D.string.major](e,t){this.prefix(e);const r=(0,o.mL)(JSON.stringify(t.value));e.push(r.length>32?(0,o.Dz)(r):r)}[n.D.array.major](e,t){this.prefix(e),this.inRecursive.push({type:n.D.array,elements:0}),e.push([91])}[n.D.map.major](e,t){this.prefix(e),this.inRecursive.push({type:n.D.map,elements:0}),e.push([123])}[n.D.tag.major](e,t){}[n.D.float.major](e,t){if("break"===t.type.name){const t=this.inRecursive.pop();if(t){if(t.type===n.D.array)e.push([93]);else{if(t.type!==n.D.map)throw new Error("Unexpected recursive type; this should not happen!");e.push([125])}return}throw new Error("Unexpected break; this should not happen!")}if(void 0===t.value)throw new Error(`${i.OO} unsupported type: undefined`);if(this.prefix(e),"true"===t.type.name)return void e.push([116,114,117,101]);if("false"===t.type.name)return void e.push([102,97,108,115,101]);if("null"===t.type.name)return void e.push([110,117,108,108]);const r=String(t.value),s=[];let o=!1;for(let n=0;n<r.length;n++)s[n]=r.charCodeAt(n),o||46!==s[n]&&101!==s[n]&&69!==s[n]||(o=!0);o||(s.push(46),s.push(48)),e.push(s)}}const c={addBreakTokens:!0,mapSorter:function(e,t){if(Array.isArray(e[0])||Array.isArray(t[0]))throw new Error(`${i.OO} complex map keys are not supported`);const r=e[0],s=t[0];if(r.type!==n.D.string||s.type!==n.D.string)throw new Error(`${i.OO} non-string map keys are not supported`);if(r<s)return-1;if(r>s)return 1;throw new Error(`${i.OO} unexpected duplicate map keys, this is not supported`)}};function l(e,t){return t=Object.assign({},c,t),(0,s.w$)(e,new a,t)}},14829:(e,t,r)=>{"use strict";r.d(t,{JN:()=>w,PS:()=>m,cW:()=>y});var n=r(96585),s=r(9679),i=r(26421),o=r(99609),a=r(95665),c=r(88925),l=r(68613),u=r(50688),d=r(46947),h=r(92526),p=r(53460);function f(e,t,r){throw new Error(`${h.IR} encountered invalid minor (${r}) for major ${e[t]>>>5}`)}function g(e){return()=>{throw new Error(`${h.IR} ${e}`)}}const y=[];for(let b=0;b<=23;b++)y[b]=f;y[24]=s.Km,y[25]=s.Zh,y[26]=s.cs,y[27]=s.uN,y[28]=f,y[29]=f,y[30]=f,y[31]=f;for(let b=32;b<=55;b++)y[b]=f;y[56]=i.yr,y[57]=i.r0,y[58]=i.wy,y[59]=i.ec,y[60]=f,y[61]=f,y[62]=f,y[63]=f;for(let b=64;b<=87;b++)y[b]=o.Ii;y[88]=o.UQ,y[89]=o.BS,y[90]=o.zU,y[91]=o.ME,y[92]=f,y[93]=f,y[94]=f,y[95]=g("indefinite length bytes/strings are not supported");for(let b=96;b<=119;b++)y[b]=a.nt;y[120]=a.Bq,y[121]=a.h,y[122]=a.q0,y[123]=a.bc,y[124]=f,y[125]=f,y[126]=f,y[127]=g("indefinite length bytes/strings are not supported");for(let b=128;b<=151;b++)y[b]=c.Ju;y[152]=c.h7,y[153]=c.OC,y[154]=c.lY,y[155]=c.a8,y[156]=f,y[157]=f,y[158]=f,y[159]=c.s5;for(let b=160;b<=183;b++)y[b]=l._K;y[184]=l.G,y[185]=l.qe,y[186]=l.IY,y[187]=l.F2,y[188]=f,y[189]=f,y[190]=f,y[191]=l.ng;for(let b=192;b<=215;b++)y[b]=u.qJ;y[216]=u.ZR,y[217]=u.CF,y[218]=u.vP,y[219]=u.MV,y[220]=f,y[221]=f,y[222]=f,y[223]=f;for(let b=224;b<=243;b++)y[b]=g("simple values are not supported");y[244]=f,y[245]=f,y[246]=f,y[247]=d.h1,y[248]=g("simple values are not supported"),y[249]=d.mW,y[250]=d.GI,y[251]=d.vV,y[252]=f,y[253]=f,y[254]=f,y[255]=d.y7;const m=[];for(let b=0;b<24;b++)m[b]=new n.W(n.D.uint,b,1);for(let b=-1;b>=-24;b--)m[31-b]=new n.W(n.D.negint,b,1);function w(e){switch(e.type){case n.D.false:return(0,p.nI)([244]);case n.D.true:return(0,p.nI)([245]);case n.D.null:return(0,p.nI)([246]);case n.D.bytes:return e.value.length?void 0:(0,p.nI)([64]);case n.D.string:return""===e.value?(0,p.nI)([96]):void 0;case n.D.array:return 0===e.value?(0,p.nI)([128]):void 0;case n.D.map:return 0===e.value?(0,p.nI)([160]):void 0;case n.D.uint:return e.value<24?(0,p.nI)([Number(e.value)]):void 0;case n.D.negint:if(e.value>=-24)return(0,p.nI)([31-Number(e.value)])}}m[64]=new n.W(n.D.bytes,new Uint8Array(0),1),m[96]=new n.W(n.D.string,"",1),m[128]=new n.W(n.D.array,0,1),m[160]=new n.W(n.D.map,0,1),m[244]=new n.W(n.D.false,!1,1),m[245]=new n.W(n.D.true,!0,1),m[246]=new n.W(n.D.null,null,1)},96585:(e,t,r)=>{"use strict";r.d(t,{D:()=>n,W:()=>s});class n{constructor(e,t,r){this.major=e,this.majorEncoded=e<<5,this.name=t,this.terminal=r}toString(){return`Type[${this.major}].${this.name}`}compare(e){return this.major<e.major?-1:this.major>e.major?1:0}}n.uint=new n(0,"uint",!0),n.negint=new n(1,"negint",!0),n.bytes=new n(2,"bytes",!0),n.string=new n(3,"string",!0),n.array=new n(4,"array",!1),n.map=new n(5,"map",!1),n.tag=new n(6,"tag",!1),n.float=new n(7,"float",!0),n.false=new n(7,"false",!0),n.true=new n(7,"true",!0),n.null=new n(7,"null",!0),n.undefined=new n(7,"undefined",!0),n.break=new n(7,"break",!0);class s{constructor(e,t,r){this.type=e,this.value=t,this.encodedLength=r,this.encodedBytes=void 0,this.byteValue=void 0}toString(){return`Token[${this.type}].${this.value}`}}},62287:(e,t,r)=>{"use strict";r.r(t),r.d(t,{BaseDatastore:()=>i.e,Errors:()=>h,KeyTransformDatastore:()=>a.v,MemoryDatastore:()=>o.MemoryDatastore,MountDatastore:()=>l.L,NamespaceDatastore:()=>d.v,ShardingDatastore:()=>c.G,TieredDatastore:()=>u.z,shard:()=>p});var n=r(66957),s=r(87511),i=r(8954),o=r(51854),a=r(13252),c=r(64661),l=r(11524),u=r(97823),d=r(69611);const h=n,p=s},49301:(e,t,r)=>{"use strict";r.d(t,{m:()=>l});var n=r(96032),s=r(43019),i=r(48009),o=r(71038);const a=i.v.Wantlist.WantType.Block,c=i.v.Wantlist.WantType.Have;class l{constructor(e,t){this.set=t?o({system:"ipfs",component:"bitswap",metric:"wantlist",metrics:t.metrics}):new Map,this._stats=e}get length(){return this.set.size}add(e,t,r){const i=e.toString(s.base58btc),o=this.set.get(i);o?(o.inc(),o.priority=t,o.wantType===c&&r===a&&(o.wantType=r)):(this.set.set(i,new n.D(e,t,r)),this._stats&&this._stats.push(null,"wantListSize",1))}remove(e){const t=e.toString(s.base58btc),r=this.set.get(t);r&&(r.dec(),r.hasRefs()||(this.set.delete(t),this._stats&&this._stats.push(null,"wantListSize",-1)))}removeForce(e){this.set.has(e)&&this.set.delete(e)}forEach(e){return this.set.forEach(e)}entries(){return this.set.entries()}sortedEntries(){return new Map((e=e=>e[1].key,t=Array.from(this.set.entries()),Array.prototype.slice.call(t,0).sort(((t,r)=>{const n=e(t),s=e(r);return n<s?-1:n>s?1:0}))));var e,t}contains(e){const t=e.toString(s.base58btc);return this.set.has(t)}get(e){const t=e.toString(s.base58btc);return this.set.get(t)}}l.Entry=n.D},40389:(e,t,r)=>{"use strict";r.d(t,{n:()=>l});var n=r(15504),s=r(55194),i=r(62469),o=r(60191),a=r(47664),c=r(5724);async function*l(e,t){if("string"===typeof e||e instanceof String||(0,a._t)(e)||(0,a.Lj)(e)||e._readableState)throw n(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"),"ERR_UNEXPECTED_INPUT");if((0,a.Os)(e)&&(e=s(e)),Symbol.iterator in e||Symbol.asyncIterator in e){const r=i(e),{value:s,done:c}=await r.peek();if(c)return void(yield*[]);if(r.push(s),Number.isInteger(s))throw n(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"),"ERR_UNEXPECTED_INPUT");if(s._readableState)return void(yield*o(r,(e=>u({content:e},t))));if((0,a._t)(s))return void(yield u({content:r},t));if((0,a.Mk)(s)||s[Symbol.iterator]||s[Symbol.asyncIterator]||(0,a.Os)(s)||(0,a.Lj)(s))return void(yield*o(r,(e=>u(e,t))))}if((0,a.Mk)(e))throw n(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"),"ERR_UNEXPECTED_INPUT");throw n(new Error("Unexpected input: "+typeof e),"ERR_UNEXPECTED_INPUT")}async function u(e,t){const{path:r,mode:n,mtime:s,content:i}=e,o={path:r||"",mode:(0,c.tK)(n),mtime:(0,c.Xu)(s)};return i?o.content=await t(i):r||(o.content=await t(e)),o}},41048:(e,t,r)=>{"use strict";r.d(t,{a:()=>a});var n=r(98767),s=r(98691),i=r(73620);class o extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"request timed out"),this.name="TimeoutError",this.code=o.code}}function a(e,t){return function(){for(var r=arguments.length,a=new Array(r),c=0;c<r;c++)a[c]=arguments[c];const l=a[null==t?a.length-1:t];if(!l||!l.timeout)return e(...a);const u="string"===typeof l.timeout?(0,i.Z)(l.timeout):l.timeout,d=new n.TimeoutController(u);l.signal=(0,s.anySignal)([l.signal,d.signal]);const h=e(...a),p=new Promise(((e,t)=>{d.signal.addEventListener("abort",(()=>{t(new o)}))})),f=Date.now(),g=()=>{if(d.signal.aborted)throw new o;if(Date.now()-f>u)throw d.abort(),new o};return h[Symbol.asyncIterator]?async function*(){const e=h[Symbol.asyncIterator]();try{for(;;){const{value:t,done:r}=await Promise.race([e.next(),p]);if(r)break;g(),yield t}}catch(t){throw g(),t}finally{d.clear(),e.return&&e.return()}}():(async()=>{try{const e=await Promise.race([h,p]);return g(),e}catch(e){throw g(),e}finally{d.clear()}})()}}o.code="ERR_TIMEOUT"},70962:(e,t,r)=>{"use strict";r.d(t,{Y:()=>i});var n=r(26494);let s;function i(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(s)return s;const t=n({singleProcess:e});return s={readLock:e=>async function(){const r=await t.readLock();try{for(var n=arguments.length,s=new Array(n),i=0;i<n;i++)s[i]=arguments[i];return await e.apply(null,s)}finally{r()}},writeLock:e=>async function(){const r=await t.writeLock();try{for(var n=arguments.length,s=new Array(n),i=0;i<n;i++)s[i]=arguments[i];return await e.apply(null,s)}finally{r()}}},s}},61542:(e,t,r)=>{"use strict";r.d(t,{x:()=>d});var n=r(32743),s=r(5724),i=r(47922),o=r(92829),a=r(60720),c=r(15504),l=r(97085);const u=a("ipfs:mfs:utils:with-mfs-root");async function d(e,t){if(t&&t.signal&&t.signal.aborted)throw c(new Error("Request aborted"),"ERR_ABORTED",{name:"Aborted"});let r;await e.repo.datastore.open();try{const t=await e.repo.datastore.get(l.Nt);r=n.CID.decode(t)}catch(a){if("ERR_NOT_FOUND"!==a.code)throw a;u("Creating new MFS root");const d=i.encode({Data:new s.fL({type:"directory"}).marshal(),Links:[]}),h=await o.sha256.digest(d);if(r=n.CID.createV0(h),await e.repo.blocks.put(r,d),t&&t.signal&&t.signal.aborted)throw c(new Error("Request aborted"),"ERR_ABORTED",{name:"Aborted"});await e.repo.datastore.put(l.Nt,r.bytes)}return u(`Loaded MFS root /ipfs/${r}`),r}},31229:(e,t,r)=>{"use strict";r.d(t,{k0:()=>X.CID,Ue:()=>Ql,bf:()=>eu});var n={};r.r(n),r.d(n,{code:()=>v,decode:()=>k,encode:()=>_,name:()=>b});var s=r(664),i=r(41257),o=r(60720),a=r(15504),c=r(5724),l=r(47922),u=r(60372),d=r(28546),h=r(63225),p=r(64429),f=r(54743);function g(e){const t=h.base64.encode(e).slice(1);return[new p.WU(p.Dy.map,1/0,1),new p.WU(p.Dy.string,"/",1),new p.WU(p.Dy.map,1/0,1),new p.WU(p.Dy.string,"bytes",5),new p.WU(p.Dy.string,t,t.length),new p.WU(p.Dy.break,void 0,1),new p.WU(p.Dy.break,void 0,1)]}const y={typeEncoders:{Object:function(e){if(e.asCID!==e)return null;const t=d.k0.asCID(e);if(!t)return null;const r=t.toString();return[new p.WU(p.Dy.map,1/0,1),new p.WU(p.Dy.string,"/",1),new p.WU(p.Dy.string,r,r.length),new p.WU(p.Dy.break,void 0,1)]},Uint8Array:g,Buffer:g,undefined:function(){throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")},number:function(e){if(Number.isNaN(e))throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");if(e===1/0||e===-1/0)throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");return null}}};class m extends f.d2{constructor(e,t){super(e,t),this.tokenBuffer=[]}done(){return 0===this.tokenBuffer.length&&super.done()}_next(){return this.tokenBuffer.length>0?this.tokenBuffer.pop():super.next()}next(){const e=this._next();if(e.type===p.Dy.map){const e=this._next();if(e.type===p.Dy.string&&"/"===e.value){const e=this._next();if(e.type===p.Dy.string){if(this._next().type!==p.Dy.break)throw new Error("Invalid encoded CID form");return this.tokenBuffer.push(e),new p.WU(p.Dy.tag,42,0)}if(e.type===p.Dy.map){const e=this._next();if(e.type===p.Dy.string&&"bytes"===e.value){const e=this._next();if(e.type===p.Dy.string){for(let e=0;e<2;e++){if(this._next().type!==p.Dy.break)throw new Error("Invalid encoded Bytes form")}const t=h.base64.decode(`m${e.value}`);return new p.WU(p.Dy.bytes,t,e.value.length)}this.tokenBuffer.push(e)}this.tokenBuffer.push(e)}this.tokenBuffer.push(e)}this.tokenBuffer.push(e)}return e}}const w={allowIndefinite:!1,allowUndefined:!1,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,tags:[]};w.tags[42]=d.k0.parse;const b="dag-json",v=297,_=e=>f.cv(e,y),k=e=>{const t=Object.assign(w,{tokenizer:new m(e,w)});return f.Jx(e,t)};var E=r(58735),I=r.t(E,2),S=r(80073),P=r(40963),A=r(38167);class R extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"not initialized"),this.name="NotInitializedError",this.code=R.code}}R.code="ERR_NOT_INITIALIZED";class C extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"cannot initialize an initializing node"),this.name="AlreadyInitializingError",this.code=T.code}}C.code="ERR_ALREADY_INITIALIZING";class T extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"cannot re-initialize an initialized node"),this.name="AlreadyInitializedError",this.code=T.code}}T.code="ERR_ALREADY_INITIALIZED";class D extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"not started"),this.name="NotStartedError",this.code=D.code}}D.code="ERR_NOT_STARTED";class B extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"cannot start, already startin"),this.name="AlreadyStartingError",this.code=B.code}}B.code="ERR_ALREADY_STARTING";class x extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"cannot start, already started"),this.name="AlreadyStartedError",this.code=x.code}}x.code="ERR_ALREADY_STARTED";class N extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"not enabled"),this.name="NotEnabledError",this.code=N.code}}N.code="ERR_NOT_ENABLED";var O=r(68425),L=r(97085);class M{static create(e){let{start:t,stop:r}=e;return new M(t,r)}static async start(e,t){const{state:r,activate:n}=e;switch(r.status){case"stopped":try{const r=n(t);e.state={status:"starting",ready:r};const s=await r;return e.state={status:"started",value:s},s}catch(s){throw e.state={status:"stopped"},s}case"starting":throw new B;case"started":throw new x;case"stopping":return await r.ready,await M.start(e,t);default:return M.panic(e)}}static async stop(e){const{state:t,deactivate:r}=e;switch(t.status){case"stopped":break;case"starting":try{await t.ready}catch(n){}return await M.stop(e);case"stopping":return await t.ready;case"started":r&&await r(t.value),e.state={status:"stopped"};break;default:M.panic(t)}}static try(e){let{state:t}=e;return"started"===t.status?t.value:null}static async use(e,t){let{state:r}=e;switch(r.status){case"started":return r.value;case"starting":return await(0,L.Fb)(r.ready,t);default:throw new D}}static panic(e){let{state:t}=e;const r=JSON.stringify({status:t.status});throw RangeError(`Service in invalid state ${r}, should never happen if you see this please report a bug`)}constructor(e,t){this.activate=e,this.deactivate=t,this.state={status:"stopped"}}async use(e){return await M.use(this,e)}try(){return M.try(this)}}var j=r(42623),U=r(60185),z=r(68170);const W=new j.E(1e3),$=new(U.default?U.default:U)({concurrency:4}),F=e=>{if(e.Path)return e.Path;throw new Error(e.Message)};async function K(e,t){return async function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const r=new URLSearchParams(t);r.set("arg",e);const n=r.toString();if(!t.nocache&&W.has(n)){const e=W.get(n);return F(e)}const s=await $.add((async()=>{const e=await z.get("https://ipfs.io/api/v0/dns",{searchParams:r}),t=new URL(e.url).search.slice(1),n=await e.json();return W.set(t,n,6e4),n}));return F(s)}(e,t)}var q=r(41048);function H(e){return e.endsWith(".eth")&&(e=e.replace(/.eth$/,".eth.link")),e}var G=r(7022),V=r(13380),X=r(32743),J=r(91401);function Z(e){try{return J.parse(e).toBytes()}catch{return X.CID.parse(e).bytes}}var Y=r(16586);async function*Q(e){if(null===e||void 0===e)throw a(new Error(`Unexpected input: ${e}`),"ERR_UNEXPECTED_INPUT");const t=X.CID.asCID(e);if(t)yield ee({cid:t});else{if(!(e instanceof String||"string"===typeof e)){if(null!=e.cid||null!=e.path)return yield ee(e);if(Symbol.iterator in e){const t=e[Symbol.iterator](),r=t.next();if(r.done)return t;if(X.CID.asCID(r.value)||r.value instanceof String||"string"===typeof r.value){yield ee({cid:r.value});for(const e of t)yield ee({cid:e});return}if(null!=r.value.cid||null!=r.value.path){yield ee(r.value);for(const e of t)yield ee(e);return}throw a(new Error("Unexpected input: "+typeof e),"ERR_UNEXPECTED_INPUT")}if(Symbol.asyncIterator in e){const t=e[Symbol.asyncIterator](),r=await t.next();if(r.done)return t;if(X.CID.asCID(r.value)||r.value instanceof String||"string"===typeof r.value){yield ee({cid:r.value});for await(const e of t)yield ee({cid:e});return}if(null!=r.value.cid||null!=r.value.path){yield ee(r.value);for await(const e of t)yield ee(e);return}throw a(new Error("Unexpected input: "+typeof e),"ERR_UNEXPECTED_INPUT")}throw a(new Error("Unexpected input: "+typeof e),"ERR_UNEXPECTED_INPUT")}yield ee({path:e})}}function ee(e){const t=e.cid||`${e.path}`;if(!t)throw a(new Error("Unexpected input: Please path either a CID or an IPFS path"),"ERR_UNEXPECTED_INPUT");const r={path:t,recursive:!1!==e.recursive};return null!=e.metadata&&(r.metadata=e.metadata),r}const te={direct:"direct",recursive:"recursive",indirect:"indirect",all:"all"};function re(e,t,r){const n={type:e,cid:t};return r&&(n.metadata=r),n}class ne{constructor(e){let{codecs:t,repo:r}=e;const n=function(e){let{repo:t,codecs:r}=e;return(0,q.a)((async function*(e){const n=async function*(){for await(const{path:n,recursive:s,metadata:i}of Q(e)){const{cid:e}=await(0,L.i3)(t,r,n),{reason:o}=await t.pins.isPinnedWithType(e,[te.recursive,te.direct]);if("recursive"===o&&!s)throw new Error(`${e} already pinned recursively`);s?await t.pins.pinRecursively(e,{metadata:i}):await t.pins.pinDirectly(e,{metadata:i}),yield e}};if(!Boolean((arguments.length>1&&void 0!==arguments[1]?arguments[1]:{}).lock))return void(yield*n());const s=await t.gcLock.readLock();try{yield*n()}finally{s()}}))}({codecs:t,repo:r});this.addAll=n,this.add=function(e){let{addAll:t}=e;return function(e){let r,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const s=X.CID.asCID(e);return r=t(s?[{cid:s,...n}]:[{path:e.toString(),...n}],n),Y(r)}}({addAll:n});const s=function(e){let{repo:t,codecs:r}=e;return(0,q.a)((async function*(e){const n=await t.gcLock.readLock();try{for await(const{path:n,recursive:s}of Q(e)){const{cid:e}=await(0,L.i3)(t,r,n),{pinned:i,reason:o}=await t.pins.isPinnedWithType(e,te.all);if(!i)throw new Error(`${e} is not pinned`);switch(o){case te.recursive:if(!s)throw new Error(`${e} is pinned recursively`);await t.pins.unpin(e),yield e;break;case te.direct:await t.pins.unpin(e),yield e;break;default:throw new Error(`${e} is pinned indirectly under ${o}`)}}}finally{n()}}))}({codecs:t,repo:r});this.rmAll=s,this.rm=function(e){let{rmAll:t}=e;return async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await Y(t([{path:e,...r}],r));if(!n)throw new Error("CID expected");return n}}({rmAll:s}),this.ls=function(e){let{repo:t,codecs:r}=e;return(0,q.a)((async function*(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=te.all;if(e.type&&(n=e.type,!Object.keys(te).includes(n)))throw a(new Error("Invalid pin type"),"ERR_INVALID_PIN_TYPE");if(e.paths){let s=!1;for await(const{path:i}of Q(e.paths)){const{cid:e}=await(0,L.i3)(t,r,i),{reason:o,pinned:c,parent:l,metadata:u}=await t.pins.isPinnedWithType(e,n);if(!c)throw a(new Error(`path '${i}' is not pinned`),"ERR_NOT_PINNED");switch(o){case te.direct:case te.recursive:s=!0,yield re(o,e,u);break;default:s=!0,yield re(`${te.indirect} through ${l}`,e,u)}}if(!s)throw new Error("No match found")}else{if(n===te.recursive||n===te.all)for await(const{cid:e,metadata:r}of t.pins.recursiveKeys())yield re(te.recursive,e,r);if(n===te.indirect||n===te.all)for await(const r of t.pins.indirectKeys(e))yield re(te.indirect,r);if(n===te.direct||n===te.all)for await(const{cid:e,metadata:r}of t.pins.directKeys())yield re(te.direct,e,r)}}))}({codecs:t,repo:r}),this.remote={add:function(e){return Promise.reject(new Error("Not implemented"))},ls:async function*(e){return Promise.reject(new Error("Not implemented"))},rm:function(e){return Promise.reject(new Error("Not implemented"))},rmAll:function(e){return Promise.reject(new Error("Not implemented"))},service:{add:(e,t)=>Promise.reject(new Error("Not implemented")),rm:function(e){return Promise.reject(new Error("Not implemented"))},ls:function(){return Promise.reject(new Error("Not implemented"))}}}}}var se=r(82149),ie=r(66957),oe=r(93314),ae=r(10764),ce=r(51199),le=r(70380),ue=r(17578),de=r(79357),he=r(52769),pe=r(61163),fe=r(19061),ge=r(90309),ye=r(86034);const me=Object.assign(o("jsipns"),{error:o("jsipns:error")}),we=S.identity.code,be=(0,O.fromString)("/ipns/"),ve="/ipns/",_e=ve.length,ke=async(e,t,r,n,s,i)=>{r=BigInt(r);const o=(0,O.fromString)(s.toString()),a=await Te(e,t,n,o),c=Ee(t,o,n,r,i),l=Be(c),u={value:t,signature:a,validityType:n,validity:o,sequence:r,ttl:i,signatureV2:await e.sign(l),data:c};return me(`ipns entry for ${t} created`),u},Ee=(e,t,r,n,s)=>{const i={Value:e,Validity:t,ValidityType:r,Sequence:n,TTL:s};return p.cv(i)},Ie=async(e,t)=>{const{value:r,validityType:n,validity:s}=t;let i,o,c;t.signatureV2&&t.data?(o=t.signatureV2,i=Be(t.data),Se(t)):(o=t.signature,i=De(r,n,s));try{c=await e.verify(i,o)}catch(l){c=!1}if(!c)throw me.error("record signature verification failed"),a(new Error("record signature verification failed"),ye.SY);if(n===fe.X.ValidityType.EOL){let e;try{e=(0,ge.r)((0,oe.toString)(s))}catch(u){throw me.error("unrecognized validity format (not an rfc3339 format)"),a(new Error("unrecognized validity format (not an rfc3339 format)"),ye.vH)}if(e.getTime()<Date.now())throw me.error("record has expired"),a(new Error("record has expired"),ye.L0)}else if(n)throw me.error("unrecognized validity type"),a(new Error("unrecognized validity type"),ye.Fl);me(`ipns entry for ${r} is valid`)},Se=e=>{if(!e.data)throw a(new Error("Record data is missing"),ye.BL);const t=p.Jx(e.data);if(Number.isInteger(t.Sequence)&&(t.Sequence=BigInt(t.Sequence)),Number.isInteger(t.TTL)&&(t.TTL=BigInt(t.TTL)),!(0,ae.equals)(t.Value,e.value))throw a(new Error('Field "value" did not match between protobuf and CBOR'),ye.SY);if(!(0,ae.equals)(t.Validity,e.validity))throw a(new Error('Field "validity" did not match between protobuf and CBOR'),ye.SY);if(t.ValidityType!==e.validityType)throw a(new Error('Field "validityType" did not match between protobuf and CBOR'),ye.SY);if(t.Sequence!==e.sequence)throw a(new Error('Field "sequence" did not match between protobuf and CBOR'),ye.SY);if(t.TTL!==e.ttl)throw a(new Error('Field "ttl" did not match between protobuf and CBOR'),ye.SY)},Pe=async(e,t)=>{if(!t||!e){const e=new Error("one or more of the provided parameters are not defined");throw me.error(e),a(e,ye.eb)}let r;if(t.pubKey){try{r=le.keys.unmarshalPublicKey(t.pubKey)}catch(n){throw me.error(n),n}if(!(await J.createFromPubKey(t.pubKey)).equals(e))throw a(new Error("Embedded public key did not match PeerID"),ye.TO)}else e.pubKey&&(r=e.pubKey);if(r)return r;throw a(new Error("no public key is available"),ye.eb)},Ae=e=>de.base32upper.encode(e).slice(1),Re=e=>new se.Key(`/ipns/${Ae(e)}`),Ce=e=>{const t=(0,O.fromString)("/pk/"),r=(0,O.fromString)("/ipns/");return{routingPubKey:new se.Key((0,he.concat)([t,e]),!1),pkKey:new se.Key(Ae((0,he.concat)([t,e]))),routingKey:new se.Key((0,he.concat)([r,e]),!1),ipnsKey:new se.Key(Ae((0,he.concat)([r,e])))}},Te=(e,t,r,n)=>{try{const s=De(t,r,n);return e.sign(s)}catch(s){throw me.error("record signature creation failed"),a(new Error("record signature creation failed: "+s.message),ye.FB)}},De=(e,t,r)=>{const n=(0,O.fromString)((e=>{if("0"===e.toString())return"EOL";const t=new Error(`unrecognized validity type ${e.toString()}`);throw me.error(t),a(t,ye.Fl)})(t));return(0,he.concat)([e,r,n])},Be=e=>{const t=(0,O.fromString)("ipns-signature:");return(0,he.concat)([t,e])},xe=e=>{const t=ue.decode(e.id);return t.code!==we?null:le.keys.unmarshalPublicKey(t.digest)},Ne=e=>fe.X.encode({...e,sequence:pe.fromString(e.sequence.toString()),ttl:null==e.ttl?void 0:pe.fromString(e.ttl.toString())}).finish(),Oe=e=>{const t=fe.X.decode(e),r=fe.X.toObject(t,{defaults:!1,arrays:!0,objects:!1});return{value:r.value,signature:r.signature,validityType:r.validityType,validity:r.validity,sequence:Object.hasOwnProperty.call(r,"sequence")?BigInt(`${r.sequence}`):0,pubKey:r.pubKey,ttl:Object.hasOwnProperty.call(r,"ttl")?BigInt(`${r.ttl}`):void 0,signatureV2:r.signatureV2,data:r.data}},Le={validate:async(e,t)=>{const r=Oe(e),n=t.slice(be.length),s=J.createFromBytes(n),i=await Pe(s,r);await Ie(i,r)},select:(e,t)=>{const r=Oe(e),n=Oe(t);if(r.signatureV2&&!n.signatureV2)return 0;if(n.signatureV2&&!r.signatureV2)return 1;if(r.sequence>n.sequence)return 0;if(r.sequence<n.sequence)return 1;const s=(0,ge.r)((0,oe.toString)(r.validity));return(0,ge.r)((0,oe.toString)(n.validity)).getTime()>s.getTime()?1:0}},Me=Object.assign(o("ipfs:ipns:publisher"),{error:o("ipfs:ipns:publisher:error")}),je=(0,ie.notFoundError)().code,Ue=36e5;class ze{constructor(e,t){this._routing=e,this._datastore=t}async publishWithEOL(e,t,r){if(!e||!e.bytes)throw a(new Error("invalid private key"),"ERR_INVALID_PRIVATE_KEY");const n=await J.createFromPrivKey(e.bytes),s=await this._updateOrCreateRecord(e,t,r,n);return this._putRecordToRouting(s,n)}publish(e,t){return this.publishWithEOL(e,t,Ue)}async _putRecordToRouting(e,t){if(!J.isPeerId(t)){const e="peerId received is not valid";throw Me.error(e),a(new Error(e),"ERR_INVALID_PEER_ID")}const r=t.pubKey,n=await(async(e,t)=>{if(!e||!e.bytes||!t){const e=new Error("one or more of the provided parameters are not defined");throw me.error(e),a(e,ye.eb)}let r,n;try{r=await J.createFromPubKey(e.bytes)}catch(s){throw a(s,ye.Qk)}try{n=xe(r)}catch(s){throw me.error(s),a(s,ye.kH)}if(n)return null;try{t.pubKey=le.keys.marshalPublicKey(e)}catch(s){throw me.error(s),s}return t})(r,e),s=Ce(t.toBytes());return await this._publishEntry(s.routingKey,n||e),n||e}async _publishEntry(e,t){const r=se.Key.asKey(e);if(!r){const e="datastore key does not have a valid format";throw Me.error(e),a(new Error(e),"ERR_INVALID_DATASTORE_KEY")}let n;try{n=Ne(t)}catch(s){throw Me.error(s),s}try{const e=await this._routing.put(r.uint8Array(),n);return Me(`ipns record for ${(0,oe.toString)(r.uint8Array(),"base32")} was stored in the routing`),e}catch(s){const e=`ipns record for ${(0,oe.toString)(r.uint8Array(),"base32")} could not be stored in the routing - ${s.stack}`;throw Me.error(e),Me.error(s),a(new Error(e),"ERR_PUTTING_TO_ROUTING")}}async _getPublished(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!J.isPeerId(e)){const e="peerId received is not valid";throw Me.error(e),a(new Error(e),"ERR_INVALID_PEER_ID")}const r=!1!==t.checkRouting;try{const t=await this._datastore.get(Re(e.id));return this._unmarshalData(t)}catch(n){if(n.code!==je){const t=`unexpected error getting the ipns record ${e.id} from datastore`;throw Me.error(t),a(new Error(t),"ERR_UNEXPECTED_DATASTORE_RESPONSE")}if(!r)throw a(n,"ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED");try{const t=Ce(e.toBytes()),r=await this._routing.get(t.routingKey.uint8Array());return this._unmarshalData(r)}catch(n){throw Me.error(n),n}}}_unmarshalData(e){try{return Oe(e)}catch(t){throw a(t,"ERR_INVALID_RECORD_DATA")}}async _updateOrCreateRecord(e,t,r,n){if(!J.isPeerId(n)){const e="peerId received is not valid";throw Me.error(e),a(new Error(e),"ERR_INVALID_PEER_ID")}const s={checkRouting:!0};let i;try{i=await this._getPublished(n,s)}catch(l){if(l.code!==je){const e=`unexpected error when determining the last published IPNS record for ${n.id} ${l.stack}`;throw Me.error(e),a(new Error(e),"ERR_DETERMINING_PUBLISHED_RECORD")}}let o,c=0;i&&void 0!==i.sequence&&(c=(0,ae.equals)(i.value,t)?BigInt(i.sequence):BigInt(i.sequence)+BigInt(1));try{o=await((e,t,r,n)=>{const s=new ce(Date.now()+Number(n)),i=fe.X.ValidityType.EOL,[o,a]=n.toString().split("."),c=BigInt(o)*BigInt(1e5)+BigInt(a||0);return ke(e,t,r,i,s,c)})(e,t,c,r)}catch(l){const e=`ipns record for ${t} could not be created`;throw Me.error(l),a(new Error(e),"ERR_CREATING_IPNS_RECORD")}try{const e=Ne(o);return await this._datastore.put(Re(n.id),e),Me(`ipns record for ${(0,oe.toString)(t,"base32")} was stored in the datastore`),o}catch(l){const e=`ipns record for ${t} could not be stored in the datastore`;throw Me.error(e),a(new Error(e),"ERR_STORING_IN_DATASTORE")}}}ze.defaultRecordLifetime=Ue;const We=Object.assign(o("ipfs:ipns:republisher"),{error:o("ipfs:ipns:republisher:error")});class $e{constructor(e,t,r,n){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{pass:""};this._publisher=e,this._datastore=t,this._peerId=r,this._keychain=n,this._options=s,this._republishHandle=null}async start(){if(this._republishHandle)throw a(new Error("republisher is already running"),"ERR_REPUBLISH_ALREADY_RUNNING");const e={_task:null,_inflightTask:null,_timeoutId:null,runPeriodically:t=>{e._timeoutId=setTimeout((async()=>{e._timeoutId=null;try{e._inflightTask=e._task(),await e._inflightTask,e._task&&e.runPeriodically(t)}catch(r){We.error(r)}}),t())},cancel:async()=>{null!=e._timeoutId&&clearTimeout(e._timeoutId),e._task=null,await e._inflightTask}},{privKey:t}=this._peerId,{pass:r}=this._options;let n=!0;e._task=()=>this._republishEntries(t,r),e.runPeriodically((()=>n?(n=!1,this._options.initialBroadcastInterval||6e4):this._options.broadcastInterval||144e5)),this._republishHandle=e}async stop(){const e=this._republishHandle;if(!e)throw a(new Error("republisher is not running"),"ERR_REPUBLISH_NOT_RUNNING");this._republishHandle=null,await e.cancel()}async _republishEntries(e,t){try{await this._republishEntry(e)}catch(r){const e="cannot republish entry for the node's private key";return void We.error(e)}if(t)try{const e=await this._keychain.listKeys();for(const r of e){if("self"===r.name)continue;const e=await this._keychain.exportKey(r.name,t),n=await le.keys.import(e,t);await this._republishEntry(n)}}catch(r){We.error(r)}}async _republishEntry(e){if(!e||!e.bytes)throw a(new Error("invalid private key"),"ERR_INVALID_PRIVATE_KEY");try{const t=await J.createFromPrivKey(e.bytes),r=await this._getPreviousValue(t);await this._publisher.publishWithEOL(e,r,864e5)}catch(t){if("ERR_NO_ENTRY_FOUND"===t.code)return;throw t}}async _getPreviousValue(e){if(!J.isPeerId(e))throw a(new Error("invalid peer ID"),"ERR_INVALID_PEER_ID");try{const r=await this._datastore.get(Re(e.id));if(!(r instanceof Uint8Array))throw a(new Error("found ipns record that we couldn't process"),"ERR_INVALID_IPNS_RECORD");try{return Oe(r).value}catch(t){throw We.error(t),a(new Error("found ipns record that we couldn't convert to a value"),"ERR_INVALID_IPNS_RECORD")}}catch(t){if(t&&t.notFound)throw a(new Error(`no previous entry for record with id: ${e.id}`),"ERR_NO_ENTRY_FOUND");throw t}}}const Fe=Object.assign(o("ipfs:ipns:resolver"),{error:o("ipfs:ipns:resolver:error")}),Ke=ie.notFoundError().code;class qe{constructor(e){this._routing=e}async resolve(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("string"!==typeof e)throw a(new Error("invalid name"),"ERR_INVALID_NAME");const r=t.recursive&&"true"===t.recursive.toString(),n=e.split("/");if(3!==n.length||""!==n[0])throw a(new Error("invalid name"),"ERR_INVALID_NAME");const s=n[2];let i=1/0;r&&(i=32);const o=await this.resolver(s,i);return Fe(`${e} was locally resolved correctly`),o}async resolver(e,t){if(0===t){const e="could not resolve name (recursion limit of 32 exceeded)";throw Fe.error(e),a(new Error(e),"ERR_RESOLVE_RECURSION_LIMIT")}const r=await this._resolveName(e),n=r.split("/");return"ipfs"!==n[1]&&t?this.resolver(n[2],t-1):r}async _resolveName(e){const t=J.parse(e),{routingKey:r}=Ce(t.toBytes());let n,s;try{n=await this._routing.get(r.uint8Array())}catch(i){if(Fe.error("could not get record from routing",i),i.code===Ke)throw a(new Error(`record requested for ${e} was not found in the network`),"ERR_NO_RECORD_FOUND");throw a(new Error(`unexpected error getting the ipns record ${t.toString()}`),"ERR_UNEXPECTED_ERROR_GETTING_RECORD")}try{s=Oe(n)}catch(i){throw Fe.error("could not unmarshal record",i),a(new Error("found ipns record that we couldn't convert to a value"),"ERR_INVALID_RECORD_RECEIVED")}return this._validateRecord(t,s)}async _validateRecord(e,t){const r=await Pe(e,t);return await Ie(r,t),(0,oe.toString)(t.value)}}var He=r(87167);class Ge{constructor(e){this.lru=He(e)}get(e){const t=this.lru.get(e);if(t)return t.expire&&t.expire<Date.now()?void this.lru.remove(e):t.value}set(e,t,r){this.lru.set(e,{value:t,expire:Date.now()+r})}has(e){return!!this.get(e)}remove(e){this.lru.remove(e)}clear(){this.lru.clear()}}const Ve=Object.assign(o("ipfs:ipns"),{error:o("ipfs:ipns:error")});class Xe{constructor(e,t,r,n,s){this.publisher=new ze(e,t),this.republisher=new $e(this.publisher,t,r,n,s),this.resolver=new qe(e),this.cache=new Ge(1e3),this.routing=e}async publish(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:ze.defaultRecordLifetime;try{const n=await(0,J.createFromPrivKey)(e.bytes);await this.publisher.publishWithEOL(e,t,r),Ve(`IPNS value ${(0,oe.toString)(t,"base32")} was published correctly`);const s=n.toB58String(),i=parseFloat(r),o=i<6e4?i:6e4;return this.cache.set(s,t,o),Ve(`IPNS value ${(0,oe.toString)(t,"base32")} was cached correctly`),{name:s,value:t}}catch(n){throw Ve.error(n),n}}async resolve(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("string"!==typeof e)throw a(new Error("name received is not valid"),"ERR_INVALID_NAME");if(!t.nocache&&!t.recursive){const t=e.split("/")[2],r=this.cache.get(t);if(r)return r}try{const r=await this.resolver.resolve(e,t);return Ve(`IPNS record from ${e} was resolved correctly`),r}catch(r){throw Ve.error(r),r}}async initializeKeyspace(e,t){return this.publish(e,t,ze.defaultRecordLifetime)}}var Je=r(97823),Ze=r(21613),Ye=r(43019),Qe=r(22984),et=r(62287);const tt="/record/";function rt(e){return(0,oe.toString)(e,"base32")}function nt(e){("string"===typeof e||e instanceof String)&&(e=(0,O.fromString)(e.toString()));return`/record/${(0,oe.toString)(e,"base64url")}`}const st=Object.assign(o("datastore-pubsub:publisher"),{error:o("datastore-pubsub:publisher:error")});class it extends et.BaseDatastore{constructor(e,t,r,n,s){if(super(),!n)throw a(new TypeError("missing validator"),"ERR_INVALID_PARAMETERS");if("function"!==typeof n.validate)throw a(new TypeError("missing validate function"),"ERR_INVALID_PARAMETERS");if("function"!==typeof n.select)throw a(new TypeError("missing select function"),"ERR_INVALID_PARAMETERS");if(s&&"function"!==typeof s)throw a(new TypeError("invalid subscriptionKeyFn received"),"ERR_INVALID_PARAMETERS");this._pubsub=e,this._datastore=t,this._peerId=r,this._validator=n,this._handleSubscriptionKeyFn=s,this._onMessage=this._onMessage.bind(this)}async put(e,t){if(!(e instanceof Uint8Array)){const e="datastore key does not have a valid format";throw st.error(e),a(new Error(e),"ERR_INVALID_DATASTORE_KEY")}if(!(t instanceof Uint8Array)){const e="received value is not a Uint8Array";throw st.error(e),a(new Error(e),"ERR_INVALID_VALUE_RECEIVED")}const r=nt(e);st(`publish value for topic ${r}`),await this._pubsub.publish(r,t)}async get(e){if(!(e instanceof Uint8Array)){const e="datastore key does not have a valid format";throw st.error(e),a(new Error(e),"ERR_INVALID_DATASTORE_KEY")}const t=nt(e),r=await this._pubsub.getTopics();if(r&&Array.isArray(r)&&r.indexOf(t)>-1)return this._getLocal(e);try{this._pubsub.on(t,this._onMessage),await this._pubsub.subscribe(t)}catch(n){const e=`cannot subscribe topic ${t}`;throw st.error(e),a(new Error(e),"ERR_SUBSCRIBING_TOPIC")}return st(`subscribed values for key ${t}`),this._getLocal(e)}unsubscribe(e){const t=nt(e);return this._pubsub.removeListener(t,this._onMessage),this._pubsub.unsubscribe(t)}async _getLocal(e){const t=new Qe.s("/"+rt(e),!1);let r;try{r=await this._datastore.get(t)}catch(n){if("ERR_NOT_FOUND"!==n.code){const e=`unexpected error getting the ipns record for ${t.toString()}`;throw st.error(e),a(new Error(e),"ERR_UNEXPECTED_ERROR_GETTING_RECORD")}const e=`local record requested was not found for ${t.toString()}`;throw st.error(e),a(new Error(e),"ERR_NOT_FOUND")}if(!(r instanceof Uint8Array)){const e="found record that we couldn't convert to a value";throw st.error(e),a(new Error(e),"ERR_INVALID_RECORD_RECEIVED")}return r}async _onMessage(e){const{data:t,from:r,topicIDs:n}=e;let s;try{s=function(e){if(e.substring(0,tt.length)!==tt)throw a(new Error("topic received is not from a record"),"ERR_TOPIC_IS_NOT_FROM_RECORD_NAMESPACE");const t=e.substring(tt.length);return(0,O.fromString)(t,"base64url")}(n[0])}catch(i){return void st.error(i)}if(st(`message received for topic ${n[0]}`),r!==this._peerId.toB58String()){if(this._handleSubscriptionKeyFn){let e;try{e=await this._handleSubscriptionKeyFn(s)}catch(i){return void st.error("message discarded by the subscriptionKeyFn")}s=e}try{await this._storeIfSubscriptionIsBetter(s,t)}catch(i){st.error(i)}}else st("message discarded as it is from the same peer")}async _storeIfSubscriptionIsBetter(e,t){let r=!1;try{r=await this._isBetter(e,t)}catch(n){if("ERR_NOT_VALID_RECORD"!==n.code)throw n}r&&await this._storeRecord(e,t)}async _validateRecord(e,t){return this._validator.validate(e,t)}async _selectRecord(e,t){return 0===await this._validator.select(e,t)}async _isBetter(e,t){try{await this._validateRecord(t,e)}catch(s){const e="record received through pubsub is not valid";throw st.error(e),a(new Error(e),"ERR_NOT_VALID_RECORD")}const r=new Qe.s(e);let n;try{n=await this._getLocal(r.uint8Array())}catch(s){return!0}return!(0,ae.equals)(n,t)&&this._selectRecord(e,[n,t])}async _storeRecord(e,t){const r=new Qe.s("/"+rt(e),!1);await this._datastore.put(r,t),st(`record for ${nt(e)} was stored in the datastore`)}}const ot=Object.assign(o("ipfs:ipns:pubsub"),{error:o("ipfs:ipns:pubsub:error")});class at{constructor(e,t,r){this._subscriptions={},this._handleSubscriptionKey=this._handleSubscriptionKey.bind(this),this._pubsubDs=new it(e,t,r,Le,this._handleSubscriptionKey)}async put(e,t){try{await this._pubsubDs.put(e,t)}catch(r){throw ot.error(r),r}}async get(e){let t,r;try{t=await this._pubsubDs.get(e)}catch(s){r=s}const n=e.slice(0,_e);if((0,oe.toString)(n)===ve){const t=Ye.base58btc.encode(e).substring(1),r=Ye.base58btc.encode(e.slice(_e)).substring(1);this._subscriptions[t]=r,ot(`subscribed to pubsub topic ${t}, id ${r}`)}if(r)throw r;return t}_handleSubscriptionKey(e){e instanceof Uint8Array&&(e=(0,oe.toString)(e,"base58btc"));const t=this._subscriptions[e];if(!t)throw a(new Error(`key ${e} does not correspond to a subscription`),"ERR_INVALID_KEY");let r;try{r=Ce((0,O.fromString)(t,"base58btc"))}catch(n){throw ot.error(n),n}return r.routingKey.uint8Array()}getSubscriptions(){return Object.values(this._subscriptions).filter(Boolean).map((e=>`/ipns/${e}`))}async cancel(e){if("string"!==typeof e)throw a(new Error("invalid subscription name"),"ERR_INVALID_SUBSCRIPTION_NAME");e.startsWith(ve)&&(e=e.substring(_e));const t=Object.keys(this._subscriptions).find((t=>this._subscriptions[t]===e));if(!t)return{canceled:!1};const r=(0,O.fromString)(t);return this._pubsubDs.unsubscribe(r),delete this._subscriptions[t],ot(`unsubscribed pubsub ${t}: ${e}`),{canceled:!0}}}var ct=r(16758);const lt=Object.assign(o("ipfs:ipns:offline-datastore"),{error:o("ipfs:ipns:offline-datastore:error")});class ut{constructor(e){this._repo=e,this.stores=[]}async put(e,t){if(!(e instanceof Uint8Array))throw a(new Error("Offline datastore key must be a Uint8Array"),"ERR_INVALID_KEY");if(!(t instanceof Uint8Array))throw a(new Error("Offline datastore value must be a Uint8Array"),"ERR_INVALID_VALUE");let r;try{r=this._routingKey(e)}catch(s){throw lt.error(s),a(new Error("Not possible to generate the routing key"),"ERR_GENERATING_ROUTING_KEY")}const n=new ct.Record(e,t);return this._repo.datastore.put(r,n.serialize())}async get(e){if(!(e instanceof Uint8Array))throw a(new Error("Offline datastore key must be a Uint8Array"),"ERR_INVALID_KEY");let t;try{t=this._routingKey(e)}catch(s){throw lt.error(s),a(new Error("Not possible to generate the routing key"),"ERR_GENERATING_ROUTING_KEY")}const r=await this._repo.datastore.get(t);let n;try{n=ct.Record.deserialize(r)}catch(s){throw lt.error(s),s}return n.value}_routingKey(e){return new se.Key("/dht/record/"+(0,oe.toString)(e,"base32"),!1)}}var dt=r(20838);const ht=Object.assign(o("ipfs:ipns:dht-datastore"),{error:o("ipfs:ipns:dht-datastore:error")});class pt{constructor(e){this._dht=e}async put(e,t){try{await dt(this._dht.put(e,t))}catch(r){throw ht.error(r),r}}async get(e){for await(const t of this._dht.get(e))if("VALUE"===t.name)return t.value;throw(0,ie.notFoundError)()}}const ft=o("ipfs:components:ipns");class gt{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{pass:""};this.options=e,this.offline=null,this.online=null}getIPNS(){const e=this.online||this.offline;if(e)return e;throw new R}get routing(){return this.getIPNS().routing}startOffline(e){let{repo:t,peerId:r,keychain:n}=e;if(null!=this.offline)throw new T;ft("initializing IPNS keyspace");const s=new ut(t),i=new Xe(s,t.datastore,r,n,this.options);this.offline=i}async startOnline(e){let{libp2p:t,repo:r,peerId:n,keychain:s}=e;if(null!=this.online)throw new T;const i=function(e){let{libp2p:t,repo:r,peerId:n,options:s}=e;const i=[];let o;if(Ze(s,"EXPERIMENTAL.ipnsPubsub",!1)){const e=t.pubsub,s=r.datastore;o=new at(e,s,n),i.push(o)}if(!Ze(s,"offline",!1)&&t._config&&t._config.dht&&t._config.dht.enabled&&i.push(new pt(t._dht)),Ze(s,"offline",!1)||0===i.length){const e=new ut(r);i.push(e)}return new Je.z(i)}({libp2p:t,repo:r,peerId:n,options:this.options}),o=new Xe(i,r.datastore,n,s,this.options);await o.republisher.start(),this.online=o}async stop(){const e=this.online;e&&(await e.republisher.stop(),this.online=null)}publish(e,t,r){return this.getIPNS().publish(e,t,r)}resolve(e,t){return this.getIPNS().resolve(e,t)}initializeKeyspace(e,t){return this.getIPNS().initializeKeyspace(e,t)}}var yt=r(73620),mt=r(7901);async function wt(e,t,r){let{ipns:n,repo:s,codecs:i}=e;if(V.ipnsPath(t))return n.resolve(t);const{cid:o,path:a}=(0,mt.B)(t);await dt((0,L.DB)(o,a||"",i,s,r))}const bt=Object.assign(o("ipfs:name:publish"),{error:o("ipfs:name:publish:error")});var vt=r(71659),_t=r(47937);const kt=s.Z.bind({ignoreUndefined:!0}),Et=Object.assign(o("ipfs:name:resolve"),{error:o("ipfs:name:resolve:error")}),It=(e,t)=>t.length>0?e+"/"+t.join("/"):e;function St(e,t){if(!e||!t||!t.ipnsPubsub)throw a(new Error("IPNS pubsub subsystem is not enabled"),"ERR_IPNS_PUBSUB_NOT_ENABLED");if(e.routing instanceof at)return e.routing;const r=(e.routing.stores||[]).find((e=>e instanceof at));if(!r)throw a(new Error("IPNS pubsub datastore not found"),"ERR_PUBSUB_DATASTORE_NOT_FOUND");return r}class Pt{constructor(e){let{ipns:t,options:r}=e;this.cancel=function(e){let{ipns:t,options:r}=e;const n=r.EXPERIMENTAL;return(0,q.a)((async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return St(t,n).cancel(e,r)}))}({ipns:t,options:r}),this.state=function(e){let{ipns:t,options:r}=e;const n=r.EXPERIMENTAL;return(0,q.a)((async function(){try{return{enabled:Boolean(St(t,n))}}catch(e){return{enabled:!1}}}))}({ipns:t,options:r}),this.subs=function(e){let{ipns:t,options:r}=e;const n=r.EXPERIMENTAL;return(0,q.a)((async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return St(t,n).getSubscriptions(e)}))}({ipns:t,options:r})}}class At{constructor(e){let{dns:t,ipns:r,repo:n,codecs:s,peerId:i,isOnline:o,keychain:c,options:l}=e;this.publish=function(e){let{ipns:t,repo:r,codecs:n,peerId:s,isOnline:i,keychain:o}=e;const c=async e=>{if("self"===e)return s.privKey;try{const t=await o.exportKey(e,"temp");return await le.keys.import(t,"temp")}catch(t){throw bt.error(t),a(t,"ERR_CANNOT_GET_KEY")}};return(0,q.a)((async function(e){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const o=!(!1===s.resolve),l=s.lifetime||"24h",u=s.key||"self";if(!i())throw a(new Error(L.yH),"OFFLINE_ERROR");try{e=(0,L.AH)(e)}catch(g){throw bt.error(g),g}let d=0;try{d=(0,yt.Z)(l)||0,d=parseFloat(d.toFixed(6))}catch(g){throw bt.error(g),g}const h=await Promise.all([c(u),o?wt({ipns:t,repo:r,codecs:n},e):Promise.resolve()]),p=(0,O.fromString)(e),f=await t.publish(h[0],p,d);return{name:f.name,value:(0,oe.toString)(f.value)}}))}({ipns:r,repo:n,codecs:s,peerId:i,isOnline:o,keychain:c}),this.resolve=function(e){let{dns:t,ipns:r,peerId:n,isOnline:s,options:{offline:i}}=e;return(0,q.a)((async function*(e){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(o=kt({nocache:!1,recursive:!0},o),i&&o&&o.nocache)throw a(new Error("cannot specify both offline and nocache"),"ERR_NOCACHE_AND_OFFLINE");if(!s()&&!i)throw a(new Error(L.yH),"OFFLINE_ERROR");e||(e=n.toB58String()),e.startsWith("/ipns/")||(e=`/ipns/${e}`);let[c,l,...u]=e.slice(1).split("/");try{if("1"===l.substring(0,1)){const e=J.parse(l),t=ue.decode(e.toBytes());l=X.CID.createV1(114,t).toString(vt.base36)}else{const e=X.CID.parse(l);1===e.version&&(l=e.toString(vt.base36))}}catch(h){if(_t(l))return void(yield It(await t(l,o),u));throw Et.error(h),a(new Error("Invalid IPNS name"),"ERR_IPNS_INVALID_NAME")}const d=await r.resolve(`/${c}/${l}`,o);yield It(d instanceof Uint8Array?(0,oe.toString)(d):d,u)}))}({dns:t,ipns:r,peerId:i,isOnline:o,options:l}),this.pubsub=new Pt({ipns:r,options:l})}}var Rt=r(98767),Ct=r(98691);const Tt=(0,ie.notFoundError)().code,Dt="<dst>",Bt="<src> -> <dst>";function xt(e,t,r){const{cid:n,path:s}=(0,mt.B)(t);return!1!==r.preload&&e(n),`/ipfs/${n}${s||""}`}async function*Nt(e,t,r,n,s){const i=await e(n,s),{cid:o}=(0,mt.B)(i),a=null!=s.maxDepth?s.maxDepth:1/0,c=s.unique||!1;for await(const u of async function*(e,t,r,n,s,i){const o=new Set;async function*a(r,c){const u=c+1;if(!(u>n))try{for await(const n of async function*(e,t,r,n){const s=await e.blocks.get(r,n),i=(await t.getCodec(r.code)).decode(s),o=r.code===l.code,a=[];for(const[c,l]of Lt(i,a)){if(o){const e=c.match(/^Links\/(\d+)\/Hash$/);if(e){const t=Number(e[1]);if(t<i.Links.length){yield{name:i.Links[t].Name,cid:l};continue}}}yield{name:c,cid:l}}}(e,t,r.cid,i))yield{parent:r,node:n,isDuplicate:s&&o.has(n.cid.toString())},s&&o.add(n.cid.toString()),yield*a(n,u)}catch(d){throw d.code===Tt&&(d.message=`Could not find object with CID: ${r.cid}`),d}}yield*a({cid:r},0)}(t,r,o,a,c,s))u.parent&&(u.isDuplicate||(yield{ref:Ot(u.parent.cid,u.node.cid,u.node.name,s.format)}))}function Ot(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"",n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Dt,s=n.replace(/<src>/g,e.toString());return s=s.replace(/<dst>/g,t.toString()),s=s.replace(/<linkname>/g,r),s}const Lt=function*(e,t){if(null!=e&&!(e instanceof Uint8Array)){for(const[r,n]of Object.entries(e)){const e=[...t,r];if(null!=n&&"object"===typeof n)if(Array.isArray(n))for(const[t,r]of n.entries()){const n=[...e,t],s=X.CID.asCID(r);s?yield[n.join("/"),s]:"object"===typeof r&&(yield*Lt(r,n))}else{const t=X.CID.asCID(n);t?yield[e.join("/"),t]:yield*Lt(n,e)}}return[]}};function Mt(e){let{repo:t}=e;return(0,q.a)((async function*(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};for await(const r of t.blocks.queryKeys({},{signal:e.signal}))yield{ref:r.toString()}}))}function jt(e){let{network:t}=e;return(0,q.a)((async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=(await t.use(e)).bitswap,n=r.stat().snapshot;return{provideBufLen:parseInt(n.providesBufferLength.toString()),blocksReceived:BigInt(n.blocksReceived.toString()),wantlist:Array.from(r.getWantlist()).map((e=>e[1].cid)),peers:r.peers().map((e=>e.toB58String())),dupBlksReceived:BigInt(n.dupBlksReceived.toString()),dupDataReceived:BigInt(n.dupDataReceived.toString()),dataReceived:BigInt(n.dataReceived.toString()),blocksSent:BigInt(n.blocksSent.toString()),dataSent:BigInt(n.dataSent.toString())}}))}class Ut{constructor(e){let{network:t}=e;this.wantlist=function(e){let{network:t}=e;return(0,q.a)((async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{bitswap:r}=await t.use(e),n=r.getWantlist();return Array.from(n).map((e=>e[1].cid))}))}({network:t}),this.wantlistForPeer=function(e){let{network:t}=e;return(0,q.a)((async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{bitswap:n}=await t.use(r),s=n.wantlistForPeer(J.createFromB58String(e));return Array.from(s).map((e=>e[1].cid))}))}({network:t}),this.unwant=function(e){let{network:t}=e;return(0,q.a)((async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{bitswap:n}=await t.use(r);return Array.isArray(e)||(e=[e]),n.unwant(e)}))}({network:t}),this.stat=jt({network:t})}}var zt=r(44021);function Wt(e){try{return zt.IPFS.matches(e)}catch(t){return!1}}var $t=r(10006);var Ft=r(10036);class Kt{constructor(e){let{repo:t}=e;this.add=function(e){let{repo:t}=e;return(0,q.a)((async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!Wt(e))throw new Error(`${e} is not a valid Multiaddr`);const n=await t.config.getAll(r),s=n.Bootstrap||[];return s.push(e.toString()),n.Bootstrap=Array.from(new Set(s)).sort(((e,t)=>e.localeCompare(t))),await t.config.replace(n),{Peers:[e]}}))}({repo:t}),this.list=function(e){let{repo:t}=e;return(0,q.a)((async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return{Peers:(await t.config.get("Bootstrap",e)||[]).map((e=>new $t.Multiaddr(e)))}}))}({repo:t}),this.rm=function(e){let{repo:t}=e;return(0,q.a)((async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!Wt(e))throw new Error(`${e} is not a valid Multiaddr`);const n=await t.config.getAll(r);return n.Bootstrap=(n.Bootstrap||[]).filter((t=>t.toString()!==e.toString())),await t.config.replace(n),{Peers:[e]}}))}({repo:t}),this.clear=function(e){let{repo:t}=e;return(0,q.a)((async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await t.config.getAll(e),n=r.Bootstrap||[];return r.Bootstrap=[],await t.config.replace(r),{Peers:n.map((e=>new $t.Multiaddr(e)))}}))}({repo:t}),this.reset=function(e){let{repo:t}=e;return(0,q.a)((async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await t.config.getAll(e);return r.Bootstrap=(0,Ft.Z)().Bootstrap,await t.config.replace(r),{Peers:(0,Ft.Z)().Bootstrap.map((e=>new $t.Multiaddr(e)))}}))}({repo:t})}}var qt=r(1833),Ht=r(60191),Gt=r(93663),Vt=r(89962);function Xt(e){return e instanceof Uint8Array?X.CID.decode(e):X.CID.parse(e.toString())}class Jt{constructor(e){let{codecs:t,hashers:r,preload:n,repo:s}=e;this.get=function(e){let{preload:t,repo:r}=e;return(0,q.a)((async function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return!1!==n.preload&&t(e),r.blocks.get(e,n)}))}({preload:n,repo:s}),this.put=function(e){let{codecs:t,hashers:r,repo:n,preload:s}=e;return(0,q.a)((async function(e){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const o=i.pin?await n.gcLock.readLock():null;try{const a=null!=i.version?i.version:0,c=i.format||(0===a?"dag-pb":"raw"),l=await r.getHasher(i.mhtype||"sha2-256"),u=await l.digest(e),d=await t.getCodec(c),h=X.CID.create(a,d.code,u);return await n.blocks.put(h,e,{signal:i.signal}),!1!==i.preload&&s(h),!0===i.pin&&await n.pins.pinRecursively(h,{signal:i.signal}),h}finally{o&&o()}}))}({codecs:t,hashers:r,preload:n,repo:s}),this.rm=function(e){let{repo:t}=e;return(0,q.a)((async function*(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};Array.isArray(e)||(e=[e]);const n=await t.gcLock.writeLock();try{yield*(0,Vt.pipe)(e,(e=>Ht(e,(e=>async()=>{const n={cid:e=Xt(e)};try{if(!await t.blocks.has(e))throw a(new Error("block not found"),"ERR_BLOCK_NOT_FOUND");await t.blocks.delete(e)}catch(s){r.force||(s.message=`cannot remove ${e}: ${s.message}`,n.error=s)}return n}))),(e=>qt(e,{concurrency:8})),(e=>Gt(e,(()=>!r.quiet))))}finally{n()}}))}({repo:s}),this.stat=function(e){let{repo:t,preload:r}=e;return(0,q.a)((async function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};e=Xt(e),!1!==n.preload&&r(e);return{cid:e,size:(await t.blocks.get(e)).length}}))}({preload:n,repo:s})}}var Zt=r(55194),Yt=r(31156),Qt=r(62469),er=r(21958),tr=r(47664);async function*rr(e){yield e}async function nr(e){if((0,tr._t)(e))return rr(sr(e));if("string"===typeof e||e instanceof String)return rr(sr(e.toString()));if((0,tr.Lj)(e))return Yt(e);if((0,tr.Os)(e)&&(e=Zt(e)),Symbol.iterator in e||Symbol.asyncIterator in e){const t=Qt(e),{value:r,done:n}=await t.peek();if(n)return rr(new Uint8Array(0));if(t.push(r),Number.isInteger(r))return rr(Uint8Array.from(await er(t)));if((0,tr._t)(r)||"string"===typeof r||r instanceof String)return Ht(t,sr)}throw a(new Error(`Unexpected input: ${e}`),"ERR_UNEXPECTED_INPUT")}function sr(e){return e instanceof Uint8Array?e:ArrayBuffer.isView(e)?new Uint8Array(e.buffer,e.byteOffset,e.byteLength):e instanceof ArrayBuffer?new Uint8Array(e):Array.isArray(e)?Uint8Array.from(e):(0,O.fromString)(e.toString())}async function ir(e,t){const{path:r,mode:n,mtime:s,content:i}=e,o={path:r||"",mode:(0,c.tK)(n),mtime:(0,c.Xu)(s)};return i?o.content=await t(i):r||(o.content=await t(e)),o}function or(e){return async function*(e,t){if(null===e||void 0===e)throw a(new Error(`Unexpected input: ${e}`),"ERR_UNEXPECTED_INPUT");if("string"===typeof e||e instanceof String)yield ir(e.toString(),t);else if((0,tr._t)(e)||(0,tr.Lj)(e))yield ir(e,t);else{if((0,tr.Os)(e)&&(e=Zt(e)),Symbol.iterator in e||Symbol.asyncIterator in e){const r=Qt(e),{value:n,done:s}=await r.peek();if(s)return void(yield{content:[]});if(r.push(n),Number.isInteger(n)||(0,tr._t)(n)||"string"===typeof n||n instanceof String)return void(yield ir(r,t));throw a(new Error("Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead"),"ERR_UNEXPECTED_INPUT")}if(!(0,tr.Mk)(e))throw a(new Error('Unexpected input: cannot convert "'+typeof e+'" into ImportCandidate'),"ERR_UNEXPECTED_INPUT");yield ir(e,t)}}(e,nr)}var ar=r(46224),cr=r(40389);function lr(e){return(0,cr.n)(e,nr)}var ur=r(67835);const dr=s.Z.bind({ignoreUndefined:!0});function hr(e){return async function*(t){for await(const r of t){let t=r.cid;1===e.cidVersion&&(t=t.toV1());let n=r.path?r.path:t.toString();e.wrapWithDirectory&&!r.path&&(n=""),yield{path:n,cid:t,size:r.size,mode:r.unixfs&&r.unixfs.mode,mtime:r.unixfs&&r.unixfs.mtime}}}}function pr(e,t){return async function*(r){for await(const n of r){(!n.path||t.wrapWithDirectory?""===n.path:!n.path.includes("/"))&&!t.onlyHash&&!1!==t.preload&&e(n.cid),yield n}}}function fr(e,t){return async function*(r){for await(const n of r){const r=!(n.path&&n.path.includes("/"));(null==t.pin||t.pin)&&r&&!t.onlyHash&&await e.pins.pinRecursively(n.cid),yield n}}}var gr=r(48206);var yr=r(53659),mr=r(4813),wr=r(42407);class br{constructor(e){let{preload:t,repo:r,hashers:n,options:s}=e;const i=function(e){let{repo:t,preload:r,hashers:n,options:s}=e;const i=s&&s.sharding;return(0,q.a)((async function*(e){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const o=dr({shardSplitThreshold:i?1e3:1/0,strategy:"balanced"},s,{...(0,ur.Aq)(s.chunker)});o.hashAlg&&"sha2-256"!==o.hashAlg&&1!==o.cidVersion&&(o.cidVersion=1),o.trickle&&(o.strategy="trickle"),"trickle"===o.strategy&&(o.leafType="raw",o.reduceSingleLeafToSelf=!1),o.cidVersion>0&&void 0===o.rawLeaves&&(o.rawLeaves=!0),void 0!==o.hashAlg&&void 0===o.rawLeaves&&(o.rawLeaves=!0),delete o.trickle;const a={};if(o.progress){const e=o.progress;o.progress=(t,r)=>{a[r]||(a[r]=0),a[r]+=t,e(a[r],r)}}let c;null!=o.hashAlg&&(c=await n.getHasher(o.hashAlg));const l=(0,Vt.pipe)(lr(e),(e=>(0,ar.Z)(e,t.blocks,{...o,hasher:c,pin:!1})),hr(o),pr(r,o),fr(t,o)),u=await t.gcLock.readLock();try{for await(const e of l)delete a[e.path],yield e}finally{u()}}))}({preload:t,repo:r,options:s,hashers:n});this.addAll=i,this.add=function(e){let{addAll:t}=e;return async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await Y(t(or(e),r));if(null==n)throw Error("Failed to add a file, if you see this please report a bug");return n}}({addAll:i}),this.cat=function(e){let{repo:t,preload:r}=e;return(0,q.a)((async function*(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(e=(0,L.JU)(e),!1!==n.preload){const t=e.split("/");r(X.CID.parse(t[0]))}const s=await(0,gr.OY)(e,t.blocks,n);if("directory"===s.type)throw new Error("this dag node is a directory");if(!s.content)throw new Error("this dag node has no content");yield*s.content(n)}))}({repo:r,preload:t}),this.get=function(e){let{repo:t,preload:r}=e;return(0,q.a)((async function*(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(null!=n.compressionLevel&&(n.compressionLevel<-1||n.compressionLevel>9))throw a(new Error("Compression level must be between -1 and 9"),"ERR_INVALID_PARAMS");if(!1!==n.preload){let t;try{t=(0,L.JU)(e).split("/")}catch(o){throw a(o,"ERR_INVALID_PATH")}r(X.CID.parse(t[0]))}const s=X.CID.asCID(e)||e,i=await(0,gr.OY)(s,t.blocks,n);if("file"===i.type||"raw"===i.type){const e=[];return n.compress&&!0!==n.archive?e.push(i.content):e.push([{header:{name:i.path,mode:"file"===i.type&&i.unixfs.mode,mtime:"file"===i.type&&i.unixfs.mtime?new Date(1e3*i.unixfs.mtime.secs):void 0,size:i.size,type:"file"},body:i.content()}],(0,yr.pack)(),(e=>Ht(e,(e=>e.slice())))),n.compress&&e.push((async function*(e){const t=await wr(e);yield mr.gzip(t,{level:n.compressionLevel||6})})),void(yield*(0,Vt.pipe)(...e))}if("directory"!==i.type)throw a(new Error("Not a UnixFS node"),"ERR_NOT_UNIXFS");{const e=[(0,gr.BE)(s,t.blocks,n),async function*(e){for await(const t of e){const e={header:{name:t.path,size:t.size}};if("file"===t.type)e.header.type="file",e.header.mode=null!=t.unixfs.mode?t.unixfs.mode:void 0,e.header.mtime=t.unixfs.mtime?new Date(1e3*t.unixfs.mtime.secs):void 0,e.body=t.content();else if("raw"===t.type)e.header.type="file",e.body=t.content();else{if("directory"!==t.type)throw a(new Error("Not a UnixFS node"),"ERR_NOT_UNIXFS");e.header.type="directory",e.header.mode=null!=t.unixfs.mode?t.unixfs.mode:void 0,e.header.mtime=t.unixfs.mtime?new Date(1e3*t.unixfs.mtime.secs):void 0}yield e}},(0,yr.pack)(),e=>Ht(e,(e=>e.slice()))];if(n.compress){if(!n.archive)throw a(new Error("file is not regular"),"ERR_INVALID_PATH");n.compress&&e.push((async function*(e){const t=await wr(e);yield mr.gzip(t,{level:n.compressionLevel||6})}))}yield*(0,Vt.pipe)(...e)}}))}({repo:r,preload:t}),this.ls=function(e){let{repo:t,preload:r}=e;return(0,q.a)((async function*(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const s=(0,L.JU)(e),i=s.split("/");!1!==n.preload&&r(X.CID.parse(i[0]));const o=X.CID.asCID(s)||s,c=await(0,gr.OY)(o,t.blocks,n);if("file"!==c.type){if("directory"!==c.type)throw a(new Error(`Unknown UnixFS type ${c.type}`),"ERR_UNKNOWN_UNIXFS_TYPE");for await(const e of c.content())yield(0,L.jr)(e)}else yield(0,L.jr)(c)}))}({repo:r,preload:t})}}var vr=r(22123);const _r=Object.assign(o("ipfs:components:id"),{error:o("ipfs:components:id:error")});async function kr(e,t,r){let n=await t.peerStore.get(e);n||(n=await async function(e,t,r){for await(const s of t._dht.findPeer(e,r))if("FINAL_PEER"===s.name)break;const n=await t.peerStore.get(e);if(!n)throw a(new Error("Could not find peer"),"ERR_NOT_FOUND");return n}(e,t,r));let s=e.pubKey?e.pubKey:await t.peerStore.keyBook.get(e);if(!s)try{s=await t._dht.getPublicKey(e,r)}catch(i){_r.error("Could not load public key for",e.toB58String(),i)}return{...n,publicKey:s,metadata:n.metadata||new Map,addresses:n.addresses.map((e=>e.multiaddr))}}var Er=r(69201);const Ir={server:{description:"Recommended for nodes with public IPv4 address (servers, VPSes, etc.), disables host and content discovery and UPnP in local networks.",transform:e=>(Er(e,"Discovery.MDNS.Enabled",!1),Er(e,"Discovery.webRTCStar.Enabled",!1),e.Swarm={...e.Swarm||{},DisableNatPortMap:!0},e)},"local-discovery":{description:"Sets default values to fields affected by `server` profile, enables discovery and UPnP in local networks.",transform:e=>(Er(e,"Discovery.MDNS.Enabled",!0),Er(e,"Discovery.webRTCStar.Enabled",!0),Er(e,"Swarm",{...e.Swarm||{},DisableNatPortMap:!1}),e)},test:{description:"Reduces external interference, useful for running ipfs in test environments. Note that with these settings node won't be able to talk to the rest of the network without manual bootstrap.",transform:e=>{const t=(0,Ft.Z)();return Er(e,"Addresses.API",t.Addresses.API?"/ip4/127.0.0.1/tcp/0":""),Er(e,"Addresses.Gateway",t.Addresses.Gateway?"/ip4/127.0.0.1/tcp/0":""),Er(e,"Addresses.Swarm",t.Addresses.Swarm.length?["/ip4/127.0.0.1/tcp/0"]:[]),Er(e,"Addresses.Delegates",[]),Er(e,"Bootstrap",[]),Er(e,"Discovery.MDNS.Enabled",!1),Er(e,"Discovery.webRTCStar.Enabled",!1),Er(e,"Swarm",{...e.Swarm||{},DisableNatPortMap:!0}),e}},"default-networking":{description:"Restores default network settings. Inverse profile of the `test` profile.",transform:e=>{const t=(0,Ft.Z)();return Er(e,"Addresses.API",t.Addresses.API),Er(e,"Addresses.Gateway",t.Addresses.Gateway),Er(e,"Addresses.Swarm",t.Addresses.Swarm),Er(e,"Addresses.Delegates",t.Addresses.Delegates),Er(e,"Bootstrap",t.Bootstrap),Er(e,"Discovery.MDNS.Enabled",t.Discovery.MDNS.Enabled),Er(e,"Discovery.webRTCStar.Enabled",t.Discovery.webRTCStar.Enabled),Er(e,"Swarm",{...e.Swarm||{},DisableNatPortMap:!1}),e}},lowpower:{description:"Reduces daemon overhead on the system. May affect node functionality,performance of content discovery and data fetching may be degraded. Recommended for low power systems.",transform:e=>{const t=e.Swarm||{},r=t.ConnMgr||{};return r.LowWater=20,r.HighWater=40,t.ConnMgr=r,e.Swarm=t,e}},"default-power":{description:'Inverse of "lowpower" profile.',transform:e=>{const t=(0,Ft.Z)();return e.Swarm=t.Swarm,e}}},Sr=o("ipfs:core:config");async function Pr(e){return Object.keys(Ir).map((e=>({name:e,description:Ir[e].description})))}var Ar=r(83737),Rr=r(75617);function Cr(e){const t=(0,u.encode)({version:1,roots:e}),r=Rr.encode(t.length),n=new Uint8Array(r.length+t.length);return n.set(r,0),n.set(t,r.length),n}var Tr=r(54595);const Dr={Null:e=>null===e,Int:e=>Number.isInteger(e),Float:e=>"number"===typeof e&&Number.isFinite(e),String:e=>"string"===typeof e,Bool:e=>"boolean"===typeof e,Bytes:e=>e instanceof Uint8Array,Link:e=>!Dr.Null(e)&&"object"===typeof e&&e.asCID===e,List:e=>Array.isArray(e),Map:e=>!Dr.Null(e)&&"object"===typeof e&&e.asCID!==e&&!Dr.List(e)&&!Dr.Bytes(e)},Br={Int:Dr.Int,"CarHeader > version":e=>Br.Int(e),"CarHeader > roots (anon) > valueType (anon)":Dr.Link,"CarHeader > roots (anon)":e=>Dr.List(e)&&Array.prototype.every.call(e,Br["CarHeader > roots (anon) > valueType (anon)"]),"CarHeader > roots":e=>Br["CarHeader > roots (anon)"](e),CarHeader:e=>{const t=e&&Object.keys(e);return Dr.Map(e)&&["version"].every((e=>t.includes(e)))&&Object.entries(e).every((e=>{let[t,r]=e;return Br["CarHeader > "+t]&&Br["CarHeader > "+t](r)}))}},xr=Br.CarHeader,Nr=18,Or=32,Lr=112;async function Mr(e){const t=await e.upTo(8);if(!t.length)throw new Error("Unexpected end of data");const r=Rr.decode(t);return e.seek(Rr.decode.bytes),r}async function jr(e,t){const r=await Mr(e);if(0===r)throw new Error("Invalid CAR header (zero length)");const n=await e.exactly(r);e.seek(r);const s=(0,u.decode)(n);if(!xr(s))throw new Error("Invalid CAR header format");if(1!==s.version&&2!==s.version||void 0!==t&&s.version!==t)throw new Error(`Invalid CAR version: ${s.version}${void 0!==t?` (expected ${t})`:""}`);const i=Array.isArray(s.roots);if(1===s.version&&!i||2===s.version&&i)throw new Error("Invalid CAR header format");if(1===s.version)return s;const o=await async function(e){const t=await e.exactly(40),r=new DataView(t.buffer,t.byteOffset,t.byteLength);let n=0;const s={version:2,characteristics:[r.getBigUint64(n,!0),r.getBigUint64(n+=8,!0)],dataOffset:Number(r.getBigUint64(n+=8,!0)),dataSize:Number(r.getBigUint64(n+=8,!0)),indexOffset:Number(r.getBigUint64(n+=8,!0))};return e.seek(40),s}(e);e.seek(o.dataOffset-e.pos);const a=await jr(e,1);return Object.assign(a,o)}async function Ur(e){const t=await e.exactly(2);if(t[0]===Nr&&t[1]===Or){const t=await e.exactly(34);e.seek(34);const r=ue.decode(t);return X.CID.create(0,Lr,r)}const r=await Mr(e);if(1!==r)throw new Error(`Unexpected CID version (${r})`);const n=await Mr(e),s=await async function(e){const t=await e.upTo(8);Rr.decode(t);const r=Rr.decode.bytes,n=Rr.decode(t.subarray(Rr.decode.bytes)),s=r+Rr.decode.bytes+n,i=await e.exactly(s);return e.seek(s),i}(e),i=ue.decode(s);return X.CID.create(r,n,i)}async function zr(e){const t=e.pos;let r=await Mr(e);if(0===r)throw new Error("Invalid CAR section (zero length)");r+=e.pos-t;return{cid:await Ur(e),length:r,blockLength:r-Number(e.pos-t)}}async function Wr(e){const{cid:t,blockLength:r}=await zr(e),n=await e.exactly(r);return e.seek(r),{bytes:n,cid:t}}async function $r(e){const t=e.pos,{cid:r,length:n,blockLength:s}=await zr(e),i={cid:r,length:n,blockLength:s,offset:t,blockOffset:e.pos};return e.seek(i.blockLength),i}function Fr(e){const t=(async()=>{const t=await jr(e);if(2===t.version){const r=e.pos-t.dataOffset;e=function(e,t){let r=0;return{async upTo(n){let s=await e.upTo(n);return s.length+r>t&&(s=s.subarray(0,t-r)),s},async exactly(n){const s=await e.exactly(n);if(s.length+r>t)throw new Error("Unexpected end of data");return s},seek(t){r+=t,e.seek(t)},get pos(){return e.pos}}}(e,t.dataSize-r)}return t})();return{header:()=>t,async*blocks(){for(await t;(await e.upTo(8)).length>0;)yield await Wr(e)},async*blocksIndex(){for(await t;(await e.upTo(8)).length>0;)yield await $r(e)}}}function Kr(e){let t=0;return{upTo:async r=>e.subarray(t,t+Math.min(r,e.length-t)),async exactly(r){if(r>e.length-t)throw new Error("Unexpected end of data");return e.subarray(t,t+r)},seek(e){t+=e},get pos(){return t}}}function qr(e){const t=e[Symbol.asyncIterator]();return function(e){let t=0,r=0,n=0,s=new Uint8Array(0);const i=async t=>{r=s.length-n;const i=[s.subarray(n)];for(;r<t;){const t=await e();if(null==t)break;r<0?t.length>r&&i.push(t.subarray(-r)):i.push(t),r+=t.length}s=new Uint8Array(i.reduce(((e,t)=>e+t.length),0));let o=0;for(const e of i)s.set(e,o),o+=e.length;n=0};return{upTo:async e=>(s.length-n<e&&await i(e),s.subarray(n,n+Math.min(s.length-n,e))),async exactly(e){if(s.length-n<e&&await i(e),s.length-n<e)throw new Error("Unexpected end of data");return s.subarray(n,n+e)},seek(e){t+=e,n+=e},get pos(){return t}}}((async function(){const e=await t.next();return e.done?null:e.value}))}class Hr{constructor(e,t){this._encoder=t,this._mutex=t.setRoots(e),this._ended=!1}async put(e){if(!(e.bytes instanceof Uint8Array)||!e.cid)throw new TypeError("Can only write {cid, bytes} objects");if(this._ended)throw new Error("Already closed");const t=X.CID.asCID(e.cid);if(!t)throw new TypeError("Can only write {cid, bytes} objects");return this._mutex=this._mutex.then((()=>this._encoder.writeBlock({cid:t,bytes:e.bytes}))),this._mutex}async close(){if(this._ended)throw new Error("Already closed");return await this._mutex,this._ended=!0,this._encoder.close()}static create(e){e=function(e){if(void 0===e)return[];if(!Array.isArray(e)){const t=X.CID.asCID(e);if(!t)throw new TypeError("roots must be a single CID or an array of CIDs");return[t]}const t=[];for(const r of e){const e=X.CID.asCID(r);if(!e)throw new TypeError("roots must be a single CID or an array of CIDs");t.push(e)}return t}(e);const{encoder:t,iterator:r}=Vr();return{writer:new Hr(e,t),out:new Gr(r)}}static createAppender(){const{encoder:e,iterator:t}=Vr();e.setRoots=()=>Promise.resolve();return{writer:new Hr([],e),out:new Gr(t)}}static async updateRootsInBytes(e,t){const r=Kr(e);await jr(r);const n=Cr(t);if(Number(r.pos)!==n.length)throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${r.pos} bytes, new header is ${n.length} bytes)`);return e.set(n,0),e}}class Gr{constructor(e){this._iterator=e}[Symbol.asyncIterator](){if(this._iterating)throw new Error("Multiple iterator not supported");return this._iterating=!0,this._iterator}}function Vr(){const e=(0,Tr.U)(),{writer:t,iterator:r}=e,n=function(e){return{async setRoots(t){const r=Cr(t);await e.write(r)},async writeBlock(t){const{cid:r,bytes:n}=t;await e.write(new Uint8Array(Rr.encode(r.bytes.length+n.length))),await e.write(r.bytes),n.length&&await e.write(n)},async close(){await e.end()}}}(t);return{encoder:n,iterator:r}}var Xr=r(96602),Jr=r(39928);const Zr=async e=>{let{cid:t,load:r,seen:n}=e;n=n||new Set;const s=t.toString(Ye.base58btc);if(n.has(s))return;const i=await r(t);if(n.add(s),null!==i)for(const[,o]of i.links())await Zr({cid:o,load:r,seen:n})},Yr=o("ipfs:components:dag:import"),Qr=[Xr.code,Jr.code];function en(e,t,r,n){return async s=>{const i=await n.getCodec(s.code);if(!i)throw new Error(`Can't decode links in block with codec 0x${s.code.toString(16)} to form complete DAG`);const o=await e.blocks.get(s,r);return Yr(`Adding block ${s} to car`),await t.put({cid:s,bytes:o}),Qr.includes(s.code)?null:(0,Ar.OV)({bytes:o,cid:s,codec:i})}}var tn=r(45454);class rn{constructor(e,t,r){this._version=e,this._roots=t,this._iterable=r,this._decoded=!1}get version(){return this._version}async getRoots(){return this._roots}}class nn extends rn{[Symbol.asyncIterator](){if(this._decoded)throw new Error("Cannot decode more than once");if(!this._iterable)throw new Error("Block iterable not found");return this._decoded=!0,this._iterable[Symbol.asyncIterator]()}static async fromBytes(e){const{version:t,roots:r,iterator:n}=await sn(e);return new nn(t,r,n)}static async fromIterable(e){const{version:t,roots:r,iterator:n}=await on(e);return new nn(t,r,n)}}Symbol.asyncIterator;async function sn(e){if(!(e instanceof Uint8Array))throw new TypeError("fromBytes() requires a Uint8Array");return an(Kr(e))}async function on(e){if(!e||"function"!==typeof e[Symbol.asyncIterator])throw new TypeError("fromIterable() requires an async iterable");return an(qr(e))}async function an(e){const t=Fr(e),{version:r,roots:n}=await t.header();return{version:r,roots:n,iterator:t.blocks()}}const cn=o("ipfs:components:dag:import");async function ln(e,t,r){const n=await nn.fromIterable(r),s=await n.getRoots();return await dt(e.blocks.putMany(Ht(n,(e=>{let{cid:t,bytes:r}=e;return cn(`Import block ${t}`),{key:t,value:r}})),{signal:t.signal})),s}class un{constructor(e){let{repo:t,codecs:r,hashers:n,preload:s}=e;this.export=function(e){let{repo:t,preload:r,codecs:n}=e;return(0,q.a)((async function*(e){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};!1!==s.preload&&r(e);const i=X.CID.asCID(e);if(!i)throw new Error(`Unexpected error converting CID type: ${e}`);Yr(`Exporting ${i} as car`);const{writer:o,out:a}=await Hr.create([i]);let c=null;(async()=>{try{const e=en(t,o,{signal:s.signal,timeout:s.timeout},n);await Zr({cid:i,load:e})}catch(e){c=e}finally{o.close()}})();for await(const t of a){if(c)break;yield t}if(c)throw c}))}({repo:t,preload:s,codecs:r}),this.get=function(e){let{codecs:t,repo:r,preload:n}=e;return(0,q.a)((async function(e){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!1!==s.preload&&n(e),s.path){const n=s.localResolve?await tn((0,L.DB)(e,s.path,t,r,s)):await Y((0,L.DB)(e,s.path,t,r,s));if(!n)throw a(new Error("Not found"),"ERR_NOT_FOUND");return n}const i=await t.getCodec(e.code),o=await r.blocks.get(e,s);return{value:i.decode(o),remainderPath:""}}))}({codecs:r,repo:t,preload:s}),this.import=function(e){let{repo:t}=e;return(0,q.a)((async function*(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await t.gcLock.readLock();try{const i={signal:r.signal,timeout:r.timeout},o=Qt(e),{value:a,done:c}=await o.peek();if(c)return;let l;a&&o.push(a),l=a instanceof Uint8Array?[o]:o;for await(const e of l){const n=await ln(t,i,e);if(!1!==r.pinRoots)for(const e of n){let r="";try{await t.blocks.has(e)?(cn(`Pinning root ${e}`),await t.pins.pinRecursively(e)):r="blockstore: block not found"}catch(s){r=s.message}yield{root:{cid:e,pinErrorMsg:r}}}}}finally{n()}}))}({repo:t}),this.resolve=function(e){let{repo:t,codecs:r,preload:n}=e;return(0,q.a)((async function(e){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{cid:i}=(0,mt.B)(e);return!1!==s.preload&&n(i),(0,L.i3)(t,r,e,s)}))}({repo:t,codecs:r,preload:s}),this.put=function(e){let{repo:t,codecs:r,hashers:n,preload:s}=e;return(0,q.a)((async function(e){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const o=i.pin?await t.gcLock.readLock():null;try{const a=await r.getCodec(i.storeCodec||"dag-cbor");if(!a)throw new Error(`Unknown storeCodec ${i.storeCodec}, please configure additional BlockCodecs for this IPFS instance`);if(i.inputCodec){if(!(e instanceof Uint8Array))throw new Error("Can only inputCodec on raw bytes that can be decoded");const t=await r.getCodec(i.inputCodec);if(!t)throw new Error(`Unknown inputCodec ${i.inputCodec}, please configure additional BlockCodecs for this IPFS instance`);e=t.decode(e)}const c=null!=i.version?i.version:1,l=await n.getHasher(i.hashAlg||"sha2-256");if(!l)throw new Error(`Unknown hash algorithm ${i.hashAlg}, please configure additional MultihashHashers for this IPFS instance`);const u=a.encode(e),d=await l.digest(u),h=X.CID.create(c,a.code,d);return await t.blocks.put(h,u,{signal:i.signal}),i.pin&&await t.pins.pinRecursively(h),!1!==i.preload&&s(h),h}finally{o&&o()}}))}({repo:t,codecs:r,hashers:n,preload:s})}}var dn=r(36381),hn=r(76297);const pn=Object.assign(o("ipfs:preload"),{error:o("ipfs:preload:error")}),fn=new(U.default?U.default:U)({concurrency:4});function gn(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return pn(e),fn.add((async()=>{const r=(await z.post(e,{signal:t.signal})).body.getReader();try{for(;;){const{done:e}=await r.read();if(e)return}}finally{r.releaseLock()}}))}const yn=Object.assign(o("ipfs:preload"),{error:o("ipfs:preload:error")});function mn(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(e.enabled=Boolean(e.enabled),e.addresses=e.addresses||[],e.cache=e.cache||1e3,!e.enabled||!e.addresses.length){yn("preload disabled");const e=()=>{};return Object.assign(e,{start:()=>{},stop:()=>{}})}let t=!0,r=[];const n=e.addresses.map(dn),s=He(e.cache),i=async e=>{try{if(t)throw new Error(`preload ${e} but preloader is not started`);const o=e.toString();if(s.has(o))return;s.set(o,!0);const a=hn(n);let c=!1;const l=Date.now();for(const e of a){if(t)throw new Error(`preload aborted for ${o}`);let n;try{n=new AbortController,r=r.concat(n),await gn(`${e}/api/v0/refs?r=true&arg=${encodeURIComponent(o)}`,{signal:n.signal}),c=!0}catch(i){"aborted"!==i.type&&yn.error(i)}finally{r=r.filter((e=>e!==n))}if(c)break}yn(`${c?"":"un"}successfully preloaded ${o} in ${Date.now()-l}ms`)}catch(i){yn.error(i)}};return i.start=()=>{t=!1},i.stop=()=>{t=!0,yn(`aborting ${r.length} pending preload request(s)`),r.forEach((e=>e.abort())),r=[]},i}const wn=Object.assign(o("ipfs:mfs-preload"),{error:o("ipfs:mfs-preload:error")});var bn=r(70962),vn=r(91025),_n=r(62442),kn=r(12944),En=r(2723),In=r(65887),Sn=r(39849),Pn=r(74009),An=r(87956),Rn=r(56792),Cn=r(17300),Tn=r(48396);const Dn={stat:vn.y},Bn={chmod:_n.b,cp:kn.h,flush:En.k,mkdir:In.T,mv:Sn.f,rm:Pn.Q,touch:An.T},xn={write:Cn.g,read:Rn.k,ls:Tn.c},Nn=e=>{let{options:t,mfs:r,operations:n,lock:s}=e;Object.keys(n).forEach((e=>{r[e]=s(n[e](t))}))},On={repoOwner:!0,repo:null};function Ln(e){let{repo:t,preload:r,hashers:n,options:s}=e;const i=function(e){const{repoOwner:t}=Object.assign({},On||{},e),r=(0,bn.Y)(t),n={};return Nn({options:e,mfs:n,operations:Dn,lock:e=>r.readLock(e)}),Nn({options:e,mfs:n,operations:Bn,lock:e=>r.writeLock(e)}),Object.keys(xn).forEach((t=>{n[t]=xn[t](e)})),n}({repo:t,repoOwner:Boolean(s.repoOwner),hashers:n}),o=e=>function(){for(var t=arguments.length,n=new Array(t),s=0;s<t;s++)n[s]=arguments[s];const i=n.filter((e=>V.ipfsPath(e)||V.cid(e)));if(i.length){const e=n[n.length-1];e&&!1!==e.preload&&i.forEach((e=>r(e)))}return e(...n)};return{...i,chmod:i.chmod,cp:o(i.cp),mkdir:i.mkdir,stat:o(i.stat),rm:i.rm,read:o(i.read),touch:i.touch,write:i.write,mv:o(i.mv),flush:i.flush,ls:o((async function*(){for await(const e of i.ls(...arguments))yield{...e,size:e.size||0}}))}}const Mn="ed25519",jn=2048;class Un{constructor(e){let{keychain:t}=e;this.gen=function(e){let{keychain:t}=e;return(0,q.a)((function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{type:Mn,size:jn};return t.createKey(e,r.type||Mn,r.size||jn)}))}({keychain:t}),this.list=function(e){let{keychain:t}=e;return(0,q.a)((()=>t.listKeys()))}({keychain:t}),this.rm=function(e){let{keychain:t}=e;return(0,q.a)((e=>t.removeKey(e)))}({keychain:t}),this.rename=function(e){let{keychain:t}=e;return(0,q.a)((async(e,r)=>{const n=await t.renameKey(e,r);return{was:e,now:n.name,id:n.id,overwrite:!1}}))}({keychain:t}),this.export=function(e){let{keychain:t}=e;return(0,q.a)(((e,r)=>t.exportKey(e,r)))}({keychain:t}),this.import=function(e){let{keychain:t}=e;return(0,q.a)(((e,r,n)=>t.importKey(e,r,n)))}({keychain:t}),this.info=function(e){let{keychain:t}=e;return(0,q.a)((e=>t.findKeyByName(e)))}({keychain:t})}}function zn(e){let{repo:t,preload:r}=e;return(0,q.a)((async function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};!1!==n.preload&&r(e);const s=await t.blocks.get(e,n);return l.decode(s)}))}function Wn(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];for(const n in e){const s=e[n];if("/"===n&&1===Object.keys(e).length)try{t.push({Name:"",Tsize:0,Hash:X.CID.parse(s)});continue}catch(r){}const i=X.CID.asCID(s);i?t.push({Name:"",Tsize:0,Hash:i}):(Array.isArray(s)&&Wn(s,t),s&&"object"===typeof s&&Wn(s,t))}return t}var $n=r(92829);function Fn(e){let{repo:t,preload:r}=e;return(0,q.a)((async function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const s=await t.gcLock.readLock();try{const i=l.encode(e),o=await $n.sha256.digest(i),a=X.CID.createV1(l.code,o);return await t.blocks.put(a,i,{signal:n.signal}),!1!==n.preload&&r(a),n.pin&&await t.pins.pinRecursively(a,{signal:n.signal}),a}finally{s()}}))}class Kn{constructor(e){let{repo:t,preload:r}=e;this.addLink=function(e){let{repo:t,preload:r}=e;const n=zn({repo:t,preload:r}),s=Fn({repo:t,preload:r});return(0,q.a)((async function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=await n(e,r);return s({...i,Links:i.Links.concat([t])},r)}))}({repo:t,preload:r}),this.appendData=function(e){let{repo:t,preload:r}=e;const n=zn({repo:t,preload:r}),s=Fn({repo:t,preload:r});return(0,q.a)((async function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=await n(e,r),o=(0,he.concat)([i.Data||[],t]);return s({...i,Data:o},r)}))}({repo:t,preload:r}),this.rmLink=function(e){let{repo:t,preload:r}=e;const n=zn({repo:t,preload:r}),s=Fn({repo:t,preload:r});return(0,q.a)((async function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=await n(e,r),o=("string"===typeof t?t:t.Name)||"";return i.Links=i.Links.filter((e=>e.Name!==o)),s(i,r)}))}({repo:t,preload:r}),this.setData=function(e){let{repo:t,preload:r}=e;const n=zn({repo:t,preload:r}),s=Fn({repo:t,preload:r});return(0,q.a)((async function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=await n(e,r);return s({...i,Data:t},r)}))}({repo:t,preload:r})}}class qn{constructor(e){let{repo:t,codecs:r,preload:n}=e;this.data=function(e){let{repo:t,preload:r}=e;const n=zn({repo:t,preload:r});return(0,q.a)((async function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return(await n(e,t)).Data||new Uint8Array(0)}))}({repo:t,preload:n}),this.get=zn({repo:t,preload:n}),this.links=function(e){let{repo:t,codecs:r}=e;return(0,q.a)((async function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const s=await r.getCodec(e.code),i=await t.blocks.get(e,n),o=s.decode(i);switch(e.code){case Xr.code:return[];case l.code:return o.Links;case u.code:case v:return Wn(o);default:throw new Error(`Cannot resolve links from codec ${e.code}`)}}))}({repo:t,codecs:r}),this.new=function(e){let{repo:t,preload:r}=e;return(0,q.a)((async function(){let e,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(n.template){if("unixfs-dir"!==n.template)throw new Error("unknown template");e=new c.fL({type:"directory"}).marshal()}const s=l.encode({Data:e,Links:[]}),i=await $n.sha256.digest(s),o=X.CID.createV0(i);return await t.blocks.put(o,s,{signal:n.signal}),!1!==n.preload&&r(o),o}))}({repo:t,preload:n}),this.put=Fn({repo:t,preload:n}),this.stat=function(e){let{repo:t,preload:r}=e;const n=zn({repo:t,preload:r});return(0,q.a)((async function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const r=await n(e,t),s=l.encode(r).length,i=r.Links.reduce(((e,t)=>e+(t.Tsize||0)),0);return{Hash:e,NumLinks:r.Links.length,BlockSize:s,LinksSize:s-(r.Data||[]).length,DataSize:(r.Data||[]).length,CumulativeSize:s+i}}))}({repo:t,preload:n}),this.patch=new Kn({repo:t,preload:n})}}var Hn=r(61542);const Gn=o("ipfs:repo:gc");function Vn(e){let{repo:t}=e;return(0,q.a)((async function(){const e=await t.stat();return{numObjects:BigInt(e.numObjects.toString()),repoSize:BigInt(e.repoSize.toString()),repoPath:e.repoPath,version:`${e.version}`,storageMax:BigInt(e.storageMax.toString())}}))}var Xn=r(64931);class Jn{constructor(e){let{repo:t,hashers:r}=e;this.gc=function(e){let{repo:t,hashers:r}=e;return(0,q.a)((async function*(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n=Date.now();let s;try{s=await(0,Hn.x)({repo:t,hashers:r},e),await t.pins.pinRecursively(s),yield*t.gc()}finally{s&&await t.pins.unpin(s)}Gn(`Complete (${Date.now()-n}ms)`)}))}({repo:t,hashers:r}),this.stat=Vn({repo:t}),this.version=function(e){let{repo:t}=e;return(0,q.a)((async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};try{await t._checkInitialized(e)}catch(r){if([/Key not found in database \[\/version\]/,/ENOENT/,/repo is not initialized yet/].some((e=>e.test(r.message))))return Xn._;throw r}return t.version.get()}))}({repo:t}),this.setApiAddr=e=>t.apiAddr.set(e)}}function Zn(e,t){let r;if(r=e.metrics?t.peer?e.metrics.forPeer(J.parse(t.peer)):t.proto?e.metrics.forProtocol(t.proto):e.metrics.global:void 0,!r)return{totalIn:BigInt(0),totalOut:BigInt(0),rateIn:0,rateOut:0};const{movingAverages:n,snapshot:s}=r;return{totalIn:BigInt(s.dataReceived.integerValue().toString()),totalOut:BigInt(s.dataSent.integerValue().toString()),rateIn:n.dataReceived[6e4].movingAverage()/60,rateOut:n.dataSent[6e4].movingAverage()/60}}class Yn{constructor(e){let{repo:t,network:r}=e;this.repo=Vn({repo:t}),this.bw=function(e){let{network:t}=e;return(0,q.a)((async function*(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{libp2p:r}=await t.use(e);if(!e.poll)return void(yield Zn(r,e));const n=e.interval||1e3;let s,i=-1;try{if(i="string"===typeof n?(0,yt.Z)(n)||-1:n,!i||i<0)throw new Error("invalid duration")}catch(o){throw a(o,"ERR_INVALID_POLL_INTERVAL")}try{for(;;)yield Zn(r,e),await new Promise((e=>{s=setTimeout(e,i)}))}finally{clearTimeout(s)}}))}({network:r}),this.bitswap=jt({network:r})}}var Qn=r(2548),es=r(34695),ts=r(17008),rs=r(24222),ns=r(27401),ss=r(46714);const is={description:"Empty migration.",migrate:()=>{},revert:()=>{},empty:!0},os=[Object.assign({version:1},is),Object.assign({version:2},is),Object.assign({version:3},is),Object.assign({version:4},is),Object.assign({version:5},is),Object.assign({version:6},is),Object.assign({version:7},is),es.Q,ts.Q,rs.Q,ns.Q,ss.Q];var as=r(35264),cs=r(38099),ls=r(61757);const us=o("ipfs:repo:migrator");async function ds(e,t,r,n,s){let{ignoreLock:i=!1,onProgress:o,isDryRun:a=!1,migrations:c}=s;if(c=c||os,!e)throw new ps.RequiredParameterError("Path argument is required!");if(!r)throw new ps.RequiredParameterError("repoOptions argument is required!");if(!n)throw new ps.RequiredParameterError("toVersion argument is required!");if(!Number.isInteger(n)||n<=0)throw new ps.InvalidValueError("Version has to be positive integer!");t=(0,ls.pf)(t);const l=await as.b(t);if(l===n)return void us("Nothing to migrate.");if(l>n)throw new ps.InvalidValueError(`Current repo's version (${l}) is higher then toVersion (${n}), you probably wanted to revert it?`);let u;hs(c,l,n),a||i||(u=await r.repoLock.lock(e));try{for(const e of c){if(void 0!==n&&e.version>n)break;if(!(e.version<=l)){us(`Migrating version ${e.version}`);try{if(!a){let r=()=>{};o&&(r=(t,r)=>o(e.version,t.toFixed(2),r)),await e.migrate(t,r)}}catch(d){const r=e.version-1;throw us(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${r}`),await as.x(r,t),new Error(`During migration to version ${e.version} exception was raised: ${d.stack||d.message||d}`)}us(`Migrating to version ${e.version} finished`)}}a||await as.x(n||function(e){return e=e||os,Array.isArray(e)&&0!==e.length?e[e.length-1].version:0}(c),t),us("Repo successfully migrated",void 0!==n?`to version ${n}!`:"to latest version!")}finally{a||i||!u||await u.close()}}function hs(e,t,r){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=0;for(const i of e){if(i.version>r)break;if(i.version>t){if(n&&!i.revert)throw new ps.NonReversibleMigrationError(`It is not possible to revert to version ${t} because migration version ${i.version} is not reversible. Cancelling reversion.`);s++}}if(s!==r-t)throw new ps.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${t} to ${r}`)}as.b;const ps=cs;var fs=r(77073);class gs extends Error{constructor(e){super(e),this.name="LockExistsError",this.code=gs.code}}gs.code="ERR_LOCK_EXISTS";class ys extends Error{constructor(e){super(e),this.name="NotFoundError",this.code=ys.code}}ys.code="ERR_NOT_FOUND";class ms extends Error{constructor(e){super(e),this.name="InvalidRepoVersionError",this.code=ms.code}}ms.code="ERR_INVALID_REPO_VERSION";const ws="ERR_REPO_NOT_INITIALIZED";async function bs(e,t,r){const n=await t(e);if(n)return n;const s=_s(r);return!!s&&new Promise(((t,r)=>{const n=s.store("readonly").get(e.toString());n.transaction.onabort=()=>{r(n.transaction.error)},n.transaction.oncomplete=()=>{t(Boolean(n.result))}}))}async function vs(e,t,r,n){if(await r(e))return t(e);const s=_s(n);if(!s)throw new ys;return new Promise(((t,r)=>{const n=s.store("readonly").get(e.toString());n.transaction.onabort=()=>{r(n.transaction.error)},n.transaction.oncomplete=()=>{if(n.result)return t(n.result);r(new ys)}}))}function _s(e){let t=e;for(;t.db||t.child;)if(t=t.db||t.child,"level-js"===t.type||"Level"===t.constructor.name)return t}const ks=o("ipfs:repo:version"),Es=new se.Key("version");const Is=U.default?U.default:U,Ss=new se.Key("config");var Ps=r(31579);const As=new Qe.s("datastore_spec");const Rs=new se.Key("api");var Cs=r(31730);function Ts(e){const t=X.CID.asCID(e);if(null==t)throw a(new Error("Not a valid cid"),"ERR_INVALID_CID");return t.multihash.code!==S.identity.code?{isIdentity:!1}:{isIdentity:!0,digest:t.multihash.digest}}const Ds=o("ipfs:repo:lock:memory"),Bs="repo.lock",xs={};const Ns={lock:async function(e){const t=e+"/"+Bs;if(Ds("locking %s",t),!0===xs[t])throw new gs(`Lock already being held for file: ${t}`);return xs[t]=!0,{async close(){xs[t]&&delete xs[t]}}},locked:async function(e){const t=e+"/"+Bs;return Ds(`checking lock: ${t}`),Boolean(xs[t])}},Os={autoMigrate:!0,onMigrationProgress:()=>{},repoOwner:!0,repoLock:Ns},Ls={Spec:{type:"mount",mounts:[{mountpoint:"/blocks",type:"measure",prefix:"flatfs.datastore",child:{type:"flatfs",path:"blocks",sync:!0,shardFunc:"/repo/flatfs/shard/v1/next-to-last/2"}},{mountpoint:"/",type:"measure",prefix:"leveldb.datastore",child:{type:"levelds",path:"datastore",compression:"none"}}]}};function Ms(e){const t=d.k0.asCID(e);if(null==t)throw a(new Error("Not a valid cid"),"ERR_INVALID_CID");const r=de.base32.encode(t.multihash.bytes);return new se.Key("/"+r.slice(1).toUpperCase(),!1)}function js(e){return ue.decode(de.base32.decode(`b${e.toString().toLowerCase().substring(1)}`))}const Us=o("ipfs:repo:utils:walk-dag");async function*zs(e,t,r,n){try{const s=await t.get(e,n),i=await r(e.code),o=(0,Ar.OV)({bytes:s,cid:e,codec:i});for(const[,e]of o.links())yield e,yield*zs(e,t,r,n)}catch(s){throw Us("Could not walk DAG for CID",e.toString(),s),s}}class Ws{constructor(e){let{pinstore:t,blockstore:r,loadCodec:n}=e;this.pinstore=t,this.blockstore=r,this.loadCodec=n,this.log=o("ipfs:repo:pin"),this.directPins=new Set,this.recursivePins=new Set}async pinDirectly(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};await this.blockstore.get(e,t);const r={depth:0};return 0!==e.version&&(r.version=e.version),e.code!==l.code&&(r.codec=e.code),t.metadata&&(r.metadata=t.metadata),this.pinstore.put(Ms(e),p.cv(r))}unpin(e,t){return this.pinstore.delete(Ms(e),t)}async pinRecursively(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};await this.fetchCompleteDag(e,t);const r={depth:1/0};0!==e.version&&(r.version=e.version),e.code!==l.code&&(r.codec=e.code),t.metadata&&(r.metadata=t.metadata),await this.pinstore.put(Ms(e),p.cv(r))}async*directKeys(e){for await(const t of this.pinstore.query({filters:[e=>0===p.Jx(e.value).depth]})){const e=p.Jx(t.value),r=e.version||0,n=null!=e.codec?e.codec:l.code,s=js(t.key);yield{cid:X.CID.create(r,n,s),metadata:e.metadata}}}async*recursiveKeys(e){for await(const t of this.pinstore.query({filters:[e=>p.Jx(e.value).depth===1/0]})){const e=p.Jx(t.value),r=e.version||0,n=null!=e.codec?e.codec:l.code,s=js(t.key);yield{cid:X.CID.create(r,n,s),metadata:e.metadata}}}async*indirectKeys(e){for await(const{cid:t}of this.recursiveKeys())for await(const r of zs(t,this.blockstore,this.loadCodec,e)){const e=[te.recursive];(await this.isPinnedWithType(r,e)).pinned||(yield r)}}async isPinnedWithType(e,t,r){Array.isArray(t)||(t=[t]);const n=t.includes(te.all),s=t.includes(te.direct),i=t.includes(te.recursive),o=t.includes(te.indirect);if(i||s||n){const r=await tn(this.pinstore.query({prefix:Ms(e).toString(),filters:[e=>{if(n)return!0;const r=p.Jx(e.value);return t.includes(0===r.depth?te.direct:te.recursive)}],limit:1}));if(r){const t=p.Jx(r.value);return{cid:e,pinned:!0,reason:0===t.depth?te.direct:te.recursive,metadata:t.metadata}}}const a=this;if(n||o){const t=await tn(async function*(e,t){for await(const{cid:r}of t)for await(const t of zs(r,a.blockstore,a.loadCodec))if(t.equals(e))return void(yield r)}(e,this.recursiveKeys()));if(t)return{cid:e,pinned:!0,reason:te.indirect,parent:t}}return{cid:e,pinned:!1}}async fetchCompleteDag(e,t){const r=new Set,n=async(e,t)=>{if(r.has(e.toString()))return;r.add(e.toString());const s=await this.blockstore.get(e,t),i=await this.loadCodec(e.code),o=(0,Ar.OV)({bytes:s,cid:e,codec:i});await Promise.all([...o.links()].map((e=>{let[,r]=e;return n(r,t)})))};await n(e,t)}static checkPinType(e){if("string"!==typeof e||!Object.keys(te).includes(e))throw function(e){return a(new Error(`Invalid type '${e}', must be one of {direct, indirect, recursive, all}`),"ERR_INVALID_PIN_TYPE")}(e);return!0}}async function $s(e,t){const{pinned:r,reason:n}=await t.isPinnedWithType(e,te.all);if(r)throw a(new Error(`pinned: ${n}`),"ERR_BLOCK_PINNED")}var Fs=r(26494),Ks=r(88411),qs=r(92393);const Hs=o("ipfs:repo:gc"),Gs=(0,ie.notFoundError)().code,Vs=new se.Key("/local/filesroot");function Xs(e){let{gcLock:t,pins:r,blockstore:n,root:s,loadCodec:i}=e;return async function*(){const e=Date.now();Hs("Creating set of marked blocks");const o=await t.writeLock();try{const t=await async function(e){let{pins:t,blockstore:r,loadCodec:n,root:s}=e;const i=async function*(){let e;try{e=await s.get(Vs)}catch(i){if(i.code===Gs)return void Hs("No blocks in MFS");throw i}const t=X.CID.decode(e);yield t,yield*zs(t,r,n)}(),o=qs(Ht(t.recursiveKeys(),(e=>{let{cid:t}=e;return t})),t.indirectKeys(),Ht(t.directKeys(),(e=>{let{cid:t}=e;return t})),i),a=new Set;for await(const c of qs(o,i))a.add(de.base32.encode(c.multihash.bytes));return a}({pins:r,blockstore:n,root:s,loadCodec:i}),a=n.queryKeys({});yield*async function*(e,t,r){let{blockstore:n}=e,s=0,i=0;const o=async e=>async function(){s++;try{const s=de.base32.encode(e.multihash.bytes);if(t.has(s))return null;try{await n.delete(e),i++}catch(r){return{err:new Error(`Could not delete block with CID ${e}: ${r.message}`)}}return{cid:e}}catch(r){const t=`Could delete block with CID ${e}`;return Hs(t,r),{err:new Error(t+`: ${r.message}`)}}};yield*(0,Vt.pipe)(Ks(Ht(r,o),256),(e=>Gt(e,Boolean))),Hs(`Marked set has ${t.size} unique blocks. Blockstore has ${s} blocks. Deleted ${i} blocks.`)}({blockstore:n},t,a),Hs(`Complete (${Date.now()-e}ms)`)}finally{o()}}}const Js=o("ipfs:repo"),Zs=Number.MAX_SAFE_INTEGER;class Ys{constructor(e,t,r,n){if("string"!==typeof e)throw new Error("missing repo path");if("function"!==typeof t)throw new Error("missing codec loader");this.options=(0,s.Z)(Os,n),this.closed=!0,this.path=e,this.root=r.root,this.datastore=r.datastore,this.keys=r.keys;const i=r.blocks,o=r.pins;this.pins=new Ws({pinstore:o,blockstore:i,loadCodec:t});const c=(l=this.pins,u=i,{open:()=>u.open(),close:()=>u.close(),query:(e,t)=>u.query(e,t),queryKeys:(e,t)=>u.queryKeys(e,t),get:async(e,t)=>u.get(e,t),async*getMany(e,t){yield*u.getMany(e,t)},async put(e,t,r){await u.put(e,t,r)},async*putMany(e,t){yield*u.putMany(e,t)},has:(e,t)=>u.has(e,t),delete:async(e,t)=>(await $s(e,l),u.delete(e,t)),deleteMany:(e,t)=>u.deleteMany(Ht(e,(async e=>(await $s(e,l),e))),t),batch:()=>u.batch()});var l,u;this.blocks=function(e){return{open:()=>e.open(),close:()=>e.close(),query:(t,r)=>e.query(t,r),queryKeys:(t,r)=>e.queryKeys(t,r),async get(t,r){const n=Ts(t);return n.isIdentity?Promise.resolve(n.digest):e.get(t,r)},async*getMany(e,t){for await(const r of e)yield this.get(r,t)},async put(t,r,n){const{isIdentity:s}=Ts(t);s||await e.put(t,r,n)},async*putMany(t,r){const n=Cs();(globalThis.process&&globalThis.process.nextTick?globalThis.process.nextTick:globalThis.setImmediate||globalThis.setTimeout)((async()=>{try{await dt(e.putMany(async function*(){for await(const{key:e,value:r}of t)Ts(e).isIdentity||(yield{key:e,value:r}),n.push({key:e,value:r})}())),n.end()}catch(r){n.end(r)}})),yield*n},has(t,r){const{isIdentity:n}=Ts(t);return n?Promise.resolve(!0):e.has(t,r)},delete(t,r){const{isIdentity:n}=Ts(t);return n?Promise.resolve():e.delete(t,r)},deleteMany:(t,r)=>e.deleteMany(Gt(t,(e=>!Ts(e).isIdentity)),r),batch(){const t=e.batch();return{put(e,r){const{isIdentity:n}=Ts(e);n||t.put(e,r)},delete(e){const{isIdentity:r}=Ts(e);r||t.delete(e)},commit:e=>t.commit(e)}}}}(c),this.version=function(e){return{exists:async()=>bs(Es,e.has.bind(e),e),async get(){const t=await vs(Es,e.get.bind(e),e.has.bind(e),e);return parseInt((0,oe.toString)(t),10)},set:t=>e.put(Es,(0,O.fromString)(String(t))),async check(e){const t=await this.get();return ks("comparing version: %s and %s",t,e),t===e||6===t&&7===e||6===e&&7===t}}}(this.root),this.config=function(e){const t=new Is({concurrency:1}),r={async getAll(){const t=await vs(Ss,e.get.bind(e),e.has.bind(e),e);return JSON.parse((0,oe.toString)(t))},async get(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(null==e)throw new ys(`Key ${e} does not exist in config`);const r=await this.getAll(t),n=Qn(r,e);if(void 0===n)throw new ys(`Key ${e} does not exist in config`);return n},set(e,r){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("string"!==typeof e&&!(e instanceof String))throw a(new Error("Invalid key type: "+typeof e),"ERR_INVALID_KEY");if(void 0===r||r instanceof Uint8Array)throw a(new Error("Invalid value type: "+typeof r),"ERR_INVALID_VALUE");return t.add((()=>n({key:e,value:r},s.signal)))},replace(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!e||e instanceof Uint8Array)throw a(new Error("Invalid value type: "+typeof e),"ERR_INVALID_VALUE");return t.add((()=>n({key:void 0,value:e},r.signal)))},exists:async()=>bs(Ss,e.has.bind(e),e)};return r;async function n(e,t){if(t&&t.aborted)return;const n=e.key,i=e.value;if(n){const e=await r.getAll();return"object"===typeof e&&null!==e&&Er(e,n,i),s(e)}return s(i)}function s(t){const r=(0,O.fromString)(JSON.stringify(t,null,2));return e.put(Ss,r)}}(this.root),this.spec=function(e){return{exists:()=>e.has(As),async get(){const t=await e.get(As);return JSON.parse((0,oe.toString)(t))},set:async t=>e.put(As,(0,O.fromString)(JSON.stringify(Ps(t,{deep:!0}))))}}(this.root),this.apiAddr=function(e){return{async get(){const t=await e.get(Rs);return t&&t.toString()},set:t=>e.put(Rs,(0,O.fromString)(t.toString())),delete:()=>e.delete(Rs)}}(this.root),this.gcLock=Fs(e,{singleProcess:!1!==this.options.repoOwner}),this.gc=Xs({gcLock:this.gcLock,pins:this.pins,blockstore:this.blocks,root:this.root,loadCodec:t})}async init(e){var t;Js("initializing at: %s",this.path),await this._openRoot(),await this.config.replace((t=e,t.Datastore=Object.assign({},Ls,Qn(t,"datastore")),t)),await this.spec.set(function(e){const t={...Ls.Spec,...Qn(e,"Datastore.Spec")};return{type:t.type,mounts:t.mounts.map((e=>({mountpoint:e.mountpoint,type:e.child.type,path:e.child.path,shardFunc:e.child.shardFunc})))}}(e)),await this.version.set(Xn._)}async isInitialized(){if(!this.closed)return!0;try{return await this._openRoot(),await this._checkInitialized(),await this.root.close(),!0}catch(e){return!1}}async open(){if(!this.closed)throw a(new Error("repo is already open"),"ERR_REPO_ALREADY_OPEN");Js("opening at: %s",this.path);try{await this._openRoot(),await this._checkInitialized(),this._lockfile=await this._openLock(),Js("acquired repo.lock");if(!await this.version.check(Xn._)){if(!await this._isAutoMigrationEnabled())throw new ms("Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.");await this._migrate(Xn._,{root:this.root,datastore:this.datastore,pins:this.pins.pinstore,blocks:this.pins.blockstore,keys:this.keys})}Js("creating datastore"),await this.datastore.open(),Js("creating blocks"),await this.blocks.open(),Js("creating keystore"),await this.keys.open(),Js("creating pins"),await this.pins.pinstore.open(),this.closed=!1,Js("all opened")}catch(e){if(this._lockfile)try{await this._closeLock(),this._lockfile=null}catch(t){Js("error removing lock",t)}throw e}}async _openRoot(){try{await this.root.open()}catch(e){if("Already open"!==e.message)throw e}}async _openLock(){const e=await this.options.repoLock.lock(this.path);if("function"!==typeof e.close)throw a(new Error("Locks must have a close method"),"ERR_NO_CLOSE_FUNCTION");return e}_closeLock(){return this._lockfile&&this._lockfile.close()}async _checkInitialized(){let e;Js("init check");try{[e]=await Promise.all([this.config.exists(),this.spec.exists(),this.version.exists()])}catch(t){if("ERR_NOT_FOUND"===t.code)throw a(new Error("repo is not initialized yet"),ws,{path:this.path});throw t}if(!e)throw a(new Error("repo is not initialized yet"),ws,{path:this.path})}async close(){if(this.closed)throw a(new Error("repo is already closed"),"ERR_REPO_ALREADY_CLOSED");Js("closing at: %s",this.path);try{await this.apiAddr.delete()}catch(e){if(e.code!==ws&&!e.message.startsWith("ENOENT"))throw e}await Promise.all([this.root,this.blocks,this.keys,this.datastore,this.pins.pinstore].map((e=>e&&e.close()))),Js("unlocking"),this.closed=!0,await this._closeLock()}exists(){return this.version.exists()}async stat(){if(this.datastore&&this.keys){const[e,t,r,n,s]=await Promise.all([this._storageMaxStat(),this._blockStat(),this.version.get(),Qs(this.datastore),Qs(this.keys)]),i=t.size+n+s;return{repoPath:this.path,storageMax:e,version:r,numObjects:t.count,repoSize:i}}throw a(new Error("repo is not initialized yet"),ws,{path:this.path})}async _isAutoMigrationEnabled(){if(void 0!==this.options.autoMigrate)return this.options.autoMigrate;let e;try{e=await this.config.get("repoAutoMigrate")}catch(t){if(t.code!==ys.code)throw t;e=!0}return e}async _migrate(e,t){return await this.version.get()>e?(Js(`reverting to version ${e}`),async function(e,t,r,n,s){let{ignoreLock:i=!1,onProgress:o,isDryRun:a=!1,migrations:c}=s;if(c=c||os,!e)throw new ps.RequiredParameterError("Path argument is required!");if(!r)throw new ps.RequiredParameterError("repoOptions argument is required!");if(!n)throw new ps.RequiredParameterError("When reverting migrations, you have to specify to which version to revert!");if(!Number.isInteger(n)||n<=0)throw new ps.InvalidValueError("Version has to be positive integer!");t=(0,ls.pf)(t);const l=await as.b(t);if(l===n)return void us("Nothing to revert.");if(l<n)throw new ps.InvalidValueError(`Current repo's version (${l}) is lower then toVersion (${n}), you probably wanted to migrate it?`);let u;hs(c,n,l,!0),a||i||(u=await r.repoLock.lock(e)),us(`Reverting from version ${l} to ${n}`);try{const e=c.slice().reverse();for(const r of e){if(r.version<=n)break;if(!(r.version>l)){us(`Reverting migration version ${r.version}`);try{if(!a){let e=()=>{};o&&(e=(e,t)=>o(r.version,e.toFixed(2),t)),await r.revert(t,e)}}catch(d){const e=r.version;throw us(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${e}`),await as.x(e,t),d.message=`During reversion to version ${r.version} exception was raised: ${d.message}`,d}us(`Reverting to version ${r.version} finished`)}}a||await as.x(n,t),us(`All migrations successfully reverted to version ${n}!`)}finally{a||i||!u||await u.close()}}(this.path,t,this.options,e,{ignoreLock:!0,onProgress:this.options.onMigrationProgress})):(Js(`migrating to version ${e}`),ds(this.path,t,this.options,e,{ignoreLock:!0,onProgress:this.options.onMigrationProgress}))}async _storageMaxStat(){try{const e=await this.config.get("Datastore.StorageMax");return BigInt(fs(e))}catch(e){return BigInt(Zs)}}async _blockStat(){let e=BigInt(0),t=BigInt(0);if(this.blocks)for await(const{key:r,value:n}of this.blocks.query({}))e+=BigInt(1),t+=BigInt(n.byteLength),t+=BigInt(r.bytes.byteLength);return{count:e,size:t}}}async function Qs(e){let t=BigInt(0);for await(const r of e.query({}))t+=BigInt(r.value.byteLength),t+=BigInt(r.key.uint8Array().byteLength);return t}var ei=r(62550),ti=r(91703),ri=r(77420);class ni extends et.BaseDatastore{constructor(e,t){super(),this.path=e,this.opts=t,t&&t.db?(this.database=t.db,delete t.db):this.database=ri}_initDb(){return new Promise(((e,t)=>{this.db=this.database(this.path,{...this.opts,valueEncoding:"binary",compression:!1},(r=>{if(r)return t(r);e(this.db)}))}))}async open(){try{this.db?await this.db.open():this.db=await this._initDb()}catch(e){throw et.Errors.dbOpenFailedError(e)}}async put(e,t){try{await this.db.put(e.toString(),t)}catch(r){throw et.Errors.dbWriteFailedError(r)}}async get(e){let t;try{t=await this.db.get(e.toString())}catch(r){if(r.notFound)throw et.Errors.notFoundError(r);throw et.Errors.dbWriteFailedError(r)}return t}async has(e){try{await this.db.get(e.toString())}catch(t){if(t.notFound)return!1;throw t}return!0}async delete(e){try{await this.db.del(e.toString())}catch(t){throw et.Errors.dbDeleteFailedError(t)}}close(){return this.db&&this.db.close()}batch(){const e=[];return{put:(t,r)=>{e.push({type:"put",key:t.toString(),value:r})},delete:t=>{e.push({type:"del",key:t.toString()})},commit:()=>this.db.batch(e)}}query(e){let t=this._query({values:!0,prefix:e.prefix});Array.isArray(e.filters)&&(t=e.filters.reduce(((e,t)=>Gt(e,t)),t)),Array.isArray(e.orders)&&(t=e.orders.reduce(((e,t)=>ti(e,t)),t));const{offset:r,limit:n}=e;if(r){let e=0;t=Gt(t,(()=>e++>=r))}return n&&(t=ei(t,n)),t}queryKeys(e){let t=Ht(this._query({values:!1,prefix:e.prefix}),(e=>{let{key:t}=e;return t}));Array.isArray(e.filters)&&(t=e.filters.reduce(((e,t)=>Gt(e,t)),t)),Array.isArray(e.orders)&&(t=e.orders.reduce(((e,t)=>ti(e,t)),t));const{offset:r,limit:n}=e;if(r){let e=0;t=Gt(t,(()=>e++>=r))}return n&&(t=ei(t,n)),t}_query(e){const t={keys:!0,keyAsBuffer:!0,values:e.values};if(null!=e.prefix){const r=e.prefix.toString();t.gte=r,t.lt=r+"\xff"}return r=this.db.iterator(t),{[Symbol.asyncIterator]:()=>({next:()=>new Promise(((e,t)=>{r.next(((n,s,i)=>n?t(n):null==s?r.end((r=>{if(r)return t(r);e({done:!0,value:void 0})})):void e({done:!1,value:{key:new Qe.s(s,!1),value:i}})))})),return:()=>new Promise(((e,t)=>{r.end((r=>{if(r)return t(r);e({done:!0,value:void 0})}))}))})};var r}}var si=r(8511);function ii(e){const t=X.CID.asCID(e);if(!t)throw a(new Error("Not a valid cid"),"ERR_INVALID_CID");return new se.Key("/"+de.base32.encode(t.multihash.bytes).slice(1).toUpperCase(),!1)}function oi(e){return X.CID.createV1(Xr.code,ue.decode(de.base32.decode("b"+e.toString().slice(1).toLowerCase())))}function ai(e){const t=e.substring(0,1);if("/"===t)return ai(e.substring(1));let r,n;r="b"===t.toLowerCase()?e=>de.base32.decode(e.toLowerCase()).subarray(2):"c"===t.toLowerCase()?e=>de.base32pad.decode(e.toLowerCase()).subarray(2):"z"===t?e=>Ye.base58btc.decode(e).subarray(2):"Q"===t?e=>Ye.base58btc.decode("z"+e):e=>de.base32.decode("b"+e.toLowerCase()).subarray(2);for(let o=1;o<e.length;o++)try{n=r(e.substring(0,o))}catch(i){if("Unexpected end of data"!==i.message)throw i}let s="/C";return n&&(s=`/${de.base32.encode(n).slice(1,-1).toUpperCase()||"C"}`),s}class ci extends si.E{constructor(e){super(),this.child=e}open(){return this.child.open()}close(){return this.child.close()}async*query(e,t){for await(const{key:r,value:n}of this.child.query(function(e){return{...e,prefix:e.prefix?ai(e.prefix):void 0,filters:e.filters?e.filters.map((e=>t=>e({key:oi(t.key),value:t.value}))):void 0,orders:e.orders?e.orders.map((e=>(t,r)=>e({key:oi(t.key),value:t.value},{key:oi(r.key),value:r.value}))):void 0}}(e),t))yield{key:oi(r),value:n}}async*queryKeys(e,t){for await(const r of this.child.queryKeys(function(e){return{...e,prefix:e.prefix?ai(e.prefix):void 0,filters:e.filters?e.filters.map((e=>t=>e(oi(t)))):void 0,orders:e.orders?e.orders.map((e=>(t,r)=>e(oi(t),oi(r)))):void 0}}(e),t))yield oi(r)}async get(e,t){return this.child.get(ii(e),t)}async*getMany(e,t){for await(const r of e)yield this.get(r,t)}async put(e,t,r){await this.child.put(ii(e),t,r)}async*putMany(e,t){const r=Cs();(globalThis.process&&globalThis.process.nextTick?globalThis.process.nextTick:globalThis.setImmediate||globalThis.setTimeout)((async()=>{try{const n=this.child;await dt(this.child.putMany(async function*(){for await(const s of e){const e=ii(s.key);await n.has(e,t)||(yield{key:e,value:s.value}),r.push(s)}}())),r.end()}catch(n){r.end(n)}})),yield*r}has(e,t){return this.child.has(ii(e),t)}delete(e,t){return this.child.delete(ii(e),t)}deleteMany(e,t){const r=Cs();return dt(this.child.deleteMany(async function*(){for await(const t of e)yield ii(t),r.push(t);r.end()}(),t)).catch((e=>{r.end(e)})),r}}function li(e,t,r){const n=r.path||"ipfs";return function(e,t,r,n){return new Ys(e,t,r,n)}(n,(e=>t.getCodec(e)),{root:new ni(n,{prefix:"",version:2}),blocks:new ci(new ni(`${n}/blocks`,{prefix:"",version:2})),datastore:new ni(`${n}/datastore`,{prefix:"",version:2}),keys:new ni(`${n}/keys`,{prefix:"",version:2}),pins:new ni(`${n}/pins`,{prefix:"",version:2})},{autoMigrate:r.autoMigrate,onMigrationProgress:r.onMigrationProgress||e,repoLock:Ns})}var ui=r(97153);const di={gossipsub:ui};var hi=r(55585),pi=r(8711),fi=r(48140),gi=r(80425),yi=r(73790),mi=r(70732),wi=r(39541);const bi=(0,mi.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await(await e.post("bitswap/wantlist",{signal:t.signal,searchParams:(0,wi.X)(t),headers:t.headers})).json();return(r.Keys||[]).map((e=>X.CID.parse(e["/"])))})),vi=(0,mi.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await(await e.post("bitswap/wantlist",{signal:r.signal,searchParams:(0,wi.X)({...r,peer:t.toString()}),headers:r.headers})).json();return(n.Keys||[]).map((e=>X.CID.parse(e["/"])))})),_i=(0,mi.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("bitswap/stat",{searchParams:(0,wi.X)(t),signal:t.signal,headers:t.headers});return ki(await r.json())}));function ki(e){return{provideBufLen:e.ProvideBufLen,wantlist:(e.Wantlist||[]).map((e=>X.CID.parse(e["/"]))),peers:e.Peers||[],blocksReceived:BigInt(e.BlocksReceived),dataReceived:BigInt(e.DataReceived),blocksSent:BigInt(e.BlocksSent),dataSent:BigInt(e.DataSent),dupBlksReceived:BigInt(e.DupBlksReceived),dupDataReceived:BigInt(e.DupDataReceived)}}const Ei=(0,mi.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("bitswap/unwant",{signal:r.signal,searchParams:(0,wi.X)({arg:t.toString(),...r}),headers:r.headers});return n.json()}));function Ii(e){return{wantlist:bi(e),wantlistForPeer:vi(e),unwant:Ei(e),stat:_i(e)}}const Si=(0,mi.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("block/get",{signal:r.signal,searchParams:(0,wi.X)({arg:t.toString(),...r}),headers:r.headers});return new Uint8Array(await n.arrayBuffer())}));var Pi=r(6555),Ai=r(71696);async function Ri(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const n=[],s=new FormData;let i=0,o=0;for await(const{content:a,path:c,mode:l,mtime:u}of(0,Pi.f)(e)){let e="";i>0&&(e=`-${i}`);let t=(a?"file":"dir")+e;const r=[];if(null!==l&&void 0!==l&&r.push(`mode=${(0,Ai.Q)(l)}`),null!=u){const{secs:e,nsecs:t}=u;r.push(`mtime=${e}`),null!=t&&r.push(`mtime-nsecs=${t}`)}if(r.length&&(t=`${t}?${r.join("&")}`),a){s.set(t,a,null!=c?encodeURIComponent(c):void 0);const e=o+a.size;n.push({name:c,start:o,end:e}),o=e}else{if(null==c)throw new Error("path or content or both must be set");s.set(t,new File([""],encodeURIComponent(c),{type:"application/x-directory"}))}i++}return{total:o,parts:n,headers:r,body:s}}function Ci(e){return e.filter(Boolean)}function Ti(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return(0,Ct.anySignal)(Ci(t))}const Di=(0,mi.j)((e=>async function t(r){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const s=new AbortController,i=Ti(s.signal,n.signal);let o;try{const t=await e.post("block/put",{signal:i,searchParams:(0,wi.X)(n),...await Ri([r],s,n.headers)});o=await t.json()}catch(a){if("dag-pb"===n.format)return t(r,{...n,format:"protobuf"});if("dag-cbor"===n.format)return t(r,{...n,format:"cbor"});throw a}return X.CID.parse(o.Key)})),Bi=(0,mi.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};Array.isArray(t)||(t=[t]);const n=await e.post("block/rm",{signal:r.signal,searchParams:(0,wi.X)({arg:t.map((e=>e.toString())),"stream-channels":!0,...r}),headers:r.headers});for await(const e of n.ndjson())yield xi(e)}));function xi(e){const t={cid:X.CID.parse(e.Hash)};return e.Error&&(t.error=new Error(e.Error)),t}const Ni=(0,mi.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("block/stat",{signal:r.signal,searchParams:(0,wi.X)({arg:t.toString(),...r}),headers:r.headers}),s=await n.json();return{cid:X.CID.parse(s.Key),size:s.Size}}));function Oi(e){return{get:Si(e),put:Di(e),rm:Bi(e),stat:Ni(e)}}const Li=(0,mi.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("bootstrap/add",{signal:r.signal,searchParams:(0,wi.X)({arg:t,...r}),headers:r.headers}),{Peers:s}=await n.json();return{Peers:s.map((e=>new $t.Multiaddr(e)))}})),Mi=(0,mi.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("bootstrap/rm",{signal:t.signal,searchParams:(0,wi.X)({...t,all:!0}),headers:t.headers}),{Peers:n}=await r.json();return{Peers:n.map((e=>new $t.Multiaddr(e)))}})),ji=(0,mi.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("bootstrap/list",{signal:t.signal,searchParams:(0,wi.X)(t),headers:t.headers}),{Peers:n}=await r.json();return{Peers:n.map((e=>new $t.Multiaddr(e)))}})),Ui=(0,mi.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("bootstrap/add",{signal:t.signal,searchParams:(0,wi.X)({...t,default:!0}),headers:t.headers}),{Peers:n}=await r.json();return{Peers:n.map((e=>new $t.Multiaddr(e)))}})),zi=(0,mi.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("bootstrap/rm",{signal:r.signal,searchParams:(0,wi.X)({arg:t,...r}),headers:r.headers}),{Peers:s}=await n.json();return{Peers:s.map((e=>new $t.Multiaddr(e)))}}));function Wi(e){return{add:Li(e),clear:Mi(e),list:ji(e),reset:Ui(e),rm:zi(e)}}const $i=(0,mi.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("config/profile/apply",{signal:r.signal,searchParams:(0,wi.X)({arg:t,...r}),headers:r.headers}),s=await n.json();return{original:s.OldCfg,updated:s.NewCfg}}));var Fi=r(92670);const Ki=(0,mi.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("config/profile/list",{signal:t.signal,searchParams:(0,wi.X)(t),headers:t.headers}),n=await r.json();return n.map((e=>(0,Fi.C)(e)))}));function qi(e){return{apply:$i(e),list:Ki(e)}}const Hi=(0,mi.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!t)throw new Error("key argument is required");const n=await e.post("config",{signal:r.signal,searchParams:(0,wi.X)({arg:t,...r}),headers:r.headers}),s=await n.json();return s.Value})),Gi=(0,mi.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("config/show",{signal:t.signal,searchParams:(0,wi.X)({...t}),headers:t.headers}),n=await r.json();return n})),Vi=(0,mi.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=new AbortController,s=Ti(n.signal,r.signal),i=await e.post("config/replace",{signal:s,searchParams:(0,wi.X)(r),...await Ri([(0,O.fromString)(JSON.stringify(t))],n,r.headers)});await i.text()})),Xi=(0,mi.j)((e=>async function(t,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("string"!==typeof t)throw new Error("Invalid key type");const s={...n,...Ji(t,r)},i=await e.post("config",{signal:n.signal,searchParams:(0,wi.X)(s),headers:n.headers});await i.text()})),Ji=(e,t)=>{switch(typeof t){case"boolean":return{arg:[e,t.toString()],bool:!0};case"string":return{arg:[e,t]};default:return{arg:[e,JSON.stringify(t)],json:!0}}};function Zi(e){return{getAll:Gi(e),get:Hi(e),set:Xi(e),replace:Vi(e),profiles:qi(e)}}const Yi=(0,mi.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("dag/export",{signal:r.signal,searchParams:(0,wi.X)({arg:t.toString()}),headers:r.headers});yield*n.iterator()}));async function*Qi(e,t,r,n,s){const i=async e=>{const t=await r.getCodec(e.code),i=await n(e,s);return t.decode(i)},o=t.split("/").filter(Boolean);let c=await i(e),l=e;for(;o.length;){const e=o.shift();if(!e)throw a(new Error(`Could not resolve path "${t}"`),"ERR_INVALID_PATH");if(!Object.prototype.hasOwnProperty.call(c,e))throw a(new Error(`no link named "${e}" under ${l}`),"ERR_NO_LINK");c=c[e],yield{value:c,remainderPath:o.join("/")};const r=X.CID.asCID(c);r&&(l=r,c=await i(c))}yield{value:c,remainderPath:""}}const eo=(e,t)=>{const r=(0,mi.j)(((t,r)=>{const n=Si(r);return async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(r.path){const s=r.localResolve?await tn(Qi(t,r.path,e,n,r)):await Y(Qi(t,r.path,e,n,r));if(!s)throw a(new Error("Not found"),"ERR_NOT_FOUND");return s}const s=await e.getCodec(t.code),i=await n(t,r),o=s.decode(i);return{value:o,remainderPath:""}}}));return r(t)},to=(0,mi.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=new AbortController,s=Ti(n.signal,r.signal),{headers:i,body:o}=await Ri(t,n,r.headers),a=await e.post("dag/import",{signal:s,headers:i,body:o,searchParams:(0,wi.X)({"pin-roots":r.pinRoots})});for await(const{Root:e}of a.ndjson())if(void 0!==e){const{Cid:{"/":t},PinErrorMsg:r}=e;yield{root:{cid:X.CID.parse(t),pinErrorMsg:r}}}})),ro=(e,t)=>{const r=(0,mi.j)((t=>async function(r){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const s={storeCodec:"dag-cbor",hashAlg:"sha2-256",...n};let i;if(s.inputCodec){if(!(r instanceof Uint8Array))throw new Error("Can only inputCodec on raw bytes that can be decoded");i=r}else{i=(await e.getCodec(s.storeCodec)).encode(r),s.inputCodec=s.storeCodec}const o=new AbortController,a=Ti(o.signal,s.signal),c=await t.post("dag/put",{timeout:s.timeout,signal:a,searchParams:(0,wi.X)(s),...await Ri([i],o,s.headers)}),l=await c.json();return X.CID.parse(l.Cid["/"])}));return r(t)},no=(0,mi.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("dag/resolve",{signal:r.signal,searchParams:(0,wi.X)({arg:`${t}${r.path?`/${r.path}`.replace(/\/[/]+/g,"/"):""}`,...r}),headers:r.headers}),s=await n.json();return{cid:X.CID.parse(s.Cid["/"]),remainderPath:s.RemPath}}));function so(e,t){return{export:Yi(t),get:eo(e,t),import:to(t),put:ro(e,t),resolve:no(t)}}var io=r(43592);const oo=(0,mi.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("dht/findpeer",{signal:r.signal,searchParams:(0,wi.X)({arg:t,...r}),headers:r.headers});for await(const e of n.ndjson())yield(0,io.A)(e)})),ao=(0,mi.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("dht/findprovs",{signal:r.signal,searchParams:(0,wi.X)({arg:t.toString(),...r}),headers:r.headers});for await(const e of n.ndjson())yield(0,io.A)(e)})),co=(0,mi.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("dht/get",{signal:r.signal,searchParams:(0,wi.X)({arg:t instanceof Uint8Array?(0,oe.toString)(t):t.toString(),...r}),headers:r.headers});for await(const e of n.ndjson())yield(0,io.A)(e)})),lo=(0,mi.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{recursive:!1};const n=Array.isArray(t)?t:[t],s=await e.post("dht/provide",{signal:r.signal,searchParams:(0,wi.X)({arg:n.map((e=>e.toString())),...r}),headers:r.headers});for await(const e of s.ndjson())yield(0,io.A)(e)})),uo=(0,mi.j)((e=>async function*(t,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=new AbortController,i=Ti(s.signal,n.signal),o=await e.post("dht/put",{signal:i,searchParams:(0,wi.X)({arg:t instanceof Uint8Array?(0,oe.toString)(t):t.toString(),...n}),...await Ri([r],s,n.headers)});for await(const e of o.ndjson())yield(0,io.A)(e)})),ho=(0,mi.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("dht/query",{signal:r.signal,searchParams:(0,wi.X)({arg:t.toString(),...r}),headers:r.headers});for await(const e of n.ndjson())yield(0,io.A)(e)}));function po(e){return{findPeer:oo(e),findProvs:ao(e),get:co(e),provide:lo(e),put:uo(e),query:ho(e)}}const fo=(0,mi.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("diag/cmds",{signal:t.signal,searchParams:(0,wi.X)(t),headers:t.headers});return r.json()})),go=(0,mi.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("diag/net",{signal:t.signal,searchParams:(0,wi.X)(t),headers:t.headers});return r.json()})),yo=(0,mi.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("diag/sys",{signal:t.signal,searchParams:(0,wi.X)(t),headers:t.headers});return r.json()}));function mo(e){return{cmds:fo(e),net:go(e),sys:yo(e)}}const wo=(0,mi.j)((e=>async function(t,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=await e.post("files/chmod",{signal:n.signal,searchParams:(0,wi.X)({arg:t,mode:r,...n}),headers:n.headers});await s.text()})),bo=(0,mi.j)((e=>async function(t,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=Array.isArray(t)?t:[t],i=await e.post("files/cp",{signal:n.signal,searchParams:(0,wi.X)({arg:s.concat(r).map((e=>X.CID.asCID(e)?`/ipfs/${e}`:e)),...n}),headers:n.headers});await i.text()})),vo=(0,mi.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!t||"string"!==typeof t)throw new Error("ipfs.files.flush requires a path");const n=await e.post("files/flush",{signal:r.signal,searchParams:(0,wi.X)({arg:t,...r}),headers:r.headers}),s=await n.json();return X.CID.parse(s.Cid)}));var _o=r(1611);const ko=(0,mi.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!t)throw new Error("ipfs.files.ls requires a path");const n=await e.post("files/ls",{signal:r.signal,searchParams:(0,wi.X)({arg:X.CID.asCID(t)?`/ipfs/${t}`:t,long:!0,...r,stream:!0}),headers:r.headers});for await(const e of n.ndjson())if("Entries"in e)for(const t of e.Entries||[])yield Eo((0,_o.c)(t));else yield Eo((0,_o.c)(e))}));function Eo(e){return e.hash&&(e.cid=X.CID.parse(e.hash)),delete e.hash,e.type=1===e.type?"directory":"file",e}const Io=(0,mi.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("files/mkdir",{signal:r.signal,searchParams:(0,wi.X)({arg:t,...r}),headers:r.headers});await n.text()})),So=(0,mi.j)((e=>async function(t,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Array.isArray(t)||(t=[t]);const s=await e.post("files/mv",{signal:n.signal,searchParams:(0,wi.X)({arg:t.concat(r),...n}),headers:n.headers});await s.text()}));var Po=r(84001);const Ao=(0,mi.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("files/read",{signal:r.signal,searchParams:(0,wi.X)({arg:t,count:r.length,...r}),headers:r.headers});yield*Po(n.body)})),Ro=(0,mi.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("files/rm",{signal:r.signal,searchParams:(0,wi.X)({arg:t,...r}),headers:r.headers}),s=await n.text();if(""!==s){const e=new z.HTTPError(n);throw e.message=s,e}})),Co=(0,mi.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("files/stat",{signal:r.signal,searchParams:(0,wi.X)({arg:t,...r}),headers:r.headers}),s=await n.json();return s.WithLocality=s.WithLocality||!1,To((0,_o.c)(s))}));function To(e){return e.cid=X.CID.parse(e.hash),delete e.hash,e}const Do=(0,mi.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("files/touch",{signal:r.signal,searchParams:(0,wi.X)({arg:t,...r}),headers:r.headers});await n.text()}));var Bo=r(15059),xo=r(13068);const No=(0,mi.j)((e=>async function(t,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=new AbortController,i=Ti(s.signal,n.signal),o=await e.post("files/write",{signal:i,searchParams:(0,wi.X)({arg:t,streamChannels:!0,count:n.length,...n}),...await Ri([{content:r,path:"arg",mode:(0,Bo.Q)(n.mode),mtime:(0,xo.X)(n.mtime)}],s,n.headers)});await o.text()}));function Oo(e){return{chmod:wo(e),cp:bo(e),flush:vo(e),ls:ko(e),mkdir:Io(e),mv:So(e),read:Ao(e),rm:Ro(e),stat:Co(e),touch:Do(e),write:No(e)}}const Lo=(0,mi.j)((e=>async function(e,t){throw a(new Error("Not implemented"),"ERR_NOT_IMPLEMENTED")})),Mo=(0,mi.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{type:"rsa",size:2048};const n=await e.post("key/gen",{signal:r.signal,searchParams:(0,wi.X)({arg:t,...r}),headers:r.headers}),s=await n.json();return(0,Fi.C)(s)})),jo=(0,mi.j)((e=>async function(t,r,n){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const i=await e.post("key/import",{signal:s.signal,searchParams:(0,wi.X)({arg:t,pem:r,password:n,...s}),headers:s.headers}),o=await i.json();return(0,Fi.C)(o)})),Uo=(0,mi.j)((e=>async function(e){throw a(new Error("Not implemented"),"ERR_NOT_IMPLEMENTED")})),zo=(0,mi.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("key/list",{signal:t.signal,searchParams:(0,wi.X)(t),headers:t.headers}),n=await r.json();return(n.Keys||[]).map((e=>(0,Fi.C)(e)))})),Wo=(0,mi.j)((e=>async function(t,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=await e.post("key/rename",{signal:n.signal,searchParams:(0,wi.X)({arg:[t,r],...n}),headers:n.headers});return(0,Fi.C)(await s.json())})),$o=(0,mi.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("key/rm",{signal:r.signal,searchParams:(0,wi.X)({arg:t,...r}),headers:r.headers}),s=await n.json();return(0,Fi.C)(s.Keys[0])}));function Fo(e){return{export:Lo(e),gen:Mo(e),import:jo(e),info:Uo(e),list:zo(e),rename:Wo(e),rm:$o(e)}}const Ko=(0,mi.j)((e=>async function(t,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=await e.post("log/level",{signal:n.signal,searchParams:(0,wi.X)({arg:[t,r],...n}),headers:n.headers});return(0,Fi.C)(await s.json())})),qo=(0,mi.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("log/ls",{signal:t.signal,searchParams:(0,wi.X)(t),headers:t.headers}),n=await r.json();return n.Strings})),Ho=(0,mi.j)((e=>async function*(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("log/tail",{signal:t.signal,searchParams:(0,wi.X)(t),headers:t.headers});yield*r.ndjson()}));function Go(e){return{level:Ko(e),ls:qo(e),tail:Ho(e)}}const Vo=(0,mi.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("name/publish",{signal:r.signal,searchParams:(0,wi.X)({arg:`${t}`,...r}),headers:r.headers});return(0,Fi.C)(await n.json())})),Xo=(0,mi.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("name/resolve",{signal:r.signal,searchParams:(0,wi.X)({arg:t,stream:!0,...r}),headers:r.headers});for await(const e of n.ndjson())yield e.Path})),Jo=(0,mi.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("name/pubsub/cancel",{signal:r.signal,searchParams:(0,wi.X)({arg:t,...r}),headers:r.headers});return(0,Fi.C)(await n.json())})),Zo=(0,mi.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("name/pubsub/state",{signal:t.signal,searchParams:(0,wi.X)(t),headers:t.headers});return(0,Fi.C)(await r.json())})),Yo=(0,mi.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("name/pubsub/subs",{signal:t.signal,searchParams:(0,wi.X)(t),headers:t.headers}),n=await r.json();return n.Strings||[]}));function Qo(e){return{cancel:Jo(e),state:Zo(e),subs:Yo(e)}}function ea(e){return{publish:Vo(e),resolve:Xo(e),pubsub:Qo(e)}}const ta=(0,mi.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("object/data",{signal:r.signal,searchParams:(0,wi.X)({arg:`${t instanceof Uint8Array?X.CID.decode(t):t}`,...r}),headers:r.headers}),s=await n.arrayBuffer();return new Uint8Array(s,0,s.byteLength)})),ra=(0,mi.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("object/get",{signal:r.signal,searchParams:(0,wi.X)({arg:`${t instanceof Uint8Array?X.CID.decode(t):t}`,dataEncoding:"base64",...r}),headers:r.headers}),s=await n.json();return{Data:(0,O.fromString)(s.Data,"base64pad"),Links:(s.Links||[]).map((e=>({Name:e.Name,Hash:X.CID.parse(e.Hash),Tsize:e.Size})))}})),na=(0,mi.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("object/links",{signal:r.signal,searchParams:(0,wi.X)({arg:`${t instanceof Uint8Array?X.CID.decode(t):t}`,...r}),headers:r.headers}),s=await n.json();return(s.Links||[]).map((e=>({Name:e.Name,Tsize:e.Size,Hash:X.CID.parse(e.Hash)})))})),sa=(0,mi.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("object/new",{signal:t.signal,searchParams:(0,wi.X)({arg:t.template,...t}),headers:t.headers}),{Hash:n}=await r.json();return X.CID.parse(n)})),ia=(e,t)=>{const r=(0,mi.j)((r=>{const n=ro(e,t);return async function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return n(e,{...t,storeCodec:"dag-pb",hashAlg:"sha2-256",version:1})}}));return r(t)},oa=(0,mi.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("object/stat",{signal:r.signal,searchParams:(0,wi.X)({arg:`${t}`,...r}),headers:r.headers}),s=await n.json();return{...s,Hash:X.CID.parse(s.Hash)}})),aa=(0,mi.j)((e=>async function(t,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=await e.post("object/patch/add-link",{signal:n.signal,searchParams:(0,wi.X)({arg:[`${t}`,r.Name||r.name||"",(r.Hash||r.cid||"").toString()||null],...n}),headers:n.headers}),{Hash:i}=await s.json();return X.CID.parse(i)})),ca=(0,mi.j)((e=>async function(t,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=new AbortController,i=Ti(s.signal,n.signal),o=await e.post("object/patch/append-data",{signal:i,searchParams:(0,wi.X)({arg:`${t}`,...n}),...await Ri([r],s,n.headers)}),{Hash:a}=await o.json();return X.CID.parse(a)})),la=(0,mi.j)((e=>async function(t,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=await e.post("object/patch/rm-link",{signal:n.signal,searchParams:(0,wi.X)({arg:[`${t}`,r.Name||r.name||null],...n}),headers:n.headers}),{Hash:i}=await s.json();return X.CID.parse(i)})),ua=(0,mi.j)((e=>async function(t,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=new AbortController,i=Ti(s.signal,n.signal),o=await e.post("object/patch/set-data",{signal:i,searchParams:(0,wi.X)({arg:[`${t}`],...n}),...await Ri([r],s,n.headers)}),{Hash:a}=await o.json();return X.CID.parse(a)}));function da(e){return{addLink:aa(e),appendData:ca(e),rmLink:la(e),setData:ua(e)}}function ha(e,t){return{data:ta(t),get:ra(t),links:na(t),new:sa(t),put:ia(e,t),stat:oa(t),patch:da(t)}}const pa=(0,mi.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};for await(const{path:n,recursive:s,metadata:i}of Q(t)){const t=await e.post("pin/add",{signal:r.signal,searchParams:(0,wi.X)({...r,arg:n,recursive:s,metadata:i?JSON.stringify(i):void 0,stream:!0}),headers:r.headers});for await(const e of t.ndjson())if(e.Pins)for(const t of e.Pins)yield X.CID.parse(t);else yield X.CID.parse(e)}}));function fa(e){const t=pa(e);return(0,mi.j)((()=>async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Y(t([{path:e,...r}],r))}))(e)}function ga(e,t,r){const n={type:e,cid:X.CID.parse(t)};return r&&(n.metadata=r),n}const ya=(0,mi.j)((e=>async function*(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=[];t.paths&&(r=Array.isArray(t.paths)?t.paths:[t.paths]);const n=await e.post("pin/ls",{signal:t.signal,searchParams:(0,wi.X)({...t,arg:r.map((e=>`${e}`)),stream:!0}),headers:t.headers});for await(const e of n.ndjson()){if(e.Keys){for(const t of Object.keys(e.Keys))yield ga(e.Keys[t].Type,t,e.Keys[t].Metadata);return}yield ga(e.Type,e.Cid,e.Metadata)}})),ma=(0,mi.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};for await(const{path:n,recursive:s}of Q(t)){const t=new URLSearchParams(r.searchParams);t.append("arg",`${n}`),null!=s&&t.set("recursive",String(s));const i=await e.post("pin/rm",{signal:r.signal,headers:r.headers,searchParams:(0,wi.X)({...r,arg:`${n}`,recursive:s})});for await(const e of i.ndjson())e.Pins?yield*e.Pins.map((e=>X.CID.parse(e))):yield X.CID.parse(e)}})),wa=e=>{const t=ma(e);return(0,mi.j)((()=>async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Y(t([{path:e,...r}],r))}))(e)};var ba=r(44190);const va=e=>{let{Name:t,Status:r,Cid:n}=e;return{cid:X.CID.parse(n),name:t,status:r}},_a=e=>{if("string"===typeof e&&""!==e)return e;throw new TypeError("service name must be passed")},ka=e=>{if(X.CID.asCID(e))return e.toString();throw new TypeError("CID instance expected instead of "+typeof e)},Ea=e=>{let{service:t,cid:r,name:n,status:s,all:i}=e;const o=(0,wi.X)({service:_a(t),name:n,force:!!i||void 0});if(r)for(const a of r)o.append("cid",ka(a));if(s)for(const a of s)o.append("status",a);return o},Ia=e=>{let{cid:t,service:r,background:n,name:s,origins:i}=e;const o=(0,wi.X)({arg:ka(t),service:_a(r),name:s,background:!!n||void 0});if(i)for(const a of i)o.append("origin",a.toString());return o};function Sa(e){return async function(t,r){let{timeout:n,signal:s,headers:i,...o}=r;const a=await e.post("pin/remote/add",{timeout:n,signal:s,headers:i,searchParams:Ia({cid:t,...o})});return va(await a.json())}}function Pa(e){return async function*(t){let{timeout:r,signal:n,headers:s,...i}=t;const o=await e.post("pin/remote/ls",{timeout:r,signal:n,headers:s,searchParams:Ea(i)});for await(const e of o.ndjson())yield va(e)}}function Aa(e){return async function(t){let{timeout:r,signal:n,headers:s,...i}=t;await e.post("pin/remote/rm",{timeout:r,signal:n,headers:s,searchParams:Ea({...i,all:!1})})}}function Ra(e){return async function(t){let{timeout:r,signal:n,headers:s,...i}=t;await e.post("pin/remote/rm",{timeout:r,signal:n,headers:s,searchParams:Ea({...i,all:!0})})}}var Ca=r(99299);function Ta(e){return async function(t,r){const{endpoint:n,key:s,headers:i,timeout:o,signal:a}=r;await e.post("pin/remote/service/add",{timeout:o,signal:a,searchParams:(0,wi.X)({arg:[t,(0,Ca.hm)(n),s]}),headers:i})}}function Da(e){return async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{stat:r,headers:n,timeout:s,signal:i}=t,o=await e.post("pin/remote/service/ls",{timeout:s,signal:i,headers:n,searchParams:!0===r?(0,wi.X)({stat:r}):void 0}),{RemoteServices:a}=await o.json();return a.map(Ca.iI)}}function Ba(e){return async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};await e.post("pin/remote/service/rm",{signal:r.signal,headers:r.headers,searchParams:(0,wi.X)({arg:t})})}}function xa(e){const t=new ba.KU(e);return{add:Ta(t),ls:Da(t),rm:Ba(t)}}function Na(e){const t=new ba.KU(e);return{add:Sa(t),ls:Pa(t),rm:Aa(t),rmAll:Ra(t),service:xa(e)}}function Oa(e){return{addAll:pa(e),add:fa(e),ls:ya(e),rmAll:ma(e),rm:wa(e),remote:Na(e)}}const La=e=>Array.isArray(e)?e.map(Ma):e,Ma=e=>(0,oe.toString)(ja(e)),ja=e=>h.base64url.decode(e),Ua=e=>h.base64url.encode((0,O.fromString)(e)),za=(0,mi.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{Strings:r}=await(await e.post("pubsub/ls",{signal:t.signal,searchParams:(0,wi.X)(t),headers:t.headers})).json();return La(r)||[]})),Wa=(0,mi.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("pubsub/peers",{signal:r.signal,searchParams:(0,wi.X)({arg:Ua(t),...r}),headers:r.headers}),{Strings:s}=await n.json();return s||[]})),$a=(0,mi.j)((e=>async function(t,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=(0,wi.X)({arg:Ua(t),...n}),i=new AbortController,o=Ti(i.signal,n.signal),a=await e.post("pubsub/pub",{signal:o,searchParams:s,...await Ri([r],i,n.headers)});await a.text()})),Fa=o("ipfs-http-client:pubsub:subscribe");async function Ka(e,t){let{onMessage:r,onEnd:n,onError:s}=t;s=s||Fa;try{for await(const t of e.ndjson())try{if(!t.from)continue;r({from:t.from,data:ja(t.data),seqno:ja(t.seqno),topicIDs:La(t.topicIDs)})}catch(i){i.message=`Failed to parse pubsub message: ${i.message}`,s(i,!1,t)}}catch(i){qa(i)||s(i,!0)}finally{n()}}const qa=e=>{switch(e.type){case"aborted":case"abort":return!0;default:return"AbortError"===e.name}};var Ha=r(12613),Ga=r(21194);function Va(e){const t=new Ga.f;return{ls:za(e),peers:Wa(e),publish:$a(e),subscribe:(r=e,n=t,(0,mi.j)((e=>async function(t,r){let s,i,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};o.signal=n.subscribe(t,r,o.signal);const a=new Promise(((e,t)=>{s=e,i=t})),c=setTimeout((()=>s()),1e3);return e.post("pubsub/sub",{signal:o.signal,searchParams:(0,wi.X)({arg:Ua(t),...o}),headers:o.headers}).catch((e=>{n.unsubscribe(t,r),i(e)})).then((e=>{clearTimeout(c),e&&(Ka(e,{onMessage:r,onEnd:()=>n.unsubscribe(t,r),onError:o.onError}),s())})),a}))(r)),unsubscribe:(0,Ha.W)(e,t)};var r,n}var Xa=r(7519);const Ja=(0,mi.j)(((e,t)=>Object.assign((async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=Array.isArray(t)?t:[t],s=await e.post("refs",{signal:r.signal,searchParams:(0,wi.X)({arg:n.map((e=>`${e instanceof Uint8Array?X.CID.decode(e):e}`)),...r}),headers:r.headers,transform:Fi.C});yield*s.ndjson()}),{local:(0,Xa.p)(t)}))),Za=(0,mi.j)((e=>async function*(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("repo/gc",{signal:t.signal,searchParams:(0,wi.X)(t),headers:t.headers,transform:e=>({err:e.Error?new Error(e.Error):null,cid:(e.Key||{})["/"]?X.CID.parse(e.Key["/"]):null})});yield*r.ndjson()})),Ya=(0,mi.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("repo/stat",{signal:t.signal,searchParams:(0,wi.X)(t),headers:t.headers}),n=await r.json();return{numObjects:BigInt(n.NumObjects),repoSize:BigInt(n.RepoSize),repoPath:n.RepoPath,version:n.Version,storageMax:BigInt(n.StorageMax)}})),Qa=(0,mi.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await(await e.post("repo/version",{signal:t.signal,searchParams:(0,wi.X)(t),headers:t.headers})).json();return r.Version}));function ec(e){return{gc:Za(e),stat:Ya(e),version:Qa(e)}}const tc=(0,mi.j)((e=>async function*(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("stats/bw",{signal:t.signal,searchParams:(0,wi.X)(t),headers:t.headers,transform:e=>({totalIn:BigInt(e.TotalIn),totalOut:BigInt(e.TotalOut),rateIn:parseFloat(e.RateIn),rateOut:parseFloat(e.RateOut)})});yield*r.ndjson()}));function rc(e){return{bitswap:_i(e),repo:Ya(e),bw:tc(e)}}const nc=(0,mi.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("swarm/addrs",{signal:t.signal,searchParams:(0,wi.X)(t),headers:t.headers}),{Addrs:n}=await r.json();return Object.keys(n).map((e=>({id:e,addrs:(n[e]||[]).map((e=>new $t.Multiaddr(e)))})))})),sc=(0,mi.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("swarm/connect",{signal:r.signal,searchParams:(0,wi.X)({arg:t,...r}),headers:r.headers}),{Strings:s}=await n.json();return s||[]})),ic=(0,mi.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("swarm/disconnect",{signal:r.signal,searchParams:(0,wi.X)({arg:t,...r}),headers:r.headers}),{Strings:s}=await n.json();return s||[]})),oc=(0,mi.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("swarm/addrs/local",{signal:t.signal,searchParams:(0,wi.X)(t),headers:t.headers}),{Strings:n}=await r.json();return(n||[]).map((e=>new $t.Multiaddr(e)))})),ac=(0,mi.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("swarm/peers",{signal:t.signal,searchParams:(0,wi.X)(t),headers:t.headers}),{Peers:n}=await r.json();return(n||[]).map((e=>({addr:new $t.Multiaddr(e.Addr),peer:e.Peer,muxer:e.Muxer,latency:e.Latency,streams:e.Streams,direction:null==e.Direction?void 0:0===e.Direction?"inbound":"outbound"})))}));function cc(e){return{addrs:nc(e),connect:sc(e),disconnect:ic(e),localAddrs:oc(e),peers:ac(e)}}const lc=(0,mi.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=new AbortController,s=Ti(n.signal,r.signal),{headers:i,body:o,total:a,parts:c}=await Ri(t,n,r.headers),[l,u]="function"===typeof r.progress?uc(a,c,r.progress):[void 0,void 0],d=await e.post("add",{searchParams:(0,wi.X)({"stream-channels":!0,...r,progress:Boolean(l)}),onUploadProgress:u,signal:s,headers:i,body:o});for await(let e of d.ndjson())e=(0,Fi.C)(e),void 0!==e.hash?yield hc(e):l&&l(e.bytes||0,e.name)})),uc=(e,t,r)=>t?[void 0,dc(e,t,r)]:[r,void 0],dc=(e,t,r)=>{let n=0;const s=t.length;return i=>{let{loaded:o,total:a}=i;const c=Math.floor(o/a*e);for(;n<s;){const{start:e,end:s,name:i}=t[n];if(c<s){r(c-e,i);break}r(s-e,i),n+=1}}};function hc(e){let{name:t,hash:r,size:n,mode:s,mtime:i,mtimeNsecs:o}=e;const a={path:t,cid:X.CID.parse(r),size:parseInt(n)};return null!=s&&(a.mode=parseInt(s,8)),null!=i&&(a.mtime={secs:i,nsecs:o||0}),a}function pc(e){const t=lc(e);return(0,mi.j)((()=>async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return await Y(t(or(e),r))}))(e)}const fc=(0,mi.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("cat",{signal:r.signal,searchParams:(0,wi.X)({arg:t.toString(),...r}),headers:r.headers});yield*n.iterator()})),gc=(0,mi.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("commands",{signal:t.signal,searchParams:(0,wi.X)(t),headers:t.headers});return r.json()})),yc=(0,mi.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("dns",{signal:r.signal,searchParams:(0,wi.X)({arg:t,...r}),headers:r.headers}),s=await n.json();return s.Path})),mc=(0,mi.j)((e=>()=>{const t=new URL(e.opts.base||"");return{host:t.hostname,port:t.port,protocol:t.protocol,pathname:t.pathname,"api-path":t.pathname}})),wc=(0,mi.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n={arg:`${t instanceof Uint8Array?X.CID.decode(t):t}`,...r};n.compressionLevel&&(n["compression-level"]=n.compressionLevel,delete n.compressionLevel);const s=await e.post("get",{signal:r.signal,searchParams:(0,wi.X)(n),headers:r.headers});yield*s.iterator()})),bc=(0,mi.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("id",{signal:t.signal,searchParams:(0,wi.X)({arg:t.peerId?t.peerId.toString():void 0,...t}),headers:t.headers}),n=await r.json(),s={...(0,Fi.C)(n)};return s.addresses&&(s.addresses=s.addresses.map((e=>new $t.Multiaddr(e)))),s})),vc=e=>{const t=bc(e);return async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await t(e);return Boolean(r&&r.addresses&&r.addresses.length)}},_c=(0,mi.j)(((e,t)=>async function*(r){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const s=`${r instanceof Uint8Array?X.CID.decode(r):r}`;async function i(e){let r=e.Hash;if(r.includes("/")){const e=r.startsWith("/ipfs/")?r:`/ipfs/${r}`;r=(await Co(t)(e)).cid}else r=X.CID.parse(r);const n={name:e.Name,path:s+(e.Name?`/${e.Name}`:""),size:e.Size,cid:r,type:kc(e)};return e.Mode&&(n.mode=parseInt(e.Mode,8)),void 0!==e.Mtime&&null!==e.Mtime&&(n.mtime={secs:e.Mtime},void 0!==e.MtimeNsecs&&null!==e.MtimeNsecs&&(n.mtime.nsecs=e.MtimeNsecs)),n}const o=await e.post("ls",{signal:n.signal,searchParams:(0,wi.X)({arg:s,...n}),headers:n.headers});for await(let e of o.ndjson()){if(e=e.Objects,!e)throw new Error("expected .Objects in results");if(e=e[0],!e)throw new Error("expected one array in results.Objects");const t=e.Links;if(!Array.isArray(t))throw new Error("expected one array in results.Objects[0].Links");if(!t.length)return void(yield i(e));yield*t.map(i)}}));function kc(e){switch(e.Type){case 1:case 5:return"dir";default:return"file"}}const Ec=(0,mi.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("dns",{signal:t.signal,searchParams:(0,wi.X)(t),headers:t.headers});return(0,Fi.C)(await r.json())})),Ic=(0,mi.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("ping",{signal:r.signal,searchParams:(0,wi.X)({arg:`${t}`,...r}),headers:r.headers,transform:Fi.C});yield*n.ndjson()})),Sc=(0,mi.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("resolve",{signal:r.signal,searchParams:(0,wi.X)({arg:t,...r}),headers:r.headers}),{Path:s}=await n.json();return s})),Pc=(0,mi.j)((e=>async function(){throw a(new Error("Not implemented"),"ERR_NOT_IMPLEMENTED")})),Ac=(0,mi.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("shutdown",{signal:t.signal,searchParams:(0,wi.X)(t),headers:t.headers});await r.text()})),Rc=(0,mi.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("version",{signal:t.signal,searchParams:(0,wi.X)(t),headers:t.headers});return{...(0,Fi.C)(await r.json()),"ipfs-http-client":"1.0.0"}}));r(42611),r(88910);var Cc=r(62162),Tc=r(84856),Dc=r(48402),Bc=r(65967),xc=r(49616);const Nc={func:(e,t)=>Le.validate(t,e)};function Oc(e,t){return Le.select(t[0],t[1])}var Lc=r(95067),Mc=r(60403);const jc=s.Z.bind({ignoreUndefined:!0});function Uc(e){let{options:t={},peerId:r,multiaddrs:s=[],repo:i,keychainConfig:o={},config:c={}}=e;const{datastore:d,keys:h}=i,p=function(e){let{options:t,config:r,datastore:s,keys:i,keychainConfig:o,peerId:c,multiaddrs:d}=e;const h={datastore:s,peerId:c,modules:{}},p={modules:{pubsub:(()=>{const e=Ze(r,"Pubsub.Router")||"gossipsub";if(!di[e])throw a(new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${e} router.`),"ERR_NOT_SUPPORTED");return di[e]})(),contentRouting:[],peerRouting:[]},config:{peerDiscovery:{mdns:{enabled:Ze(t,"config.Discovery.MDNS.Enabled",Ze(r,"Discovery.MDNS.Enabled",!0))},webRTCStar:{enabled:Ze(t,"config.Discovery.webRTCStar.Enabled",Ze(r,"Discovery.webRTCStar.Enabled",!0))},bootstrap:{list:Ze(t,"config.Bootstrap",Ze(r,"Bootstrap",[]))}},relay:{enabled:Ze(t,"relay.enabled",Ze(r,"relay.enabled",!0)),hop:{enabled:Ze(t,"relay.hop.enabled",Ze(r,"relay.hop.enabled",!1)),active:Ze(t,"relay.hop.active",Ze(r,"relay.hop.active",!1))}},dht:{enabled:"none"!==Ze(r,"Routing.Type","dhtclient"),clientMode:"dhtserver"!==Ze(r,"Routing.Type","dht"),kBucketSize:Ze(t,"dht.kBucketSize",20),validators:{ipns:Le}},pubsub:{enabled:Ze(t,"config.Pubsub.Enabled",Ze(r,"Pubsub.Enabled",!0))},nat:{enabled:!Ze(r,"Swarm.DisableNatPortMap",!1)}},addresses:{listen:d.map((e=>e.toString())),announce:Ze(t,"addresses.announce",Ze(r,"Addresses.Announce",[])),noAnnounce:Ze(t,"addresses.noAnnounce",Ze(r,"Addresses.NoAnnounce",[]))},connectionManager:Ze(t,"connectionManager",{maxConnections:Ze(t,"config.Swarm.ConnMgr.HighWater",Ze(r,"Swarm.ConnMgr.HighWater")),minConnections:Ze(t,"config.Swarm.ConnMgr.LowWater",Ze(r,"Swarm.ConnMgr.LowWater"))}),keychain:{datastore:i,...o},host:{agentVersion:`js-ipfs/${vr.Pr}`}};let f=Ze(t,"libp2p",void 0);"function"===typeof f&&(f=void 0);const g=jc(h,{dialer:{maxParallelDials:150,maxDialsPerPeer:4,dialTimeout:1e4},modules:{transport:[Cc,Tc],streamMuxer:[Dc],connEncryption:[Bc.NOISE],peerDiscovery:[],dht:xc,pubsub:ui},config:{peerDiscovery:{autoDial:!0,bootstrap:{enabled:!0},webRTCStar:{enabled:!0}},dht:{kBucketSize:20,enabled:!0,clientMode:!0,validators:{ipns:Nc},selectors:{ipns:Oc}},pubsub:{enabled:!0,emitSelf:!0},nat:{enabled:!1}},metrics:{enabled:!0},peerStore:{persistence:!0}},p,f);Ze(g,"config.peerDiscovery.bootstrap.list",[]).length>0&&g.modules.peerDiscovery.push(Lc);const y=Ze(t,"config.Addresses.Delegates",Ze(r,"Addresses.Delegates",[]));if(y.length>0){const e=y[Math.floor(Math.random()*y.length)],t=new $t.Multiaddr(e).toOptions(),r=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const t={name:S.identity.name,code:S.identity.code,encode:e=>e,decode:e=>e},r=Object.values(P.gh);(e.ipld&&e.ipld.bases?e.ipld.bases:[]).forEach((e=>r.push(e)));const s=new fi.x({bases:r,loadBase:e.ipld&&e.ipld.loadBase}),i=Object.values(P.QB);[l,u,n,I,t].concat(e.ipld&&e.ipld.codecs||[]).forEach((e=>i.push(e)));const o=new gi.w({codecs:i,loadCodec:e.ipld&&e.ipld.loadCodec}),a=Object.values(P.kq);(e.ipld&&e.ipld.hashers?e.ipld.hashers:[]).forEach((e=>a.push(e)));const c=new yi.d({hashers:a,loadHasher:e.ipld&&e.ipld.loadHasher});return{add:pc(e),addAll:lc(e),bitswap:Ii(e),block:Oi(e),bootstrap:Wi(e),cat:fc(e),commands:gc(e),config:Zi(e),dag:so(o,e),dht:po(e),diag:mo(e),dns:yc(e),files:Oo(e),get:wc(e),getEndpointConfig:mc(e),id:bc(e),isOnline:vc(e),key:Fo(e),log:Go(e),ls:_c(e),mount:Ec(e),name:ea(e),object:ha(o,e),pin:Oa(e),ping:Ic(e),pubsub:Va(e),refs:Ja(e),repo:ec(e),resolve:Sc(e),start:Pc(e),stats:rc(e),stop:Ac(e),swarm:cc(e),version:Rc(e),bases:s,codecs:o,hashers:c}}({host:t.host,protocol:443===parseInt(t.port)?"https":"http",port:t.port});p.modules.contentRouting=p.modules.contentRouting||[],p.modules.contentRouting.push(new pi(c,r)),p.modules.peerRouting=p.modules.peerRouting||[],p.modules.peerRouting.push(new hi(r))}return g}({options:t,config:c,datastore:d,keys:h,keychainConfig:o,peerId:r,multiaddrs:s});return"function"===typeof t.libp2p?t.libp2p({libp2pOptions:p,options:t,config:c,datastore:d,peerId:r}):Mc.create(p)}const zc=s.Z.bind({ignoreUndefined:!0}),Wc=o("ipfs:components:peer:storage");class $c{constructor(e,t,r,n,s){this.print=n,this.peerId=e,this.keychain=t,this.repo=r,this.print=n,this.isNew=s}static async start(e,t,r){const{repoAutoMigrate:n,repo:s,onMigrationProgress:i}=r,o="string"===typeof s||null==s?li(e,t,{path:s,autoMigrate:n,onMigrationProgress:i}):s,{peerId:a,keychain:c,isNew:l}=await Fc(e,o,r);return new $c(a,c,o,e,l)}}const Fc=async(e,t,r)=>{if(!t.closed)return{...await Vc(t,r),isNew:!1};try{return await t.open(),{...await Vc(t,r),isNew:!1}}catch(n){if(n.code!==ws)throw n;if(r.init&&!1===r.init.allowNew)throw new N("Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it");return{...await Kc(e,t,r),isNew:!0}}},Kc=async(e,t,r)=>{const n=r.init||{},s=await t.exists();if(Wc("repo exists?",s),!0===s)throw new Error("repo already exists");const i=n.privateKey?await qc(n.privateKey):await Hc(e,n),o=Gc(i);Wc("peer identity: %s",o.PeerID);const a={...zc(Jc((0,Ft.Z)(),n.profiles),r.config),Identity:o};await t.init(a),await t.open(),Wc("repo opened");const c={pass:r.pass};try{c.dek=await t.config.get("Keychain.DEK")}catch(u){if("ERR_NOT_FOUND"!==u.code)throw u}const l=await Uc({options:void 0,multiaddrs:void 0,peerId:i,repo:t,config:a,keychainConfig:c});return l.keychain&&l.keychain.opts&&(await l.loadKeychain(),await t.config.set("Keychain",{DEK:l.keychain.opts.dek})),{peerId:i,keychain:l.keychain}},qc=e=>(Wc("using user-supplied private-key"),"object"===typeof e?e:J.createFromPrivKey((0,O.fromString)(e,"base64pad"))),Hc=(e,t)=>{let{algorithm:r="Ed25519",bits:n=2048}=t;return e("generating %s keypair...",r),J.create({keyType:r,bits:n})},Gc=e=>({PeerID:e.toB58String(),PrivKey:(0,oe.toString)(e.privKey.bytes,"base64pad")}),Vc=async(e,t)=>{const r=t.config,n=t.init&&t.init.profiles||[],s=t.pass,i=await e.config.getAll(),o=Xc(Jc(i,n),r);if(i!==o&&await e.config.replace(o),!o.Identity||!o.Identity.PrivKey)throw new R("No private key was found in the config, please intialize the repo");const a=await J.createFromPrivKey(o.Identity.PrivKey),c=await Uc({options:void 0,multiaddrs:void 0,peerId:a,repo:e,config:o,keychainConfig:{pass:s,...o.Keychain}});return c.keychain&&await c.loadKeychain(),{peerId:a,keychain:c.keychain}},Xc=(e,t)=>t?zc(e,t):e,Jc=(e,t)=>(t||[]).reduce(((e,t)=>{const r=Ir[t];if(!r)throw new Error(`Could not find profile with name '${t}'`);return Wc("applying profile %s",t),r.transform(e)}),e);var Zc=r(5717),Yc=r(3390),Qc=r(81564);const el=(e,t)=>{const r=["bitswap"];return t&&r.push(t),e&&r.push(`${e.toB58String().slice(0,8)}`),Object.assign(o(r.join(":")),{error:o(r.concat(["error"]).join(":"))})},tl=(e,t)=>{if(e.size!==t.size)return!1;for(const[r,n]of e){const e=t.get(r);if(void 0===e)return!1;if(n instanceof Uint8Array&&e instanceof Uint8Array&&!(0,ae.equals)(n,e))return!1;if(n instanceof Qc.b&&e instanceof Qc.b&&!n.equals(e))return!1}return!0};var rl=r(48009);class nl{constructor(e){this.full=e,this.wantlist=new Map,this.blocks=new Map,this.blockPresences=new Map,this.pendingBytes=0}get empty(){return 0===this.blocks.size&&0===this.wantlist.size&&0===this.blockPresences.size}addEntry(e,t,r,n,s){null==r&&(r=nl.WantType.Block);const i=e.toString(Ye.base58btc),o=this.wantlist.get(i);o?(o.wantType===r&&(o.priority=t),n&&(o.cancel=Boolean(n)),s&&(o.sendDontHave=Boolean(s)),r===nl.WantType.Block&&o.wantType===nl.WantType.Have&&(o.wantType=r)):this.wantlist.set(i,new Qc.b(e,t,r,n,s))}addBlock(e,t){const r=e.toString(Ye.base58btc);this.blocks.set(r,t)}addHave(e){const t=e.toString(Ye.base58btc);this.blockPresences.has(t)||this.blockPresences.set(t,nl.BlockPresenceType.Have)}addDontHave(e){const t=e.toString(Ye.base58btc);this.blockPresences.has(t)||this.blockPresences.set(t,nl.BlockPresenceType.DontHave)}cancel(e){const t=e.toString(Ye.base58btc);this.wantlist.delete(t),this.addEntry(e,0,nl.WantType.Block,!0,!1)}setPendingBytes(e){this.pendingBytes=e}serializeToBitswap100(){const e={wantlist:{entries:Array.from(this.wantlist.values()).map((e=>({block:e.cid.bytes,priority:Number(e.priority),cancel:Boolean(e.cancel)}))),full:!!this.full||void 0},blocks:Array.from(this.blocks.values())};return rl.v.encode(e).finish()}serializeToBitswap110(){const e={wantlist:{entries:Array.from(this.wantlist.values()).map((e=>({block:e.cid.bytes,priority:Number(e.priority),wantType:e.wantType,cancel:Boolean(e.cancel),sendDontHave:Boolean(e.sendDontHave)}))),full:!!this.full||void 0},blockPresences:[],payload:[],pendingBytes:this.pendingBytes};for(const[t,r]of this.blocks.entries()){const n=X.CID.parse(t),s=n.version,i=n.code,o=n.multihash.code,a=n.multihash.digest.length,c=(0,Yc.Z)([s,i,o,a]);e.payload.push(new rl.v.Block({prefix:c,data:r}))}for(const[t,r]of this.blockPresences)e.blockPresences.push(new rl.v.BlockPresence({cid:X.CID.parse(t).bytes,type:r}));return this.pendingBytes>0&&(e.pendingBytes=this.pendingBytes),rl.v.encode(e).finish()}equals(e){return!!(this.full===e.full&&this.pendingBytes===e.pendingBytes&&tl(this.wantlist,e.wantlist)&&tl(this.blocks,e.blocks)&&tl(this.blockPresences,e.blockPresences))}get[Symbol.toStringTag](){const e=Array.from(this.wantlist.keys()),t=Array.from(this.blocks.keys());return`BitswapMessage <full: ${this.full}, list: ${e}, blocks: ${t}>`}}nl.deserialize=async(e,t)=>{const r=rl.v.decode(e),n=r.wantlist&&r.wantlist.full||!1,s=new nl(n);return r.wantlist&&r.wantlist.entries&&r.wantlist.entries.forEach((e=>{if(!e.block)return;const t=X.CID.decode(e.block);s.addEntry(t,e.priority||0,e.wantType,Boolean(e.cancel),Boolean(e.sendDontHave))})),r.blockPresences&&r.blockPresences.forEach((e=>{if(!e.cid)return;const t=X.CID.decode(e.cid);e.type===nl.BlockPresenceType.Have?s.addHave(t):s.addDontHave(t)})),r.blocks.length>0?(await Promise.all(r.blocks.map((async e=>{const t=await $n.sha256.digest(e),r=X.CID.createV0(t);s.addBlock(r,e)}))),s):r.payload.length>0?(await Promise.all(r.payload.map((async e=>{if(!e.prefix||!e.data)return;const r=Zc(e.prefix),n=r[0],i=r[1],o=r[2],c=o===$n.sha256.code?$n.sha256:t&&await t.getHasher(o);if(!c)throw a(new Error("Unknown hash algorithm"),"ERR_UNKNOWN_HASH_ALG");const l=await c.digest(e.data),u=X.CID.create(n,i,l);s.addBlock(u,e.data)}))),s.setPendingBytes(r.pendingBytes),s):s},nl.blockPresenceSize=e=>e.bytes.length+1,nl.Entry=Qc.b,nl.WantType={Block:rl.v.Wantlist.WantType.Block,Have:rl.v.Wantlist.WantType.Have},nl.BlockPresenceType={Have:rl.v.BlockPresenceType.Have,DontHave:rl.v.BlockPresenceType.DontHave};var sl=r(49301);const il=Math.pow(2,31)-1;var ol=r(88898);class al{constructor(e,t,r){this.peerId=t,this.network=r,this.refcnt=1,this._entries=[],this._log=el(e,"msgqueue"),this.sendEntries=ol(this._sendEntries.bind(this),1)}addMessage(e){e.empty||this.send(e)}addEntries(e){this._entries=this._entries.concat(e),this.sendEntries()}_sendEntries(){if(!this._entries.length)return;const e=new nl(!1);this._entries.forEach((t=>{t.cancel?e.cancel(t.cid):e.addEntry(t.cid,t.priority)})),this._entries=[],this.addMessage(e)}async send(e){try{await this.network.connectTo(this.peerId)}catch(t){return void this._log.error("cant connect to peer %s: %s",this.peerId.toB58String(),t.message)}this._log("sending message to peer %s",this.peerId.toB58String()),this.network.sendMessage(this.peerId,e).catch((e=>{this._log.error("send error: %s",e.message)}))}}var cl=r(71038);class ll{constructor(e,t,r,n){this.peers=cl({system:"ipfs",component:"bitswap",metric:"want-manager-peers",metrics:n.metrics}),this.wantlist=new sl.m(r,n),this.network=t,this._stats=r,this._peerId=e,this._log=el(e,"want")}_addEntries(e,t,r){const n=e.map(((e,r)=>new nl.Entry(e,il-r,nl.WantType.Block,t)));n.forEach((e=>{e.cancel?r?this.wantlist.removeForce(e.cid.toString(Ye.base58btc)):this.wantlist.remove(e.cid):(this._log("adding to wl"),this.wantlist.add(e.cid,e.priority))}));for(const s of this.peers.values())s.addEntries(n)}_startPeerHandler(e){let t=this.peers.get(e.toB58String());if(t)return void t.refcnt++;t=new al(this._peerId,e,this.network);const r=new nl(!0);for(const n of this.wantlist.entries())r.addEntry(n[1].cid,n[1].priority);return t.addMessage(r),this.peers.set(e.toB58String(),t),t}_stopPeerHandler(e){const t=this.peers.get(e.toB58String());t&&(t.refcnt--,t.refcnt>0||this.peers.delete(e.toB58String()))}wantBlocks(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this._addEntries(e,!1),t&&t.signal&&t.signal.addEventListener("abort",(()=>{this.cancelWants(e)}))}unwantBlocks(e){this._log("unwant blocks: %s",e.length),this._addEntries(e,!0,!0)}cancelWants(e){this._log("cancel wants: %s",e.length),this._addEntries(e,!0)}connectedPeers(){return Array.from(this.peers.keys())}connected(e){this._startPeerHandler(e)}disconnected(e){this._stopPeerHandler(e)}start(){}stop(){this.peers.forEach((e=>this.disconnected(e.peerId)))}}var ul=r(7213),dl=r(90983);const hl="/ipfs/bitswap/1.0.0",pl="/ipfs/bitswap/1.1.0",fl="/ipfs/bitswap/1.2.0";class gl{constructor(e,t,r){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};this._log=el(e.peerId,"network"),this._libp2p=e,this._bitswap=t,this._protocols=[hl],n.b100Only||(this._protocols.unshift(pl),this._protocols.unshift(fl)),this._stats=r,this._running=!1,this._onPeerConnect=this._onPeerConnect.bind(this),this._onPeerDisconnect=this._onPeerDisconnect.bind(this),this._onConnection=this._onConnection.bind(this),this._hashLoader=n.hashLoader}async start(){this._running=!0,await this._libp2p.handle(this._protocols,this._onConnection);const e=new dl({multicodecs:this._protocols,handlers:{onConnect:this._onPeerConnect,onDisconnect:this._onPeerDisconnect}});this._registrarId=await this._libp2p.registrar.register(e);for await(const t of this._libp2p.peerStore.getPeers()){const e=this._libp2p.connectionManager.get(t.id);e&&this._onPeerConnect(e.remotePeer)}}async stop(){this._running=!1,await this._libp2p.unhandle(this._protocols),null!=this._registrarId&&this._libp2p.registrar.unregister(this._registrarId)}async _onConnection(e){let{protocol:t,stream:r,connection:n}=e;if(this._running){this._log("incoming new bitswap %s connection from %s",t,n.remotePeer.toB58String());try{await(0,Vt.pipe)(r,ul.decode(),(async e=>{for await(const r of e)try{const e=await nl.deserialize(r.slice(),this._hashLoader);await this._bitswap._receiveMessage(n.remotePeer,e)}catch(t){this._bitswap._receiveError(t);break}}))}catch(s){this._log(s)}}}_onPeerConnect(e){this._bitswap._onPeerConnected(e)}_onPeerDisconnect(e){this._bitswap._onPeerDisconnected(e)}findProviders(e,t){return this._libp2p.contentRouting.findProviders(e,{timeout:1e4,maxNumProviders:t})}async findAndConnect(e,t){const r=[];for await(const n of this.findProviders(e,3,t))this._log(`connecting to provider ${n.id}`),r.push(this.connectTo(n.id,t).catch((e=>{this._log.error(e)})));await Promise.all(r)}async provide(e,t){await this._libp2p.contentRouting.provide(e,t)}async sendMessage(e,t){if(!this._running)throw new Error("network isn't running");const r=e.toB58String();this._log("sendMessage to %s",r,t);const n=await this._libp2p.dial(e),{stream:s,protocol:i}=await n.newStream([fl,pl,hl]);let o;switch(i){case hl:o=t.serializeToBitswap100();break;case pl:case fl:o=t.serializeToBitswap110();break;default:throw new Error("Unknown protocol: "+i)}!async function(e,t,r){try{await(0,Vt.pipe)([t],ul.encode(),e)}catch(n){r(n)}}(s,o,this._log),this._updateSentStats(e,t.blocks)}async connectTo(e,t){if(!this._running)throw new Error("network isn't running");return this._libp2p.dial(e,t)}_updateSentStats(e,t){const r=e.toB58String();if(this._stats){for(const e of t.values())this._stats.push(r,"dataSent",e.length);this._stats.push(r,"blocksSent",t.size)}}}class yl{constructor(e){this.partner=e,this.wantlist=new sl.m,this.exchangeCount=0,this.sentToPeer=new Map,this.accounting={bytesSent:0,bytesRecv:0}}sentBytes(e){this.exchangeCount++,this.lastExchange=(new Date).getTime(),this.accounting.bytesSent+=e}receivedBytes(e){this.exchangeCount++,this.lastExchange=(new Date).getTime(),this.accounting.bytesRecv+=e}wants(e,t,r){this.wantlist.add(e,t,r)}cancelWant(e){this.wantlist.remove(e)}wantlistContains(e){return this.wantlist.get(e)}debtRatio(){return this.accounting.bytesSent/(this.accounting.bytesRecv+1)}}class ml extends Map{constructor(e,t){super(),this._cmp=t||this._defaultSort,this._keys=[];for(const[r,n]of e||[])this.set(r,n)}update(e){if(e<0||e>=this._keys.length)return;const t=this._keys[e];this._keys.splice(e,1);const r=this._find(t);this._keys.splice(r,0,t)}set(e,t){if(this.has(e)){const t=this.indexOf(e);this._keys.splice(t,1)}super.set(e,t);const r=this._find(e);return this._keys.splice(r,0,e),this}clear(){super.clear(),this._keys=[]}delete(e){if(!this.has(e))return!1;const t=this.indexOf(e);return this._keys.splice(t,1),super.delete(e)}indexOf(e){if(!this.has(e))return-1;const t=this._find(e);if(this._keys[t]===e)return t;for(let r=1;r<this._keys.length;r++){if(this._keys[t+r]===e)return t+r;if(this._keys[t-r]===e)return t-r}return-1}_find(e){let t=0,r=this._keys.length;for(;t<r;){const n=t+r>>>1,s=this._kCmp(this._keys[n],e);if(s<0)t=n+1;else{if(!(s>0))return n;r=n}}return t}*keys(){for(const e of this._keys)yield e}*values(){for(const e of this._keys)yield this.get(e)}*entries(){for(const e of this._keys)yield[e,this.get(e)]}*[Symbol.iterator](){yield*this.entries()}forEach(e,t){if(e)for(const r of this._keys)e.apply(t,[[r,this.get(r)]])}_defaultSort(e,t){return e[0]<t[0]?-1:t[0]<e[0]?1:0}_kCmp(e,t){return this._cmp([e,this.get(e)],[t,this.get(t)])}}const wl={hasNewInfo:()=>!1,merge(){}};class bl{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:wl;this._taskMerger=e,this._byPeer=new ml([],vl.compare)}pushTasks(e,t){let r=this._byPeer.get(e.toB58String());r||(r=new vl(e,this._taskMerger)),r.pushTasks(t),this._byPeer.set(e.toB58String(),r)}popTasks(e){const t=this._head();if(void 0===t)return{tasks:[],pendingSize:0};const{tasks:r,pendingSize:n}=t.popTasks(e);if(0===r.length)return{tasks:r,pendingSize:n};const s=t.peerId;return t.isIdle()?this._byPeer.delete(s.toB58String()):this._byPeer.update(0),{peerId:s,tasks:r,pendingSize:n}}_head(){if(0!==this._byPeer.size)for(const[,e]of this._byPeer)return e}remove(e,t){const r=this._byPeer.get(t.toB58String());r&&r.remove(e)}tasksDone(e,t){const r=this._byPeer.get(e.toB58String());if(!r)return;const n=this._byPeer.indexOf(e.toB58String());for(const s of t)r.taskDone(s);this._byPeer.update(n)}}class vl{constructor(e,t){this.peerId=e,this._taskMerger=t,this._activeTotalSize=0,this._pending=new _l,this._active=new Set}pushTasks(e){for(const t of e)this._pushTask(t)}_pushTask(e){if(!this._taskHasMoreInfoThanActiveTasks(e))return;const t=this._pending.get(e.topic);if(t)return e.priority>t.priority&&this._pending.updatePriority(e.topic,e.priority),void this._taskMerger.merge(e,t);this._pending.add(e)}_taskHasMoreInfoThanActiveTasks(e){const t=[];for(const r of this._active)r.topic===e.topic&&t.push(r);return 0===t.length||this._taskMerger.hasNewInfo(e,t)}popTasks(e){let t=0;const r=[],n=this._pending.tasks();for(let s=0;s<n.length&&t<e;s++){const e=n[s];r.push(e),t+=e.size,this._pending.delete(e.topic),this._activeTotalSize+=e.size,this._active.add(e)}return{tasks:r,pendingSize:this._pending.totalSize}}taskDone(e){this._active.has(e)&&(this._activeTotalSize-=e.size,this._active.delete(e))}remove(e){this._pending.delete(e)}isIdle(){return 0===this._pending.length&&0===this._active.size}static compare(e,t){return 0===e[1]._pending.length?1:0===t[1]._pending.length?-1:e[1]._activeTotalSize===t[1]._activeTotalSize?t[1]._pending.length-e[1]._pending.length:e[1]._activeTotalSize-t[1]._activeTotalSize}}class _l{constructor(){this._tasks=new ml([],this._compare)}get length(){return this._tasks.size}get totalSize(){return[...this._tasks.values()].reduce(((e,t)=>e+t.task.size),0)}get(e){return(this._tasks.get(e)||{}).task}add(e){this._tasks.set(e.topic,{created:Date.now(),task:e})}delete(e){this._tasks.delete(e)}tasks(){return[...this._tasks.values()].map((e=>e.task))}updatePriority(e,t){const r=this._tasks.get(e);if(!r)return;const n=this._tasks.indexOf(e);r.task.priority=t,this._tasks.update(n)}_compare(e,t){return e[1].task.priority===t[1].task.priority?e[1].created-t[1].created:t[1].task.priority-e[1].task.priority}}const kl={hasNewInfo(e,t){let r=!1,n=!1;for(const s of t)s.data.haveBlock&&(r=!0),s.data.isWantBlock&&(n=!0);return!(n||!e.data.isWantBlock)||!(r||!e.data.haveBlock)},merge(e,t){const r=e.data,n=t.data;!n.haveBlock&&r.haveBlock&&(n.haveBlock=r.haveBlock,n.blockSize=r.blockSize),!n.isWantBlock&&r.isWantBlock&&(n.isWantBlock=!0,n.haveBlock&&!r.haveBlock||(n.haveBlock=r.haveBlock,t.size=e.size)),n.isWantBlock&&n.haveBlock&&(t.size=n.blockSize)}},El=nl.WantType;class Il{constructor(e,t,r,n,s){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{};this._log=el(e,"engine"),this.blockstore=t,this.network=r,this._stats=n,this._opts=this._processOpts(i),this.ledgerMap=cl({system:"ipfs",component:"bitswap",metric:"ledger-map",metrics:s.metrics}),this._running=!1,this._requestQueue=new bl(kl)}_processOpts(e){return{maxSizeReplaceHasWithBlock:1024,targetMessageSize:16384,...e}}_scheduleProcessTasks(){setTimeout((()=>{this._processTasks()}))}async _processTasks(){if(!this._running)return;const{peerId:e,tasks:t,pendingSize:r}=this._requestQueue.popTasks(this._opts.targetMessageSize);if(0===t.length)return;const n=new nl(!1);n.setPendingBytes(r);const s=[],i=new Map;for(const c of t){const e=X.CID.parse(c.topic);c.data.haveBlock?c.data.isWantBlock?(s.push(e),i.set(c.topic,c.data)):n.addHave(e):n.addDontHave(e)}const o=await this._getBlocks(s);for(const[c,l]of i){const e=X.CID.parse(c),t=o.get(c);t?n.addBlock(e,t):l.sendDontHave&&n.addDontHave(e)}if(n.empty)return e&&this._requestQueue.tasksDone(e,t),void this._scheduleProcessTasks();try{e&&await this.network.sendMessage(e,n);for(const[t,r]of o.entries())e&&this.messageSent(e,X.CID.parse(t),r)}catch(a){this._log.error(a)}e&&this._requestQueue.tasksDone(e,t),this._scheduleProcessTasks()}wantlistForPeer(e){const t=e.toB58String(),r=this.ledgerMap.get(t);return r?r.wantlist.sortedEntries():new Map}ledgerForPeer(e){const t=e.toB58String(),r=this.ledgerMap.get(t);return r?{peer:r.partner,value:r.debtRatio(),sent:r.accounting.bytesSent,recv:r.accounting.bytesRecv,exchanged:r.exchangeCount}:null}peers(){return Array.from(this.ledgerMap.values()).map((e=>e.partner))}receivedBlocks(e){if(e.length){for(const t of this.ledgerMap.values())for(const r of e){const e=t.wantlistContains(r.cid);if(!e)continue;const n=r.data.length,s=this._sendAsBlock(e.wantType,n);let i=n;s||(i=nl.blockPresenceSize(e.cid)),this._requestQueue.pushTasks(t.partner,[{topic:e.cid.toString(Ye.base58btc),priority:e.priority,size:i,data:{blockSize:n,isWantBlock:s,haveBlock:!0,sendDontHave:!1}}])}this._scheduleProcessTasks()}}async messageReceived(e,t){const r=this._findOrCreate(e);if(t.empty)return;if(t.full&&(r.wantlist=new sl.m),this._updateBlockAccounting(t.blocks,r),0===t.wantlist.size)return void this._scheduleProcessTasks();const n=[],s=[];t.wantlist.forEach((e=>{e.cancel?(r.cancelWant(e.cid),n.push(e.cid)):(r.wants(e.cid,e.priority,e.wantType),s.push(e))})),this._cancelWants(e,n),await this._addWants(e,s),this._scheduleProcessTasks()}_cancelWants(e,t){for(const r of t)this._requestQueue.remove(r.toString(Ye.base58btc),e)}async _addWants(e,t){const r=await this._getBlockSizes(t.map((e=>e.cid))),n=[];for(const s of t){const t=s.cid.toString(Ye.base58btc),i=r.get(t);if(null==i)s.sendDontHave&&n.push({topic:t,priority:s.priority,size:nl.blockPresenceSize(s.cid),data:{isWantBlock:s.wantType===El.Block,blockSize:0,haveBlock:!1,sendDontHave:s.sendDontHave}});else{const e=this._sendAsBlock(s.wantType,i);let r=i;e||(r=nl.blockPresenceSize(s.cid)),n.push({topic:t,priority:s.priority,size:r,data:{isWantBlock:e,blockSize:i,haveBlock:!0,sendDontHave:s.sendDontHave}})}this._requestQueue.pushTasks(e,n)}}_sendAsBlock(e,t){return e===El.Block||t<=this._opts.maxSizeReplaceHasWithBlock}async _getBlockSizes(e){const t=await this._getBlocks(e);return new Map([...t].map((e=>{let[t,r]=e;return[t,r.length]})))}async _getBlocks(e){const t=new Map;return await Promise.all(e.map((async e=>{try{const r=await this.blockstore.get(e);t.set(e.toString(Ye.base58btc),r)}catch(r){"ERR_NOT_FOUND"!==r.code&&this._log.error("failed to query blockstore for %s: %s",e,r)}}))),t}_updateBlockAccounting(e,t){for(const r of e.values())this._log("got block (%s bytes)",r.length),t.receivedBytes(r.length)}messageSent(e,t,r){const n=this._findOrCreate(e);n.sentBytes(r.length),n.wantlist.remove(t)}numBytesSentTo(e){return this._findOrCreate(e).accounting.bytesSent}numBytesReceivedFrom(e){return this._findOrCreate(e).accounting.bytesRecv}peerDisconnected(e){this.ledgerMap.delete(e.toB58String())}_findOrCreate(e){const t=e.toB58String(),r=this.ledgerMap.get(t);if(r)return r;const n=new yl(e);return this.ledgerMap.set(t,n),this._stats&&this._stats.push(t,"peerCount",1),n}start(){this._running=!0}stop(){this._running=!1}}var Sl=r(36571);const Pl=e=>`unwant:${(0,oe.toString)(e.multihash.bytes,"base64")}`,Al=e=>`block:${(0,oe.toString)(e.multihash.bytes,"base64")}`;class Rl extends Sl.EventEmitter{constructor(e){super(),this.setMaxListeners(1e3),this._log=el(e,"notif")}hasBlock(e,t){const r=Al(e);this._log(r),this.emit(r,t)}wantBlock(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!e)throw new Error("Not a valid cid");const r=Al(e),n=Pl(e);return this._log(`wantBlock:${e}`),new Promise(((s,i)=>{const o=()=>{this.removeListener(r,a),i(new Error(`Block for ${e} unwanted`))},a=e=>{this.removeListener(n,o),s(e)};this.once(n,o),this.once(r,a),t&&t.signal&&t.signal.addEventListener("abort",(()=>{this.removeListener(r,a),this.removeListener(n,o),i(new Error(`Want for ${e} aborted`))}))}))}unwantBlock(e){const t=Pl(e);this._log(t),this.emit(t)}}var Cl=r(40316);class Tl extends Sl.EventEmitter{constructor(e,t){super(),this._options=t,this._queue=[],this._stats={},this._frequencyLastTime=Date.now(),this._frequencyAccumulators={},this._movingAverages={},this._update=this._update.bind(this),e.forEach((e=>{this._stats[e]=BigInt(0),this._movingAverages[e]={},this._options.movingAverageIntervals.forEach((t=>{(this._movingAverages[e][t]=Cl(t)).push(this._frequencyLastTime,0)}))})),this._enabled=this._options.enabled}enable(){this._enabled=!0}disable(){this._disabled=!0}stop(){this._timeout&&clearTimeout(this._timeout)}get snapshot(){return Object.assign({},this._stats)}get movingAverages(){return Object.assign({},this._movingAverages)}push(e,t){this._enabled&&(this._queue.push([e,t,Date.now()]),this._resetComputeTimeout())}_resetComputeTimeout(){this._timeout&&clearTimeout(this._timeout),this._timeout=setTimeout(this._update,this._nextTimeout())}_nextTimeout(){const e=this._queue.length/this._options.computeThrottleMaxQueueSize;return Math.max(this._options.computeThrottleTimeout*(1-e),0)}_update(){if(this._timeout=null,this._queue.length){let e;for(;this._queue.length;){const t=e=this._queue.shift();t&&this._applyOp(t)}e&&this._updateFrequency(e[2]),this.emit("update",this._stats)}}_updateFrequency(e){const t=e-this._frequencyLastTime;t&&Object.keys(this._stats).forEach((r=>{this._updateFrequencyFor(r,t,e)})),this._frequencyLastTime=e}_updateFrequencyFor(e,t,r){const n=this._frequencyAccumulators[e]||0;this._frequencyAccumulators[e]=0;const s=n/t*1e3;let i=this._movingAverages[e];i||(i=this._movingAverages[e]={}),this._options.movingAverageIntervals.forEach((e=>{let t=i[e];t||(t=i[e]=Cl(e)),t.push(r,s)}))}_applyOp(e){const t=e[0],r=e[1];if("number"!==typeof r)throw new Error(`invalid increment number: ${r}`);Object.prototype.hasOwnProperty.call(this._stats,t)||(this._stats[t]=BigInt(0)),this._stats[t]=BigInt(this._stats[t])+BigInt(r),this._frequencyAccumulators[t]||(this._frequencyAccumulators[t]=0),this._frequencyAccumulators[t]+=r}}const Dl={enabled:!1,computeThrottleTimeout:1e3,computeThrottleMaxQueueSize:1e3,movingAverageIntervals:[6e4,3e5,9e5]};class Bl extends Sl.EventEmitter{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Dl;super();const n=Object.assign({},Dl,r);if("number"!==typeof n.computeThrottleTimeout)throw new Error("need computeThrottleTimeout");if("number"!==typeof n.computeThrottleMaxQueueSize)throw new Error("need computeThrottleMaxQueueSize");this._initialCounters=t,this._options=n,this._enabled=this._options.enabled,this._global=new Tl(t,n),this._global.on("update",(e=>this.emit("update",e))),this._peers=cl({system:"ipfs",component:"bitswap",metric:"stats-peers",metrics:e.metrics})}enable(){this._enabled=!0,this._options.enabled=!0,this._global.enable()}disable(){this._enabled=!1,this._options.enabled=!1,this._global.disable()}stop(){this._enabled=!1,this._global.stop();for(const e of this._peers)e[1].stop()}get snapshot(){return this._global.snapshot}get movingAverages(){return this._global.movingAverages}forPeer(e){const t="string"!==typeof e&&e.toB58String?e.toB58String():`${e}`;return this._peers.get(t)}push(e,t,r){if(this._enabled&&(this._global.push(t,r),e)){let n=this._peers.get(e);n||(n=new Tl(this._initialCounters,this._options),this._peers.set(e,n)),n.push(t,r)}}disconnected(e){const t=e.toB58String(),r=this._peers.get(t);r&&(r.stop(),this._peers.delete(t))}}const xl={statsEnabled:!1,statsComputeThrottleTimeout:1e3,statsComputeThrottleMaxQueueSize:1e3},Nl=["blocksReceived","dataReceived","dupBlksReceived","dupDataReceived","blocksSent","dataSent","providesBufferLength","wantListLength","peerCount"];class Ol extends si.E{constructor(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};super(),this._libp2p=e,this._log=el(this.peerId),this._options=Object.assign({},xl,r),this._stats=new Bl(e,Nl,{enabled:this._options.statsEnabled,computeThrottleTimeout:this._options.statsComputeThrottleTimeout,computeThrottleMaxQueueSize:this._options.statsComputeThrottleMaxQueueSize}),this.network=new gl(e,this,this._stats,{hashLoader:r.hashLoader}),this.blockstore=t,this.engine=new Il(this.peerId,t,this.network,this._stats,e),this.wm=new ll(this.peerId,this.network,this._stats,e),this.notifications=new Rl(this.peerId),this.started=!1}isStarted(){return this.started}get peerId(){return this._libp2p.peerId}async _receiveMessage(e,t){try{await this.engine.messageReceived(e,t)}catch(n){this._log("failed to receive message",t)}if(0===t.blocks.size)return;const r=[];for(const[s,i]of t.blocks.entries()){const e=X.CID.parse(s);r.push({wasWanted:this.wm.wantlist.contains(e),cid:e,data:i})}this.wm.cancelWants(r.filter((e=>{let{wasWanted:t}=e;return t})).map((e=>{let{cid:t}=e;return t}))),await Promise.all(r.map((t=>{let{cid:r,wasWanted:n,data:s}=t;return this._handleReceivedBlock(e,r,s,n)})))}async _handleReceivedBlock(e,t,r,n){this._log("received block");const s=await this.blockstore.has(t);this._updateReceiveCounters(e.toB58String(),t,r,s),n&&await this.put(t,r)}_updateReceiveCounters(e,t,r,n){this._stats.push(e,"blocksReceived",1),this._stats.push(e,"dataReceived",r.length),n&&(this._stats.push(e,"dupBlksReceived",1),this._stats.push(e,"dupDataReceived",r.length))}_receiveError(e){this._log.error("ReceiveError: %s",e.message)}_onPeerConnected(e){this.wm.connected(e)}_onPeerDisconnected(e){this.wm.disconnected(e),this.engine.peerDisconnected(e),this._stats.disconnected(e)}enableStats(){this._stats.enable()}disableStats(){this._stats.disable()}wantlistForPeer(e,t){return this.engine.wantlistForPeer(e)}ledgerForPeer(e){return this.engine.ledgerForPeer(e)}async get(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const r=(e,t)=>(this.wm.wantBlocks([e],t),this.notifications.wantBlock(e,t));let n=!1;const s=new AbortController,i=t.signal?(0,Ct.anySignal)([t.signal,s.signal]):s.signal,o=await Promise.race([this.notifications.wantBlock(e,{signal:i}),(async(e,t)=>{try{return await this.blockstore.get(e,t)}catch(s){if("ERR_NOT_FOUND"!==s.code)throw s;return n||(n=!0,this.network.findAndConnect(e).catch((e=>this._log.error(e)))),r(e,t)}})(e,{signal:i})]);return s.abort(),o}async*getMany(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};for await(const r of e)yield this.get(r,t)}unwant(e){const t=Array.isArray(e)?e:[e];this.wm.unwantBlocks(t),t.forEach((e=>this.notifications.unwantBlock(e)))}cancelWants(e){this.wm.cancelWants(Array.isArray(e)?e:[e])}async put(e,t,r){await this.blockstore.put(e,t),this._sendHaveBlockNotifications(e,t)}async*putMany(e,t){for await(const{key:r,value:n}of this.blockstore.putMany(e,t))this._sendHaveBlockNotifications(r,n),yield{key:r,value:n}}_sendHaveBlockNotifications(e,t){this.notifications.hasBlock(e,t),this.engine.receivedBlocks([{cid:e,data:t}]),this.network.provide(e).catch((e=>{this._log.error("Failed to provide: %s",e.message)}))}getWantlist(){return this.wm.wantlist.entries()}peers(){return this.engine.peers()}stat(){return this._stats}async start(){this.wm.start(),await this.network.start(),this.engine.start(),this.started=!0}async stop(){this._stats.stop(),this.wm.stop(),await this.network.stop(),this.engine.stop(),this.started=!1}unwrap(){return this.blockstore}}var Ll=r(24349);class Ml extends Ll.Ed{constructor(e,t){super(),this.child=e,this.bitswap=t}open(){return this.child.open()}close(){return this.child.close()}unwrap(){return this.child}async put(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};await this.has(e)||(this.bitswap.isStarted()?await this.bitswap.put(e,t,r):await this.child.put(e,t,r))}async*putMany(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const r=Gt(e,(async e=>{let{key:t}=e;return!await this.has(t)}));this.bitswap.isStarted()?yield*this.bitswap.putMany(r,t):yield*this.child.putMany(r,t)}async get(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return!await this.has(e)&&this.bitswap.isStarted()?this.bitswap.get(e,t):this.child.get(e,t)}async*getMany(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const r=Cs(),n=Cs();Promise.resolve().then((async()=>{for await(const t of e)!await this.has(t)&&this.bitswap.isStarted()?r.push(t):n.push(t);r.end(),n.end()})),yield*qs(this.bitswap.getMany(r,t),this.child.getMany(n,t))}async delete(e,t){await this.child.delete(e,t)}async*deleteMany(e,t){yield*this.child.deleteMany(e,t)}async has(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.child.has(e,t)}async*query(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};yield*this.child.query(e,t)}async*queryKeys(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};yield*this.child.queryKeys(e,t)}}class jl{constructor(e,t,r,n,s){this.peerId=e,this.libp2p=t,this.bitswap=r,this.repo=n,this.blockstore=s}static async start(e){let{peerId:t,repo:r,print:n,hashers:s,options:i}=e;r.closed&&await r.open();const o=await r.config.getAll(),a=await Uc({options:i,repo:r,peerId:t,multiaddrs:Ul(t,o),config:o,keychainConfig:void 0});a.keychain&&await a.loadKeychain(),await a.start();for(const u of a.multiaddrs)n(`Swarm listening on ${u}/p2p/${t.toB58String()}`);const c=function(e,t){return new Ol(e,t,arguments.length>2&&void 0!==arguments[2]?arguments[2]:{})}(a,r.blocks,{statsEnabled:!0,hashLoader:s});await c.start();const l=new Ml(r.blocks,c);return r.blocks=l,r.pins.blockstore=l,new jl(t,a,c,r,l)}static async stop(e){e.repo.blocks=e.blockstore.unwrap(),e.repo.pins.blockstore=e.blockstore.unwrap(),await e.bitswap.stop(),await e.libp2p.stop()}}const Ul=(e,t)=>{const r=e.toB58String(),n=[],s=t.Addresses&&t.Addresses.Swarm||[];for(const i of s){let e=new $t.Multiaddr(i);if(e.protoCodes().includes(zl))throw a(new Error("websocket-star swarm addresses are not supported. See https://github.com/ipfs/js-ipfs/issues/2779"),"ERR_WEBSOCKET_STAR_SWARM_ADDR_NOT_SUPPORTED");const t=e.getPeerId();t&&t!==r&&(e=e.encapsulate(`/p2p/${r}`)),n.push(e)}return n},zl=479;class Wl{constructor(e){let{network:t}=e;this.addrs=function(e){let{network:t}=e;return(0,q.a)((async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=[],{libp2p:n}=await t.use(e);for await(const t of n.peerStore.getPeers())r.push({id:t.id.toB58String(),addrs:t.addresses.map((e=>e.multiaddr))});return r}))}({network:t}),this.connect=function(e){let{network:t}=e;return(0,q.a)((async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{libp2p:n}=await t.use(r);await n.dial(e,r)}))}({network:t}),this.disconnect=function(e){let{network:t}=e;return(0,q.a)((async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{libp2p:n}=await t.use(r);await n.hangUp(e)}))}({network:t}),this.localAddrs=function(e){let{network:t}=e;return(0,q.a)((async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{libp2p:r}=await t.use(e);return r.multiaddrs}))}({network:t}),this.peers=function(e){let{network:t}=e;return(0,q.a)((async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{libp2p:r}=await t.use(e),n=[];for(const[t,s]of r.connections)for(const r of s){const s={addr:r.remoteAddr,peer:t};(e.verbose||e.direction)&&(s.direction=r.stat.direction),e.verbose&&(s.muxer=r.stat.multiplexer,s.latency="n/a",s.streams=[]),n.push(s)}return n}))}({network:t})}}const $l={success:!0,time:0,text:""};const Fl="/ipns/";function Kl(e){let t;if(e.startsWith(Fl)&&(e=e.substring(Fl.length)),"1"!==e[0]&&"Q"!==e[0]||(e=`z${e}`),"z"===e[0]&&(t=Ye.base58btc.decode(e)),"k"===e[0]&&(t=vt.base36.decode(e)),!t)throw new Error("Could not parse string");if(1!==t[0]&&114!==t[1]&&(t=(0,he.concat)([[1,114],t])),40!==t.length)throw new Error("Incorrect length "+t.length);return(0,he.concat)([(0,O.fromString)(Fl),t.subarray(2)])}function ql(e){if("SENDING_QUERY"===e.name)return{type:e.type,name:e.name,to:e.to.toB58String()};if("PEER_RESPONSE"===e.name)return{type:e.type,name:e.name,messageType:e.messageType,messageName:e.messageName,closer:e.closer.map((e=>{let{id:t,multiaddrs:r}=e;return{id:t.toB58String(),multiaddrs:r}})),providers:e.providers.map((e=>{let{id:t,multiaddrs:r}=e;return{id:t.toB58String(),multiaddrs:r}})),record:e.record,from:e.from.toB58String()};if("FINAL_PEER"===e.name)return{type:e.type,name:e.name,from:e.from.toB58String(),peer:{id:e.peer.id.toB58String(),multiaddrs:e.peer.multiaddrs}};if("QUERY_ERROR"===e.name)return{type:e.type,name:e.name,error:e.error,from:e.from.toB58String()};if("PROVIDER"===e.name)return{type:e.type,name:e.name,providers:e.providers.map((e=>{let{id:t,multiaddrs:r}=e;return{id:t.toB58String(),multiaddrs:r}})),from:e.from.toB58String()};if("VALUE"===e.name)return{type:e.type,name:e.name,value:e.value,from:e.from.toB58String()};if("ADDING_PEER"===e.name)return{type:e.type,name:e.name,peer:e.peer.toB58String()};if("DIALING_PEER"===e.name)return{type:e.type,name:e.name,peer:e.peer.toB58String()};throw a(new Error("Unknown DHT event type"),"ERR_UNKNOWN_DHT_EVENT")}const Hl=async(e,t,r)=>{const n=await e.use(r);if(Ze(n.libp2p,"_config.dht.enabled",!1))return n;{const e=async function*(){yield{from:t,name:"QUERY_ERROR",type:3,error:new N("dht not enabled")}};return{libp2p:{_dht:{get:e,put:e,findProvs:e,findPeer:e,provide:e,query:e}}}}};const Gl=async()=>{throw new N("pubsub not enabled")},Vl=s.Z.bind({ignoreUndefined:!0}),Xl=Object.assign(o("ipfs"),{error:o("ipfs:error")});class Jl{constructor(e){let{print:t,storage:r,codecs:n,options:s}=e;const{peerId:i,repo:o,keychain:c}=r,l=M.create(jl),u=mn(s.preload),d=(0,q.a)((async function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{recursive:!0};if("string"!==typeof e)throw new Error("Invalid arguments, domain must be a string");return K(e=H(e),t)})),h=(0,G.X)({network:l}),p=new gt(s),f=Object.values(P.kq);(s.ipld&&s.ipld.hashers?s.ipld.hashers:[]).forEach((e=>f.push(e))),this.hashers=new yi.d({hashers:f,loadHasher:s.ipld&&s.ipld.loadHasher});const g=Object.values(P.gh);(s.ipld&&s.ipld.bases?s.ipld.bases:[]).forEach((e=>g.push(e))),this.bases=new fi.x({bases:g,loadBase:s.ipld&&s.ipld.loadBase});const y=new ne({repo:o,codecs:n}),m=new Jt({codecs:n,hashers:this.hashers,preload:u,repo:o}),w=new At({dns:d,ipns:p,repo:o,codecs:n,peerId:i,isOnline:h,keychain:c,options:s}),b=function(e){let{repo:t,codecs:r,bases:n,name:s}=e;return(0,q.a)((async function(e){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!V.path(e))throw new Error("invalid argument "+e);if(V.ipnsPath(e))for await(const t of s.resolve(e,i))e=t;const[,o,a,...c]=e.split("/"),l=i.cidBase?await n.getBase(i.cidBase):void 0,u=Z(a);if(0===c.length)return`/${o}/${l?l.encoder.encode(u):a}`;const d=X.CID.decode(u);e=c.join("/");const h=(0,L.DB)(d,e,r,t,i);let p=d,f=e;for await(const t of h)X.CID.asCID(t.value)&&(p=t.value,f=t.remainderPath);return`/ipfs/${p.toString(l&&l.encoder)}${f?"/"+f:""}`}))}({repo:o,codecs:n,bases:this.bases,name:w}),v=new un({repo:o,codecs:n,hashers:this.hashers,preload:u}),_=Object.assign(function(e){let{repo:t,codecs:r,resolve:n,preload:s}=e;return async function*(e){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(0===i.maxDepth)return;if(i.edges&&i.format&&i.format!==Dt)throw new Error("Cannot set edges to true and also specify format");if(i.format=i.edges?Bt:i.format,"number"!==typeof i.maxDepth&&(i.maxDepth=i.recursive?1/0:1),i.timeout){const e=[new Rt.TimeoutController(i.timeout).signal];i.signal&&e.push(i.signal),i.signal=(0,Ct.anySignal)(e)}const o=(Array.isArray(e)?e:[e]).map((e=>xt(s,e,i)));for(const s of o)try{yield*Nt(n,t,r,s,i)}catch(a){yield{ref:"",err:a.message}}}}({repo:o,codecs:n,resolve:b,preload:u}),{local:Mt({repo:r.repo})}),{add:k,addAll:E,cat:I,get:S,ls:A}=new br({preload:u,repo:o,options:s.EXPERIMENTAL,hashers:this.hashers}),R=Ln({repo:o,preload:u,hashers:this.hashers,options:s}),C=function(e){let{preload:t,files:r,options:n={}}=e;if(n.interval=n.interval||3e4,!n.enabled){wn("MFS preload disabled");const e=async()=>{};return{start:e,stop:e}}let s,i="";const o=async()=>{try{const e=await r.stat("/"),a=e.cid.toString();i!==a&&(wn(`preloading updated MFS root ${i} -> ${e.cid}`),await t(e.cid),i=a)}catch(e){wn.error("failed to preload MFS root",e)}finally{s=setTimeout(o,n.interval)}};return{async start(){const e=await r.stat("/");i=e.cid.toString(),wn(`monitoring MFS root ${e.cid}`),s=setTimeout(o,n.interval)},stop(){clearTimeout(s)}}}({files:R,preload:u,options:s.preload});this.preload=u,this.name=w,this.ipns=p,this.pin=y,this.resolve=b,this.block=m,this.refs=_,this.start=function(e){let{network:t,preload:r,peerId:n,keychain:s,repo:i,ipns:o,mfsPreload:a,print:c,hashers:l,options:u}=e;return async()=>{const{libp2p:e}=await M.start(t,{peerId:n,repo:i,print:c,hashers:l,options:u});await Promise.all([o.startOnline({keychain:s,libp2p:e,peerId:n,repo:i}),r.start(),a.start()])}}({network:l,peerId:i,repo:o,preload:u,ipns:p,mfsPreload:C,print:t,keychain:c,hashers:this.hashers,options:s}),this.stop=function(e){let{network:t,preload:r,ipns:n,repo:s,mfsPreload:i}=e;return async()=>{await Promise.all([r.stop(),n.stop(),i.stop()]),await M.stop(t),await s.close()}}({network:l,preload:u,mfsPreload:C,ipns:p,repo:o}),this.dht=function(e){let{network:t,repo:r,peerId:n}=e;const{get:s,put:i,findProvs:o,findPeer:c,provide:l,query:u}={async*get(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{libp2p:s}=await Hl(t,n,r),i=e instanceof Uint8Array?e:Kl(e);yield*Ht(s._dht.get(i,r),ql)},async*put(e,r,s){const{libp2p:i}=await Hl(t,n,s),o=e instanceof Uint8Array?e:Kl(e);yield*Ht(i._dht.put(o,r),ql)},async*findProvs(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{libp2p:s}=await Hl(t,n,r);yield*Ht(s._dht.findProviders(e,{signal:r.signal}),ql)},async*findPeer(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{libp2p:s}=await Hl(t,n,r);yield*Ht(s._dht.findPeer(J.parse(e),{signal:r.signal}),ql)},async*provide(e){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{recursive:!1};const{libp2p:i}=await Hl(t,n,s);if(!await r.blocks.has(e))throw a(new Error("block(s) not found locally, cannot provide"),"ERR_BLOCK_NOT_FOUND");if(s.recursive)throw a(new Error("not implemented yet"),"ERR_NOT_IMPLEMENTED_YET");yield*Ht(i._dht.provide(e),ql)},async*query(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{libp2p:s}=await Hl(t,n,r);let i;const o=X.CID.asCID(e);i=null!=o?o.multihash.bytes:J.parse(e.toString()).toBytes(),yield*Ht(s._dht.getClosestPeers(i,r),ql)}};return{get:(0,q.a)(s),put:(0,q.a)(i),findProvs:(0,q.a)(o),findPeer:(0,q.a)(c),provide:(0,q.a)(l),query:(0,q.a)(u)}}({network:l,repo:o,peerId:i}),this.pubsub=function(e){let{network:t,config:r}=e;const n=Ze(r||{},"Pubsub.Enabled",!0);return{subscribe:n?(0,q.a)((async function(e,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{libp2p:s}=await t.use(n);return s.pubsub.subscribe(e,r,n)})):Gl,unsubscribe:n?(0,q.a)((async function(e,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{libp2p:s}=await t.use(n);s.pubsub.unsubscribe(e,r,n)})):Gl,publish:n?(0,q.a)((async function(e,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{libp2p:s}=await t.use(n);if(!r)throw a(new Error('argument "data" is required'),"ERR_ARG_REQUIRED");await s.pubsub.publish(e,r)})):Gl,ls:n?(0,q.a)((async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{libp2p:r}=await t.use(e);return r.pubsub.getTopics()})):Gl,peers:n?(0,q.a)((async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{libp2p:n}=await t.use(r);return n.pubsub.getSubscribers(e)})):Gl}}({network:l,config:s.config}),this.dns=d,this.isOnline=h,this.id=function(e){let{peerId:t,network:r}=e;return(0,q.a)((async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n=r.try();if(!n){if(e.peerId)throw new D;return{id:t.toB58String(),publicKey:(0,oe.toString)(t.pubKey.bytes,"base64pad"),addresses:[],agentVersion:`js-ipfs/${vr.Pr}`,protocolVersion:"9000",protocols:[]}}const{libp2p:s}=n,i=e.peerId?J.parse(e.peerId):t,o=await kr(i,s,e),a=(0,oe.toString)(o.metadata.get("AgentVersion")||new Uint8Array),c=(0,oe.toString)(o.metadata.get("ProtocolVersion")||new Uint8Array),l=o.id.toB58String(),u=o.publicKey?(0,oe.toString)(o.publicKey.bytes,"base64pad"):"";return{id:l,publicKey:u,addresses:(o.addresses||[]).map((e=>{const t=e.toString();return t.endsWith(`/p2p/${l}`)?t:`${t}/p2p/${l}`})).sort().map((e=>new $t.Multiaddr(e))),agentVersion:a,protocolVersion:c,protocols:(o.protocols||[]).sort()}}))}({network:l,peerId:i}),this.version=function(e){let{repo:t}=e;return(0,q.a)((async function(){const e=await t.version.get();return{version:vr.Pr,commit:vr.th,repo:`${e}`,"ipfs-core":vr.Pr,"interface-ipfs-core":vr.Px}}))}({repo:o}),this.bitswap=new Ut({network:l}),this.bootstrap=new Kt({repo:o}),this.config=function(e){let{repo:t}=e;return{getAll:(0,q.a)((async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.config.getAll(e)})),get:(0,q.a)((async function(e,r){return e?t.config.get(e,r):Promise.reject(new Error("key argument is required"))})),set:(0,q.a)((async function(e,r,n){return t.config.set(e,r,n)})),replace:(0,q.a)((async function(e,r){return t.config.replace(e,r)})),profiles:{apply:(0,q.a)((async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{dryRun:!1};const{dryRun:n}=r,s=Ir[e];if(!s)throw new Error(`No profile with name '${e}' exists`);try{const e=await t.config.getAll(r);let i=JSON.parse(JSON.stringify(e));return i=s.transform(i),n||await t.config.replace(i,r),delete e.Identity.PrivKey,delete i.Identity.PrivKey,{original:e,updated:i}}catch(i){throw Sr(i),new Error(`Could not apply profile '${e}' to config: ${i.message}`)}})),list:(0,q.a)(Pr)}}}({repo:o}),this.ping=function(e){let{network:t}=e;return(0,q.a)((async function*(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{libp2p:n}=await t.use();r.count=r.count||10;const s=J.createFromB58String(e),i=await n.peerStore.get(s);let o=i&&i.id;if(!o){yield{...$l,text:`Looking up peer ${e}`};const t=await n.peerRouting.findPeer(s);o=t&&t.id}if(!o)throw new Error("Peer was not found");yield{...$l,text:`PING ${o.toB58String()}`};let a=0,c=0;for(let t=0;t<r.count;t++)try{const e=await n.ping(o);c+=e,a++,yield{...$l,time:e}}catch(l){yield{...$l,success:!1,text:l.toString()}}if(a){const e=c/a;yield{...$l,text:`Average latency: ${e}ms`}}}))}({network:l}),this.add=k,this.addAll=E,this.cat=I,this.get=S,this.ls=A,this.dag=v,this.files=R,this.key=new Un({keychain:c}),this.object=new qn({preload:u,codecs:n,repo:o}),this.repo=new Jn({repo:o,hashers:this.hashers}),this.stats=new Yn({repo:o,network:l}),this.swarm=new Wl({network:l}),Object.defineProperty(this,"libp2p",{get(){const e=l.try();return e?e.libp2p:void 0}});const T=()=>Promise.reject(a(new Error("Not implemented"),"ERR_NOT_IMPLEMENTED"));this.commands=T,this.diag={cmds:T,net:T,sys:T},this.log={level:T,ls:T,tail:async function*(){throw a(new Error("Not implemented"),"ERR_NOT_IMPLEMENTED")}},this.mount=T,this.codecs=n}async init(){throw new T}}const Zl=async e=>{const t=l.encode({Data:new c.fL({type:"directory"}).marshal(),Links:[]}),r=await e.block.put(t,{mhtype:"sha2-256",format:"dag-pb"});return await e.pin.add(r),r},Yl=()=>({start:!0,EXPERIMENTAL:{},preload:{enabled:!i.isTest,addresses:["/dns4/node0.preload.ipfs.io/https","/dns4/node1.preload.ipfs.io/https","/dns4/node2.preload.ipfs.io/https","/dns4/node3.preload.ipfs.io/https"]}});r(64009);const Ql=async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};e=Vl(Yl(),e);const t=e.init||{},r={name:S.identity.name,code:S.identity.code,encode:e=>e,decode:e=>e},s=Object.values(P.QB);[l,u,n,I,r].concat(e.ipld&&e.ipld.codecs||[]).forEach((e=>s.push(e)));const i=new gi.w({codecs:s,loadCodec:e.ipld&&e.ipld.loadCodec}),o=e.silent?Xl:console.log;Xl("creating repo");const a=await $c.start(o,i,e);Xl("getting repo config");const c=await a.repo.config.getAll(),d=new Jl({storage:a,print:o,codecs:i,options:{...e,config:c}});if(Xl("starting preload"),await d.preload.start(),Xl("starting storage"),d.ipns.startOffline(a),a.isNew&&!t.emptyRepo){const e=await Zl(d);Xl("adding default assets"),await(0,A.L)({addAll:d.addAll,print:o}),Xl("initializing IPNS keyspace"),await d.ipns.initializeKeyspace(a.peerId.privKey,(0,O.fromString)(`/ipfs/${e}`))}return!1!==e.start&&(Xl("starting node"),await d.start()),d},eu=V},97085:(e,t,r)=>{"use strict";r.d(t,{AH:()=>p,DB:()=>w,Fb:()=>m,JU:()=>f,Nt:()=>d,i3:()=>g,iJ:()=>h,jr:()=>y,yH:()=>u});var n=r(13380),s=r(32743),i=r(82149),o=r(15504),a=r(41048),c=r(7901),l=r(47922);const u="This command must be run in online mode. Try running 'ipfs daemon' first.",d=new i.Key("/local/filesroot"),h=262144,p=e=>{if(s.CID.asCID(e))return`/ipfs/${e}`;const t=e.toString();try{return`/ipfs/${s.CID.parse(t)}`}catch{}if(n.path(t))return t;throw o(new Error(`invalid path: ${e}`),"ERR_BAD_PATH")},f=e=>e instanceof Uint8Array?s.CID.decode(e).toString():(0===(e=e.toString()).indexOf("/ipfs/")&&(e=e.substring("/ipfs/".length)),"/"===e.charAt(e.length-1)&&(e=e.substring(0,e.length-1)),e),g=async function(e,t,r){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const{cid:i,path:o}=(0,c.B)(r);o&&(n.path=o);let a=i,l=n.path||"";if(l.startsWith("/")&&(l=l.substring(1)),n.path)try{for await(const{value:r,remainderPath:o}of w(i,n.path,t,e,{signal:n.signal})){if(!s.CID.asCID(r))break;l=o,a=r}}catch(u){throw u.message.startsWith("Object has no property")&&(u.message=`no link named "${l.split("/")[0]}" under ${a}`,u.code="ERR_NO_LINK"),u}return{cid:a,remainderPath:l||""}},y=e=>{if("file"!==e.type&&"directory"!==e.type&&"raw"!==e.type)throw new Error(`Unknown node type '${e.type}'`);const t={cid:e.cid,path:e.path,name:e.name,size:e.size,type:"file"};return"directory"===e.type&&(t.type="dir"),"file"===e.type&&(t.size=e.unixfs.fileSize()),"file"!==e.type&&"directory"!==e.type||(t.mode=e.unixfs.mode,void 0!==e.unixfs.mtime&&(t.mtime=e.unixfs.mtime)),t},m=(0,a.a)((async(e,t)=>await e)),w=async function*(e,t,r,n,i){const a=async e=>{const t=await r.getCodec(e.code),s=await n.blocks.get(e,i);return t.decode(s)},c=t.split("/").filter(Boolean);let u=await a(e),d=e;for(;c.length;){const r=c.shift();if(!r)throw o(new Error(`Could not resolve path "${t}"`),"ERR_INVALID_PATH");if(e.code===l.code&&Array.isArray(u.Links)){const e=u.Links.find((e=>e.Name===r));if(e){yield{value:e.Hash,remainderPath:c.join("/")},u=await a(e.Hash),d=e.Hash;continue}}if(!Object.prototype.hasOwnProperty.call(u,r))throw o(new Error(`no link named "${r}" under ${d}`),"ERR_NO_LINK");u=u[r],yield{value:u,remainderPath:c.join("/")},s.CID.asCID(u)&&(d=u,u=await a(u))}yield{value:u,remainderPath:""}}},70732:(e,t,r)=>{"use strict";r.d(t,{j:()=>s});var n=r(44190);const s=e=>t=>e(new n.KU(t),t)},44190:(e,t,r)=>{"use strict";r.d(t,{KU:()=>b});var n=r(10006),s=r(41257),i=r(73620),o=r(60720),a=r(68170),c=r(664),l=r(62414),u=r(10912);const d=o("ipfs-http-client:lib:error-handler"),h=c.Z.bind({ignoreUndefined:!0}),p=s.isBrowser||s.isWebWorker?location.protocol:"http",f=s.isBrowser||s.isWebWorker?location.hostname:"localhost",g=s.isBrowser||s.isWebWorker?location.port:"5001",y=async e=>{let t;try{if((e.headers.get("Content-Type")||"").startsWith("application/json")){const r=await e.json();d(r),t=r.Message||r.message}else t=await e.text()}catch(n){d("Failed to parse error response",n),t=n.message}let r=new a.HTTPError(e);throw t&&(t.includes("deadline has elapsed")&&(r=new a.TimeoutError),t&&t.includes("context deadline exceeded")&&(r=new a.TimeoutError)),t&&t.includes("request timed out")&&(r=new a.TimeoutError),t&&(r.message=t),r},m=/[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g,w=e=>e.replace(m,(function(e){return"-"+e.toLowerCase()}));class b extends a{constructor(){var e;const t=function(){let e,t,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i={};if("string"===typeof r||n.Multiaddr.isMultiaddr(r))e=new URL((0,l.d)(r));else if(r instanceof URL)e=r;else if("string"===typeof r.url||n.Multiaddr.isMultiaddr(r.url))e=new URL((0,l.d)(r.url)),i=r;else if(r.url instanceof URL)e=r.url,i=r;else{i=r||{};const t=(i.protocol||p).replace(":",""),n=(i.host||f).split(":")[0],s=i.port||g;e=new URL(`${t}://${n}:${s}`)}if(i.apiPath?e.pathname=i.apiPath:"/"!==e.pathname&&void 0!==e.pathname||(e.pathname="api/v0"),s.isNode){const r=(0,u.Z)(e);t=i.agent||new r({keepAlive:!0,maxSockets:6})}return{...i,host:e.host,protocol:e.protocol.replace(":",""),port:Number(e.port),apiPath:e.pathname,url:e,agent:t}}(arguments.length>0&&void 0!==arguments[0]?arguments[0]:{});var r;super({timeout:(r=t.timeout||0,("string"===typeof r?(0,i.Z)(r):r)||void 0),headers:t.headers,base:`${t.url}`,handleError:y,transformSearchParams:e=>{const t=new URLSearchParams;for(const[r,n]of e)"undefined"!==n&&"null"!==n&&"signal"!==r&&t.append(w(r),n),"timeout"!==r||isNaN(n)||t.append(w(r),n);return t},agent:t.agent}),e=this,delete this.get,delete this.put,delete this.delete,delete this.options;const o=this.fetch;this.fetch=function(r){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return"string"!==typeof r||r.startsWith("/")||(r=`${t.url}/${r}`),o.call(e,r,h(n,{method:"POST"}))}}}a.HTTPError},39541:(e,t,r)=>{"use strict";r.d(t,{X:()=>i});var n=r(15059),s=r(13068);function i(){let{arg:e,searchParams:t,hashAlg:r,mtime:i,mode:o,...a}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};t&&(a={...a,...t}),r&&(a.hash=r),null!=i&&(i=(0,s.X)(i),a.mtime=i.secs,a.mtimeNsecs=i.nsecs),null!=o&&(a.mode=(0,n.Q)(o)),a.timeout&&!isNaN(a.timeout)&&(a.timeout=`${a.timeout}ms`),void 0===e||null===e?e=[]:Array.isArray(e)||(e=[e]);const c=new URLSearchParams(a);return e.forEach((e=>c.append("arg",e))),c}},38099:(e,t,r)=>{"use strict";r.r(t),r.d(t,{InvalidValueError:()=>o,MissingRepoOptionsError:()=>a,NonReversibleMigrationError:()=>n,NotInitializedRepoError:()=>s,RequiredParameterError:()=>i});class n extends Error{constructor(e){super(e),this.name="NonReversibleMigrationError",this.code=n.code,this.message=e}}n.code="ERR_NON_REVERSIBLE_MIGRATION";class s extends Error{constructor(e){super(e),this.name="NotInitializedRepoError",this.code=s.code,this.message=e}}s.code="ERR_NOT_INITIALIZED_REPO";class i extends Error{constructor(e){super(e),this.name="RequiredParameterError",this.code=i.code,this.message=e}}i.code="ERR_REQUIRED_PARAMETER";class o extends Error{constructor(e){super(e),this.name="InvalidValueError",this.code=o.code,this.message=e}}o.code="ERR_INVALID_VALUE";class a extends Error{constructor(e){super(e),this.name="MissingRepoOptionsError",this.code=a.code,this.message=e}}a.code="ERR_MISSING_REPO_OPTIONS"},61757:(e,t,r)=>{"use strict";r.d(t,{fR:()=>i,pf:()=>l,s0:()=>a,xW:()=>o});var n=r(82149),s=r(66957);const i=new n.Key("/config"),o=new n.Key("/version");function a(e){let t=e;for(;t.db||t.child;)if(t=t.db||t.child,"level-js"===t.type||"Level"===t.constructor.name)return t}function c(e){const t=e.get.bind(e),r=e.has.bind(e);return e.get=n=>async function(e,t,r,n){if(await r(e))return t(e);const i=a(n);if(!i)throw(0,s.notFoundError)();return new Promise(((t,r)=>{const n=i.store("readonly").get(e.toString());n.transaction.onabort=()=>{r(n.transaction.error)},n.transaction.oncomplete=()=>{if(n.result)return t(n.result);r((0,s.notFoundError)())}}))}(n,t,r,e),e.has=t=>async function(e,t,r){const n=await t(e);if(n)return n;const s=a(r);return!!s&&new Promise(((t,r)=>{const n=s.store("readonly").get(e.toString());n.transaction.onabort=()=>{r(n.transaction.error)},n.transaction.oncomplete=()=>{t(Boolean(n.result))}}))}(t,r,e),e}function l(e){return{...e,root:c(e.root),datastore:c(e.datastore),pins:c(e.pins),keys:c(e.keys)}}},48206:(e,t,r)=>{"use strict";r.d(t,{BE:()=>u,HN:()=>c,OY:()=>l});var n=r(15504),s=r(32743),i=r(20513),o=r(16586);const a=e=>{if(e instanceof Uint8Array)return{cid:s.CID.decode(e),toResolve:[]};const t=s.CID.asCID(e);if(t)return{cid:t,toResolve:[]};if("string"===typeof e){0===e.indexOf("/ipfs/")&&(e=e.substring(6));const t=function(){return((arguments.length>0&&void 0!==arguments[0]?arguments[0]:"").trim().match(/([^\\^/]|\\\/)+/g)||[]).filter(Boolean)}(e);return{cid:s.CID.parse(t[0]),toResolve:t.slice(1)}}throw n(new Error(`Unknown path type ${e}`),"ERR_BAD_PATH")};async function*c(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},{cid:s,toResolve:o}=a(e),c=s.toString(),l=c;const u=o.length;for(;;){const a=await(0,i.Z)(s,c,l,o,u,t,r);if(!a.entry&&!a.next)throw n(new Error(`Could not resolve ${e}`),"ERR_NOT_FOUND");if(a.entry&&(yield a.entry),!a.next)return;o=a.next.toResolve,s=a.next.cid,c=a.next.name,l=a.next.path}}async function l(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=await o(c(e,t,r));if(!s)throw n(new Error(`Could not resolve ${e}`),"ERR_NOT_FOUND");return s}async function*u(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const n=await l(e,t,r);if(n&&(yield n,"directory"===n.type))for await(const i of s(n,r))yield i;async function*s(e,t){for await(const r of e.content(t))yield r,r instanceof Uint8Array||"directory"===r.type&&(yield*s(r,t))}}},46224:(e,t,r)=>{"use strict";r.d(t,{Z:()=>a});var n=r(88411),s=r(22580),i=r(45711),o=r(49067);async function*a(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=(0,s.Z)(r);let c,l,u;c="function"===typeof r.dagBuilder?r.dagBuilder:i.Z,l="function"===typeof r.treeBuilder?r.treeBuilder:o.Z,u=Symbol.asyncIterator in e||Symbol.iterator in e?e:[e];for await(const s of l(n(c(u,t,a),a.fileImportConcurrency),t,a))yield{cid:s.cid,path:s.path,unixfs:s.unixfs,size:s.size}}},5724:(e,t,r)=>{"use strict";r.d(t,{Xu:()=>u,fL:()=>d,tK:()=>l});var n=r(15504);const s=r(46766).Vw,i=["raw","directory","file","metadata","symlink","hamt-sharded-directory"],o=["directory","hamt-sharded-directory"],a=parseInt("0644",8),c=parseInt("0755",8);function l(e){if(null!=e)return"number"===typeof e?4095&e:"0"===(e=e.toString()).substring(0,1)?4095&parseInt(e,8):4095&parseInt(e,10)}function u(e){if(null==e)return;let t;if(null!=e.secs&&(t={secs:e.secs,nsecs:e.nsecs}),null!=e.Seconds&&(t={secs:e.Seconds,nsecs:e.FractionalNanoseconds}),Array.isArray(e)&&(t={secs:e[0],nsecs:e[1]}),e instanceof Date){const r=e.getTime(),n=Math.floor(r/1e3);t={secs:n,nsecs:1e3*(r-1e3*n)}}if(Object.prototype.hasOwnProperty.call(t,"secs")){if(null!=t&&null!=t.nsecs&&(t.nsecs<0||t.nsecs>999999999))throw n(new Error("mtime-nsecs must be within the range [0,999999999]"),"ERR_INVALID_MTIME_NSECS");return t}}class d{static unmarshal(e){const t=s.decode(e),r=s.toObject(t,{defaults:!1,arrays:!0,longs:Number,objects:!1}),n=new d({type:i[r.Type],data:r.Data,blockSizes:r.blocksizes,mode:r.mode,mtime:r.mtime?{secs:r.mtime.Seconds,nsecs:r.mtime.FractionalNanoseconds}:void 0});return n._originalMode=r.mode||0,n}constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{type:"file"};const{type:t,data:r,blockSizes:s,hashType:o,fanout:a,mtime:c,mode:d}=e;if(t&&!i.includes(t))throw n(new Error("Type: "+t+" is not valid"),"ERR_INVALID_TYPE");this.type=t||"file",this.data=r,this.hashType=o,this.fanout=a,this.blockSizes=s||[],this._originalMode=0,this.mode=l(d),c&&(this.mtime=u(c),this.mtime&&!this.mtime.nsecs&&(this.mtime.nsecs=0))}set mode(e){this._mode=this.isDirectory()?c:a;const t=l(e);void 0!==t&&(this._mode=t)}get mode(){return this._mode}isDirectory(){return Boolean(this.type&&o.includes(this.type))}addBlockSize(e){this.blockSizes.push(e)}removeBlockSize(e){this.blockSizes.splice(e,1)}fileSize(){if(this.isDirectory())return 0;let e=0;return this.blockSizes.forEach((t=>{e+=t})),this.data&&(e+=this.data.length),e}marshal(){let e;switch(this.type){case"raw":e=s.DataType.Raw;break;case"directory":e=s.DataType.Directory;break;case"file":e=s.DataType.File;break;case"metadata":e=s.DataType.Metadata;break;case"symlink":e=s.DataType.Symlink;break;case"hamt-sharded-directory":e=s.DataType.HAMTShard;break;default:throw n(new Error("Type: "+e+" is not valid"),"ERR_INVALID_TYPE")}let t,r,i=this.data;if(this.data&&this.data.length||(i=void 0),null!=this.mode&&(t=4294963200&this._originalMode|(l(this.mode)||0),t!==a||this.isDirectory()||(t=void 0),t===c&&this.isDirectory()&&(t=void 0)),null!=this.mtime){const e=u(this.mtime);e&&(r={Seconds:e.secs,FractionalNanoseconds:e.nsecs},0===r.FractionalNanoseconds&&delete r.FractionalNanoseconds)}const o={Type:e,Data:i,filesize:this.isDirectory()?void 0:this.fileSize(),blocksizes:this.blockSizes,hashType:this.hashType,fanout:this.fanout,mode:t,mtime:r};return s.encode(o).finish()}}},664:(e,t,r)=>{"use strict";r.d(t,{Z:()=>n});const n=r(47250)},71659:(e,t,r)=>{"use strict";r.r(t),r.d(t,{base36:()=>s,base36upper:()=>i});var n=r(17384);const s=(0,n.kU)({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),i=(0,n.kU)({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"})},43019:(e,t,r)=>{"use strict";r.r(t),r.d(t,{base58btc:()=>s,base58flickr:()=>i});var n=r(17384);const s=(0,n.kU)({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),i=(0,n.kU)({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"})},40963:(e,t,r)=>{"use strict";r.d(t,{QB:()=>w,gh:()=>y,kq:()=>m});var n=r(17527),s=r(14906),i=r(90247),o=r(86955),a=r(2180),c=r(79357),l=r(71659),u=r(43019),d=r(63225),h=r(92829),p=r(80073),f=r(96602),g=r(39928);r(28546);const y={...n,...s,...i,...o,...a,...c,...l,...u,...d},m={...h,...p},w={raw:f,json:g}},83737:(e,t,r)=>{"use strict";r.d(t,{OV:()=>c,gO:()=>a});var n=r(28546);const s=function(){let{enumerable:e=!0,configurable:t=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return{enumerable:e,configurable:t,writable:!1}},i=function*(e,t){if(null!=e&&!(e instanceof Uint8Array))for(const[r,s]of Object.entries(e)){const e=[...t,r];if(null!=s&&"object"===typeof s)if(Array.isArray(s))for(const[t,r]of s.entries()){const s=[...e,t],o=n.k0.asCID(r);o?yield[s.join("/"),o]:"object"===typeof r&&(yield*i(r,s))}else{const t=n.k0.asCID(s);t?yield[e.join("/"),t]:yield*i(s,e)}}},o=function*(e,t){if(null!=e)for(const[r,s]of Object.entries(e)){const e=[...t,r];if(yield e.join("/"),null!=s&&!(s instanceof Uint8Array)&&"object"===typeof s&&!n.k0.asCID(s))if(Array.isArray(s))for(const[t,r]of s.entries()){const s=[...e,t];yield s.join("/"),"object"!==typeof r||n.k0.asCID(r)||(yield*o(r,s))}else yield*o(s,e)}};class a{constructor(e){let{cid:t,bytes:r,value:n}=e;if(!t||!r||"undefined"===typeof n)throw new Error("Missing required argument");this.cid=t,this.bytes=r,this.value=n,this.asBlock=this,Object.defineProperties(this,{cid:s(),bytes:s(),value:s(),asBlock:s()})}links(){return i(this.value,[])}tree(){return o(this.value,[])}get(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"/";return((e,t)=>{let r=e;for(const[s,i]of t.entries()){if(r=r[i],null==r)throw new Error(`Object has no property at ${t.slice(0,s+1).map((e=>`[${JSON.stringify(e)}]`)).join("")}`);const e=n.k0.asCID(r);if(e)return{value:e,remaining:t.slice(s+1).join("/")}}return{value:r}})(this.value,e.split("/").filter(Boolean))}}const c=e=>{let{bytes:t,cid:r,value:n,codec:s}=e;const i=void 0!==n?n:s&&s.decode(t);if(void 0===i)throw new Error('Missing required argument, must either provide "value" or "codec"');return new a({cid:r,bytes:t,value:i})}},80073:(e,t,r)=>{"use strict";r.r(t),r.d(t,{identity:()=>o});var n=r(17893),s=r(17578);const i=n.coerce,o={code:0,name:"identity",encode:i,digest:e=>s.create(0,i(e))}},92829:(e,t,r)=>{"use strict";r.r(t),r.d(t,{sha256:()=>i,sha512:()=>o});var n=r(32616);const s=e=>async t=>new Uint8Array(await crypto.subtle.digest(e,t)),i=(0,n.D)({name:"sha2-256",code:18,encode:s("SHA-256")}),o=(0,n.D)({name:"sha2-512",code:19,encode:s("SHA-512")})},73620:(e,t,r)=>{"use strict";r.d(t,{Z:()=>o});let n=/(-?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*([\p{L}]*)/giu;function s(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"ms";var r=null;return e=(e+"").replace(/(\d)[,_](\d)/g,"$1$2"),e.replace(n,(function(e,t,n){(n=i(n))&&(r=(r||0)+parseFloat(t,10)*n)})),r&&r/(i(t)||1)}function i(e){return s[e]||s[e.toLowerCase().replace(/s$/,"")]}s.nanosecond=s.ns=1e-6,s["\xb5s"]=s["\u03bcs"]=s.us=s.microsecond=.001,s.millisecond=s.ms=s[""]=1,s.second=s.sec=s.s=1e3*s.ms,s.minute=s.min=s.m=60*s.s,s.hour=s.hr=s.h=60*s.m,s.day=s.d=24*s.h,s.week=s.wk=s.w=7*s.d,s.month=s.b=30.4375*s.d,s.year=s.yr=s.y=365.25*s.d;const o=s},68425:(e,t,r)=>{"use strict";r.r(t),r.d(t,{fromString:()=>s});var n=r(71124);function s(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf8";const r=n.Z[t];if(!r)throw new Error(`Unsupported encoding "${t}"`);return r.decoder.decode(`${r.prefix}${e}`)}},93314:(e,t,r)=>{"use strict";r.r(t),r.d(t,{toString:()=>s});var n=r(71124);function s(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf8";const r=n.Z[t];if(!r)throw new Error(`Unsupported encoding "${t}"`);return r.encoder.encode(e).substring(1)}}}]);
//# sourceMappingURL=vendors-node_modules_senswap_sen-js_dist_utils_js-node_modules_base64-js_index_js-node_module-343e97.698453ea.chunk.js.map