/*! For license information please see 398.94cd9c00.chunk.js.LICENSE.txt */
(globalThis.webpackChunkinterdao=globalThis.webpackChunkinterdao||[]).push([[398],{65967:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),s=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.NOISE=void 0;const o=r(28705);s(r(28705),t),t.NOISE=new o.Noise},40316:(e,t)=>{"use strict";const r=Math.exp;e.exports=function(e){if("number"!==typeof e)throw new Error("must provide a timespan to the moving average constructor");if(e<=0)throw new Error("must provide a timespan > 0 to the moving average constructor");let t,n,s=0,o=0,i=0,a={};return a.push=function(a,c){if(n){const l=1-r(-(a-n)/e),d=c-t;t=l*c+(1-l)*t,s=(1-l)*(s+d*(l*d)),o=Math.sqrt(s),i=t+l*d}else t=c;n=a},a.movingAverage=function(){return t},a.variance=function(){return s},a.deviation=function(){return o},a.forecast=function(){return i},a}},98691:e=>{function t(e){const t=new globalThis.AbortController;function r(){t.abort();for(const t of e)t&&t.removeEventListener&&t.removeEventListener("abort",r)}for(const n of e)if(n&&n.addEventListener){if(n.aborted){r();break}n.addEventListener("abort",r)}return t.signal}e.exports=t,e.exports.anySignal=t},76297:e=>{"use strict";e.exports=e=>{if(!Array.isArray(e))throw new TypeError("Expected an array, got "+typeof e);for(let t=(e=[...e]).length-1;t>0;t--){const r=Math.floor(Math.random()*(t+1));[e[t],e[r]]=[e[r],e[t]]}return e}},12009:(e,t)=>{"use strict";t.byteLength=function(e){var t=c(e),r=t[0],n=t[1];return 3*(r+n)/4-n},t.toByteArray=function(e){var t,r,o=c(e),i=o[0],a=o[1],l=new s(function(e,t,r){return 3*(t+r)/4-r}(0,i,a)),d=0,h=a>0?i-4:i;for(r=0;r<h;r+=4)t=n[e.charCodeAt(r)]<<18|n[e.charCodeAt(r+1)]<<12|n[e.charCodeAt(r+2)]<<6|n[e.charCodeAt(r+3)],l[d++]=t>>16&255,l[d++]=t>>8&255,l[d++]=255&t;2===a&&(t=n[e.charCodeAt(r)]<<2|n[e.charCodeAt(r+1)]>>4,l[d++]=255&t);1===a&&(t=n[e.charCodeAt(r)]<<10|n[e.charCodeAt(r+1)]<<4|n[e.charCodeAt(r+2)]>>2,l[d++]=t>>8&255,l[d++]=255&t);return l},t.fromByteArray=function(e){for(var t,n=e.length,s=n%3,o=[],i=16383,a=0,c=n-s;a<c;a+=i)o.push(l(e,a,a+i>c?c:a+i));1===s?(t=e[n-1],o.push(r[t>>2]+r[t<<4&63]+"==")):2===s&&(t=(e[n-2]<<8)+e[n-1],o.push(r[t>>10]+r[t>>4&63]+r[t<<2&63]+"="));return o.join("")};for(var r=[],n=[],s="undefined"!==typeof Uint8Array?Uint8Array:Array,o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",i=0,a=o.length;i<a;++i)r[i]=o[i],n[o.charCodeAt(i)]=i;function c(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=e.indexOf("=");return-1===r&&(r=t),[r,r===t?0:4-r%4]}function l(e,t,n){for(var s,o,i=[],a=t;a<n;a+=3)s=(e[a]<<16&16711680)+(e[a+1]<<8&65280)+(255&e[a+2]),i.push(r[(o=s)>>18&63]+r[o>>12&63]+r[o>>6&63]+r[63&o]);return i.join("")}n["-".charCodeAt(0)]=62,n["_".charCodeAt(0)]=63},31156:(e,t,r)=>{"use strict";const n=r(55194);e.exports=function(e){return"function"===typeof e.stream?n(e.stream()):n(new Response(e).body)}},55194:e=>{"use strict";e.exports=async function*(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const r=e.getReader();try{for(;;){const e=await r.read();if(e.done)return;yield e.value}}finally{!0!==t.preventCancel&&r.cancel(),r.releaseLock()}}},77073:e=>{"use strict";e.exports=function(e,t){if("string"===typeof e)return i(e);if("number"===typeof e)return o(e,t);return null},e.exports.format=o,e.exports.parse=i;var t=/\B(?=(\d{3})+(?!\d))/g,r=/(?:\.0*|(\.[^0]+)0+)$/,n={b:1,kb:1024,mb:1<<20,gb:1<<30,tb:Math.pow(1024,4),pb:Math.pow(1024,5)},s=/^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;function o(e,s){if(!Number.isFinite(e))return null;var o=Math.abs(e),i=s&&s.thousandsSeparator||"",a=s&&s.unitSeparator||"",c=s&&void 0!==s.decimalPlaces?s.decimalPlaces:2,l=Boolean(s&&s.fixedDecimals),d=s&&s.unit||"";d&&n[d.toLowerCase()]||(d=o>=n.pb?"PB":o>=n.tb?"TB":o>=n.gb?"GB":o>=n.mb?"MB":o>=n.kb?"KB":"B");var h=(e/n[d.toLowerCase()]).toFixed(c);return l||(h=h.replace(r,"$1")),i&&(h=h.split(".").map((function(e,r){return 0===r?e.replace(t,i):e})).join(".")),h+a+d}function i(e){if("number"===typeof e&&!isNaN(e))return e;if("string"!==typeof e)return null;var t,r=s.exec(e),o="b";return r?(t=parseFloat(r[1]),o=r[4].toLowerCase()):(t=parseInt(e,10),o="b"),isNaN(t)?null:Math.floor(n[o]*t)}},58735:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),s=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&n(t,e,r);return s(t,e),t},i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.decode=t.encode=t.toGeneral=t.code=t.name=void 0;const a=i(r(53692)),c=i(r(515)),l=o(r(86888));function d(e){return"payload"in e&&"string"===typeof e.payload&&"signatures"in e&&Array.isArray(e.signatures)}function h(e){return"ciphertext"in e&&"string"===typeof e.ciphertext&&"iv"in e&&"string"===typeof e.iv&&"protected"in e&&"string"===typeof e.protected&&"tag"in e&&"string"===typeof e.tag}function u(e){if("string"===typeof e){const t=e.split(".");if(3===t.length)return a.default.fromSplit(t);if(5===t.length)return c.default.fromSplit(t);throw new Error("Not a valid JOSE string")}if(d(e)||h(e))return e;throw new Error("Not a valid unencoded JOSE object")}t.name="dag-jose",t.code=133,t.toGeneral=u,t.encode=function(e){let t;if("string"===typeof e&&(e=u(e)),d(e))t=a.default.encode(e);else{if(!h(e))throw new Error("Not a valid JOSE object");t=c.default.encode(e)}return new Uint8Array(l.encode(t))},t.decode=function(e){let t;try{t=l.decode(e)}catch(n){throw new Error("Not a valid DAG-JOSE object")}if("payload"in(r=t)&&r.payload instanceof Uint8Array&&"signatures"in r&&Array.isArray(r.signatures))return a.default.decode(t);if(function(e){return"ciphertext"in e&&e.ciphertext instanceof Uint8Array&&"iv"in e&&e.iv instanceof Uint8Array&&"protected"in e&&e.protected instanceof Uint8Array&&"tag"in e&&e.tag instanceof Uint8Array}(t))return c.default.decode(t);throw new Error("Not a valid DAG-JOSE object");var r}},60720:(e,t,r)=>{t.formatArgs=function(t){if(t[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+t[0]+(this.useColors?"%c ":" ")+"+"+e.exports.humanize(this.diff),!this.useColors)return;const r="color: "+this.color;t.splice(1,0,r,"color: inherit");let n=0,s=0;t[0].replace(/%[a-zA-Z%]/g,(e=>{"%%"!==e&&(n++,"%c"===e&&(s=n))})),t.splice(s,0,r)},t.save=function(e){try{e?t.storage.setItem("debug",e):t.storage.removeItem("debug")}catch(r){}},t.load=function(){let e;try{e=t.storage.getItem("debug")}catch(r){}!e&&"undefined"!==typeof process&&"env"in process&&(e={NODE_ENV:"production",PUBLIC_URL:"",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0,REACT_APP_ENV:"production",REACT_APP_ID:"interdao",REACT_APP_NAME:"InterDAO",REACT_APP_AUTHOR_NAME:"Descartes Network",REACT_APP_AUTHOR_EMAIL:"hello@descartes.network",REACT_APP_TAGS:"dapps,dao",REACT_APP_DESCRIPTION:"\ud83c\udf0f InterDAO is a universal DAO solution that projects on Solana can seamlessly construct their owned DAO.",REACT_APP_URL:"https://descartesnetwork.github.io/interdao.so/index.js"}.DEBUG);return e},t.useColors=function(){if("undefined"!==typeof window&&window.process&&("renderer"===window.process.type||window.process.__nwjs))return!0;if("undefined"!==typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))return!1;return"undefined"!==typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!==typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!==typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!==typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)},t.storage=function(){try{return localStorage}catch(e){}}(),t.destroy=(()=>{let e=!1;return()=>{e||(e=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),t.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],t.log=console.debug||console.log||(()=>{}),e.exports=r(87565)(t);const{formatters:n}=e.exports;n.j=function(e){try{return JSON.stringify(e)}catch(t){return"[UnexpectedJSONParseError]: "+t.message}}},21613:function(e){e.exports=function(e,t,r,n,s){for(t=t.split?t.split("."):t,n=0;n<t.length;n++)e=e?e[t[n]]:s;return e===s?r:e}},15504:e=>{"use strict";function t(e,t){for(const r in t)Object.defineProperty(e,r,{value:t[r],enumerable:!0,configurable:!0});return e}e.exports=function(e,r,n){if(!e||"string"===typeof e)throw new TypeError("Please pass an Error to err-code");n||(n={}),"object"===typeof r&&(n=r,r=""),r&&(n.code=r);try{return t(e,n)}catch(s){n.message=e.message,n.stack=e.stack;const r=function(){};r.prototype=Object.create(Object.getPrototypeOf(e));return t(new r,n)}}},48449:e=>{"use strict";var t=Object.prototype.hasOwnProperty,r="~";function n(){}function s(e,t,r){this.fn=e,this.context=t,this.once=r||!1}function o(e,t,n,o,i){if("function"!==typeof n)throw new TypeError("The listener must be a function");var a=new s(n,o||e,i),c=r?r+t:t;return e._events[c]?e._events[c].fn?e._events[c]=[e._events[c],a]:e._events[c].push(a):(e._events[c]=a,e._eventsCount++),e}function i(e,t){0===--e._eventsCount?e._events=new n:delete e._events[t]}function a(){this._events=new n,this._eventsCount=0}Object.create&&(n.prototype=Object.create(null),(new n).__proto__||(r=!1)),a.prototype.eventNames=function(){var e,n,s=[];if(0===this._eventsCount)return s;for(n in e=this._events)t.call(e,n)&&s.push(r?n.slice(1):n);return Object.getOwnPropertySymbols?s.concat(Object.getOwnPropertySymbols(e)):s},a.prototype.listeners=function(e){var t=r?r+e:e,n=this._events[t];if(!n)return[];if(n.fn)return[n.fn];for(var s=0,o=n.length,i=new Array(o);s<o;s++)i[s]=n[s].fn;return i},a.prototype.listenerCount=function(e){var t=r?r+e:e,n=this._events[t];return n?n.fn?1:n.length:0},a.prototype.emit=function(e,t,n,s,o,i){var a=r?r+e:e;if(!this._events[a])return!1;var c,l,d=this._events[a],h=arguments.length;if(d.fn){switch(d.once&&this.removeListener(e,d.fn,void 0,!0),h){case 1:return d.fn.call(d.context),!0;case 2:return d.fn.call(d.context,t),!0;case 3:return d.fn.call(d.context,t,n),!0;case 4:return d.fn.call(d.context,t,n,s),!0;case 5:return d.fn.call(d.context,t,n,s,o),!0;case 6:return d.fn.call(d.context,t,n,s,o,i),!0}for(l=1,c=new Array(h-1);l<h;l++)c[l-1]=arguments[l];d.fn.apply(d.context,c)}else{var u,p=d.length;for(l=0;l<p;l++)switch(d[l].once&&this.removeListener(e,d[l].fn,void 0,!0),h){case 1:d[l].fn.call(d[l].context);break;case 2:d[l].fn.call(d[l].context,t);break;case 3:d[l].fn.call(d[l].context,t,n);break;case 4:d[l].fn.call(d[l].context,t,n,s);break;default:if(!c)for(u=1,c=new Array(h-1);u<h;u++)c[u-1]=arguments[u];d[l].fn.apply(d[l].context,c)}}return!0},a.prototype.on=function(e,t,r){return o(this,e,t,r,!1)},a.prototype.once=function(e,t,r){return o(this,e,t,r,!0)},a.prototype.removeListener=function(e,t,n,s){var o=r?r+e:e;if(!this._events[o])return this;if(!t)return i(this,o),this;var a=this._events[o];if(a.fn)a.fn!==t||s&&!a.once||n&&a.context!==n||i(this,o);else{for(var c=0,l=[],d=a.length;c<d;c++)(a[c].fn!==t||s&&!a[c].once||n&&a[c].context!==n)&&l.push(a[c]);l.length?this._events[o]=1===l.length?l[0]:l:i(this,o)}return this},a.prototype.removeAllListeners=function(e){var t;return e?(t=r?r+e:e,this._events[t]&&i(this,t)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=r,a.EventEmitter=a,e.exports=a},36571:e=>{"use strict";var t,r="object"===typeof Reflect?Reflect:null,n=r&&"function"===typeof r.apply?r.apply:function(e,t,r){return Function.prototype.apply.call(e,t,r)};t=r&&"function"===typeof r.ownKeys?r.ownKeys:Object.getOwnPropertySymbols?function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:function(e){return Object.getOwnPropertyNames(e)};var s=Number.isNaN||function(e){return e!==e};function o(){o.init.call(this)}e.exports=o,e.exports.once=function(e,t){return new Promise((function(r,n){function s(r){e.removeListener(t,o),n(r)}function o(){"function"===typeof e.removeListener&&e.removeListener("error",s),r([].slice.call(arguments))}g(e,t,o,{once:!0}),"error"!==t&&function(e,t,r){"function"===typeof e.on&&g(e,"error",t,r)}(e,s,{once:!0})}))},o.EventEmitter=o,o.prototype._events=void 0,o.prototype._eventsCount=0,o.prototype._maxListeners=void 0;var i=10;function a(e){if("function"!==typeof e)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof e)}function c(e){return void 0===e._maxListeners?o.defaultMaxListeners:e._maxListeners}function l(e,t,r,n){var s,o,i,l;if(a(r),void 0===(o=e._events)?(o=e._events=Object.create(null),e._eventsCount=0):(void 0!==o.newListener&&(e.emit("newListener",t,r.listener?r.listener:r),o=e._events),i=o[t]),void 0===i)i=o[t]=r,++e._eventsCount;else if("function"===typeof i?i=o[t]=n?[r,i]:[i,r]:n?i.unshift(r):i.push(r),(s=c(e))>0&&i.length>s&&!i.warned){i.warned=!0;var d=new Error("Possible EventEmitter memory leak detected. "+i.length+" "+String(t)+" listeners added. Use emitter.setMaxListeners() to increase limit");d.name="MaxListenersExceededWarning",d.emitter=e,d.type=t,d.count=i.length,l=d,console&&console.warn&&console.warn(l)}return e}function d(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function h(e,t,r){var n={fired:!1,wrapFn:void 0,target:e,type:t,listener:r},s=d.bind(n);return s.listener=r,n.wrapFn=s,s}function u(e,t,r){var n=e._events;if(void 0===n)return[];var s=n[t];return void 0===s?[]:"function"===typeof s?r?[s.listener||s]:[s]:r?function(e){for(var t=new Array(e.length),r=0;r<t.length;++r)t[r]=e[r].listener||e[r];return t}(s):f(s,s.length)}function p(e){var t=this._events;if(void 0!==t){var r=t[e];if("function"===typeof r)return 1;if(void 0!==r)return r.length}return 0}function f(e,t){for(var r=new Array(t),n=0;n<t;++n)r[n]=e[n];return r}function g(e,t,r,n){if("function"===typeof e.on)n.once?e.once(t,r):e.on(t,r);else{if("function"!==typeof e.addEventListener)throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof e);e.addEventListener(t,(function s(o){n.once&&e.removeEventListener(t,s),r(o)}))}}Object.defineProperty(o,"defaultMaxListeners",{enumerable:!0,get:function(){return i},set:function(e){if("number"!==typeof e||e<0||s(e))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+e+".");i=e}}),o.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},o.prototype.setMaxListeners=function(e){if("number"!==typeof e||e<0||s(e))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+e+".");return this._maxListeners=e,this},o.prototype.getMaxListeners=function(){return c(this)},o.prototype.emit=function(e){for(var t=[],r=1;r<arguments.length;r++)t.push(arguments[r]);var s="error"===e,o=this._events;if(void 0!==o)s=s&&void 0===o.error;else if(!s)return!1;if(s){var i;if(t.length>0&&(i=t[0]),i instanceof Error)throw i;var a=new Error("Unhandled error."+(i?" ("+i.message+")":""));throw a.context=i,a}var c=o[e];if(void 0===c)return!1;if("function"===typeof c)n(c,this,t);else{var l=c.length,d=f(c,l);for(r=0;r<l;++r)n(d[r],this,t)}return!0},o.prototype.addListener=function(e,t){return l(this,e,t,!1)},o.prototype.on=o.prototype.addListener,o.prototype.prependListener=function(e,t){return l(this,e,t,!0)},o.prototype.once=function(e,t){return a(t),this.on(e,h(this,e,t)),this},o.prototype.prependOnceListener=function(e,t){return a(t),this.prependListener(e,h(this,e,t)),this},o.prototype.removeListener=function(e,t){var r,n,s,o,i;if(a(t),void 0===(n=this._events))return this;if(void 0===(r=n[e]))return this;if(r===t||r.listener===t)0===--this._eventsCount?this._events=Object.create(null):(delete n[e],n.removeListener&&this.emit("removeListener",e,r.listener||t));else if("function"!==typeof r){for(s=-1,o=r.length-1;o>=0;o--)if(r[o]===t||r[o].listener===t){i=r[o].listener,s=o;break}if(s<0)return this;0===s?r.shift():function(e,t){for(;t+1<e.length;t++)e[t]=e[t+1];e.pop()}(r,s),1===r.length&&(n[e]=r[0]),void 0!==n.removeListener&&this.emit("removeListener",e,i||t)}return this},o.prototype.off=o.prototype.removeListener,o.prototype.removeAllListeners=function(e){var t,r,n;if(void 0===(r=this._events))return this;if(void 0===r.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==r[e]&&(0===--this._eventsCount?this._events=Object.create(null):delete r[e]),this;if(0===arguments.length){var s,o=Object.keys(r);for(n=0;n<o.length;++n)"removeListener"!==(s=o[n])&&this.removeAllListeners(s);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"===typeof(t=r[e]))this.removeListener(e,t);else if(void 0!==t)for(n=t.length-1;n>=0;n--)this.removeListener(e,t[n]);return this},o.prototype.listeners=function(e){return u(this,e,!0)},o.prototype.rawListeners=function(e){return u(this,e,!1)},o.listenerCount=function(e,t){return"function"===typeof e.listenerCount?e.listenerCount(t):p.call(e,t)},o.prototype.listenerCount=p,o.prototype.eventNames=function(){return this._eventsCount>0?t(this._events):[]}},87167:e=>{e.exports=function(e){if(!e)throw Error("hashlru must have a max value, of type number, greater than 0");var t=0,r=Object.create(null),n=Object.create(null);function s(s,o){r[s]=o,++t>=e&&(t=0,n=r,r=Object.create(null))}return{has:function(e){return void 0!==r[e]||void 0!==n[e]},remove:function(e){void 0!==r[e]&&(r[e]=void 0),void 0!==n[e]&&(n[e]=void 0)},get:function(e){var t=r[e];return void 0!==t?t:void 0!==(t=n[e])?(s(e,t),t):void 0},set:function(e,t){void 0!==r[e]?r[e]=t:s(e,t)},clear:function(){r=Object.create(null),n=Object.create(null)}}}},4813:(e,t,r)=>{"use strict";var n={};(0,r(11824).assign)(n,r(60961),r(11829),r(52168)),e.exports=n},41257:(e,t,r)=>{"use strict";const n=r(46861),s="object"===typeof window&&"object"===typeof document&&9===document.nodeType,o=n(),i=s&&!o,a=o&&!s,c=o&&s,l="undefined"!==typeof globalThis.process&&"undefined"!==typeof globalThis.process.release&&"node"===globalThis.process.release.name&&!o,d="function"===typeof importScripts&&"undefined"!==typeof self&&"undefined"!==typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope,h="undefined"!==typeof globalThis.process&&"undefined"!==typeof globalThis.process.env&&"test"===globalThis.process.env.NODE_ENV,u="undefined"!==typeof navigator&&"ReactNative"===navigator.product;e.exports={isTest:h,isElectron:o,isElectronMain:a,isElectronRenderer:c,isNode:l,isBrowser:i,isWebWorker:d,isEnvWithDom:s,isReactNative:u}},68170:(e,t,r)=>{"use strict";const{fetch:n,Request:s,Headers:o}=r(42453),{TimeoutError:i,HTTPError:a}=r(90140),c=r(47250).bind({ignoreUndefined:!0}),{URL:l,URLSearchParams:d}=r(41094),h=r(98691),u={throwHttpErrors:!0,credentials:"same-origin"};class p{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.opts=c(u,e)}async fetch(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const r=c(this.opts,t),u=new o(r.headers);if("string"!==typeof e&&!(e instanceof l||e instanceof s))throw new TypeError("`resource` must be a string, URL, or Request");const p=new l(e.toString(),r.base),{searchParams:y,transformSearchParams:w,json:m}=r;y&&(p.search="function"===typeof w?w(new d(r.searchParams)):new d(r.searchParams)),m&&(r.body=JSON.stringify(r.json),u.set("content-type","application/json"));const v=new AbortController,b=h([v.signal,r.signal]),_=await((e,t,r)=>{if(void 0===t)return e;const n=Date.now(),s=()=>Date.now()-n>=t;return new Promise(((n,o)=>{const a=setTimeout((()=>{s()&&(o(new i),r.abort())}),t),c=e=>t=>{clearTimeout(a),s()?o(new i):e(t)};e.then(c(n),c(o))}))})(n(p.toString(),{...r,signal:b,timeout:void 0,headers:u}),r.timeout,v);if(!_.ok&&r.throwHttpErrors)throw r.handleError&&await r.handleError(_),new a(_);return _.iterator=function(){return g(_.body)},_.ndjson=async function*(){for await(const e of f(_.iterator()))t.transform?yield t.transform(e):yield e},_}post(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.fetch(e,{...t,method:"POST"})}get(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.fetch(e,{...t,method:"GET"})}put(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.fetch(e,{...t,method:"PUT"})}delete(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.fetch(e,{...t,method:"DELETE"})}options(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.fetch(e,{...t,method:"OPTIONS"})}}const f=async function*(e){const t=new TextDecoder;let r="";for await(const n of e){r+=t.decode(n,{stream:!0});const e=r.split(/\r?\n/);for(let t=0;t<e.length-1;t++){const r=e[t].trim();r.length>0&&(yield JSON.parse(r))}r=e[e.length-1]}r+=t.decode(),r=r.trim(),0!==r.length&&(yield JSON.parse(r))},g=e=>{if(m(e)){const t=e[Symbol.asyncIterator]();return{[Symbol.asyncIterator]:()=>({next:t.next.bind(t),return:r=>(e.destroy(),"function"===typeof t.return?t.return():Promise.resolve({done:!0,value:r}))})}}if(w(e)){const t=e.getReader();return async function*(){try{for(;;){const{done:e,value:r}=await t.read();if(e)return;r&&(yield r)}}finally{t.releaseLock()}}()}if(y(e))return e;throw new TypeError("Body can't be converted to AsyncIterable")},y=e=>"object"===typeof e&&null!==e&&"function"===typeof e[Symbol.asyncIterator],w=e=>e&&"function"===typeof e.getReader,m=e=>Object.prototype.hasOwnProperty.call(e,"readable")&&Object.prototype.hasOwnProperty.call(e,"writable");p.HTTPError=a,p.TimeoutError=i,p.streamToAsyncIterator=g,p.post=(e,t)=>new p(t).post(e,t),p.get=(e,t)=>new p(t).get(e,t),p.put=(e,t)=>new p(t).put(e,t),p.delete=(e,t)=>new p(t).delete(e,t),p.options=(e,t)=>new p(t).options(e,t),e.exports=p},47937:e=>{"use strict";var t=/^(?:[a-z0-9](?:[a-z0-9\-]{0,61}[a-z0-9])?\.){0,126}(?:[a-z0-9](?:[a-z0-9\-]{0,61}[a-z0-9]))\.?$/i;e.exports=function(e,r){if(null==r&&(r=!1),e.length<2)return!1;if(e.length>255)return!1;var n=e[e.length-1];if(r){if("."!==n)return!1}else if("."===n)return!1;return t.test(e)}},21958:e=>{"use strict";e.exports=async e=>{const t=[];for await(const r of e)t.push(r);return t}},20838:e=>{"use strict";e.exports=async e=>{for await(const t of e);}},45454:e=>{"use strict";e.exports=async e=>{for await(const t of e)return t}},16586:e=>{"use strict";e.exports=async e=>{let t;for await(const r of e)t=r;return t}},7213:(e,t,r)=>{"use strict";t.encode=r(57158),t.decode=r(16811),t.varintEncode=r(16225),t.varintDecode=r(67369),t.int32BEEncode=r(9538),t.int32BEDecode=r(25012)},88411:(e,t,r)=>{"use strict";const n=r(19635);e.exports=async function*(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;for await(const r of n(e,t)){const e=r.map((e=>e().then((e=>({ok:!0,value:e})),(e=>({ok:!1,err:e})))));for(let t=0;t<e.length;t++){const r=await e[t];if(!r.ok)throw r.err;yield r.value}}}},1833:(e,t,r)=>{"use strict";const n=r(61135),s=r(36571).EventEmitter;e.exports=async function*(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=t.concurrency||1/0;r<1&&(r=1/0);const o=null!=t.ordered&&t.ordered,i=new s,a=[];let c,l=n(),d=n(),h=!1,u=!1;function p(){return o?Boolean(a[0]&&a[0].done):Boolean(a.find((e=>e.done)))}function*f(){for(;a.length&&a[0].done;){const e=a[0];if(a.shift(),!e.ok)throw u=!0,l.resolve(),e.err;yield e.value,l.resolve()}}function*g(){for(;p();)for(let e=0;e<a.length;e++)if(a[e].done){const t=a[e];if(a.splice(e,1),e--,!t.ok)throw u=!0,l.resolve(),t.err;yield t.value,l.resolve()}}for(i.on("task-complete",(()=>{d.resolve()})),Promise.resolve().then((async()=>{try{for await(const t of e){if(a.length===r&&(l=n(),await l.promise),u)break;const e={done:!1};a.push(e),t().then((t=>{e.done=!0,e.ok=!0,e.value=t,i.emit("task-complete")}),(t=>{e.done=!0,e.err=t,i.emit("task-complete")}))}h=!0,i.emit("task-complete")}catch(t){c=t,i.emit("task-complete")}}));;){if(p()||(d=n(),await d.promise),c)throw c;if(o?yield*f():yield*g(),h&&0===a.length)break}}},62469:e=>{"use strict";e.exports=function(e){const[t,r]=e[Symbol.asyncIterator]?[e[Symbol.asyncIterator](),Symbol.asyncIterator]:[e[Symbol.iterator](),Symbol.iterator],n=[];return{peek:()=>t.next(),push:e=>{n.push(e)},next:()=>n.length?{done:!1,value:n.shift()}:t.next(),[r](){return this}}}},31730:(e,t,r)=>{const n=r(39047);e.exports=e=>{let t;"function"===typeof(e=e||{})?(t=e,e={}):t=e.onEnd;let r,s,o,i=new n;const a=e=>s?s(e):(i.push(e),r),c=e=>o?r:a({done:!1,value:e}),l=e=>o?r:(o=!0,e?(e=>(i=new n,s?s({error:e}):(i.push({error:e}),r)))(e):a({done:!0}));if(r={[Symbol.asyncIterator](){return this},next:()=>{if(!i.isEmpty()){if(e.writev){let e;const t=[];for(;!i.isEmpty();){if(e=i.shift(),e.error)throw e.error;t.push(e.value)}return{done:e.done,value:t}}const t=i.shift();if(t.error)throw t.error;return t}return o?{done:!0}:new Promise(((t,n)=>{s=o=>(s=null,o.error?n(o.error):e.writev&&!o.done?t({done:o.done,value:[o.value]}):t(o),r)}))},return:()=>(i=new n,l(),{done:!0}),throw:e=>(l(e),{done:!0}),push:c,end:l},!t)return r;const d=r;return r={[Symbol.asyncIterator](){return this},next:()=>d.next(),throw:e=>(d.throw(e),t&&(t(e),t=null),{done:!0}),return:()=>(d.return(),t&&(t(),t=null),{done:!0}),push:c,end:e=>(d.end(e),t&&(t(e),t=null),r)},r}},91703:(e,t,r)=>{"use strict";const n=r(21958);e.exports=async function*(e,t){const r=await n(e);yield*r.sort(t)}},53659:(e,t,r)=>{r(89869),t.pack=r(56113)},56113:(e,t,r)=>{const{Buffer:n}=r(42618),s=r(74439),{S_IFMT:o,S_IFBLK:i,S_IFCHR:a,S_IFDIR:c,S_IFIFO:l,S_IFLNK:d}=r(24416),h=r(46905),u=r(95336),p=parseInt("755",8),f=parseInt("644",8),g=n.alloc(1024);function y(e){switch(e&o){case i:return"block-device";case a:return"character-device";case c:return"directory";case l:return"fifo";case d:return"symlink"}return"file"}function w(e){if(e&=511)return new s(g.slice(0,512-e))}function m(e){if(!e.pax){const t=u.encode(e);if(t)return t}return function(e){const t=u.encodePax({name:e.name,linkname:e.linkname,pax:e.pax}),r={name:"PaxHeader",mode:e.mode,uid:e.uid,gid:e.gid,size:t.length,mtime:e.mtime,type:"pax-header",linkname:e.linkname&&"PaxHeader",uname:e.uname,gname:e.gname,devmajor:e.devmajor,devminor:e.devminor};return new s([u.encode(r),t,w(t.length),u.encode({...r,size:e.size,type:e.type})])}(e)}e.exports=()=>async function*(e){for await(let{header:t,body:r}of e){if(t.size&&"symlink"!==t.type||(t.size=0),t.type||(t.type=y(t.mode)),t.mode||(t.mode="directory"===t.type?p:f),t.uid||(t.uid=0),t.gid||(t.gid=0),t.mtime||(t.mtime=new Date),"string"===typeof r&&(r=n.from(r)),n.isBuffer(r)||s.isBufferList(r)){t.size=r.length,yield new s([m(t),r,w(t.size)]);continue}if("symlink"===t.type&&!t.linkname){t.linkname=(await h(r)).toString(),yield m(t);continue}if(yield m(t),"file"!==t.type&&"contiguous-file"!==t.type)continue;let e=0;for await(const t of r)e+=t.length,yield s.isBufferList(t)?t:new s(t);if(e!==t.size)throw new Error("size mismatch");const o=w(t.size);o&&(yield o)}yield new s(g)}},42407:(e,t,r)=>{"use strict";const{concat:n}=r(52769);e.exports=async function(e){let t=new Uint8Array(0);for await(const r of e)t=n([t,r],t.length+r.length);return t}},88898:e=>{e.exports=function(e,t,r){var n=null,s=null,o=function(){n&&(clearTimeout(n),s=null,n=null)},i=function(){if(!t)return e.apply(this,arguments);var i=this,a=arguments,c=r&&!n;return o(),s=function(){e.apply(i,a)},n=setTimeout((function(){if(n=null,!c){var e=s;return s=null,e()}}),t),c?s():void 0};return i.cancel=o,i.flush=function(){var e=s;o(),e&&e()},i}},2548:e=>{e.exports=function(e,t,r){if(!e)return r;var n,s;Array.isArray(t)&&(n=t.slice(0));"string"==typeof t&&(n=t.split("."));"symbol"==typeof t&&(n=[t]);if(!Array.isArray(n))throw new Error("props arg must be an array, a string or a symbol");for(;n.length;){if(s=n.shift(),!e)return r;if(void 0===(e=e[s]))return r}return e}},69201:e=>{function t(e){if("__proto__"===e||"constructor"===e||"prototype"===e)throw new Error("setting of prototype values not supported")}e.exports=function(e,r,n){var s,o,i;Array.isArray(r)&&(s=r.slice(0));"string"==typeof r&&(s=r.split("."));"symbol"==typeof r&&(s=[r]);if(!Array.isArray(s))throw new Error("props arg must be an array, a string or a symbol");if(!(o=s.pop()))return!1;t(o);for(;i=s.shift();)if(t(i),"undefined"==typeof e[i]&&(e[i]={}),!(e=e[i])||"object"!=typeof e)return!1;return e[o]=n,!0}},77420:(e,t,r)=>{e.exports=r(67469)(r(39850))},95067:(e,t,r)=>{"use strict";const n=r(91401),{Multiaddr:s}=r(10006),o=r(44021),{EventEmitter:i}=r(36571),a=r(60720),c=Object.assign(a("libp2p:bootstrap"),{error:a("libp2p:bootstrap:error")});(e.exports=class extends i{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{list:[]};if(!e.list||!e.list.length)throw new Error("Bootstrap requires a list of peer addresses");super(),this._list=e.list,this._interval=e.interval||1e4,this._timer=null}start(){this._timer||(this._timer=setInterval((()=>this._discoverBootstrapPeers()),this._interval),c("Starting bootstrap node discovery"),this._discoverBootstrapPeers())}_discoverBootstrapPeers(){this._timer&&this._list.forEach((e=>{if(!o.P2P.matches(e))return c.error("Invalid multiaddr");const t=new s(e),r=t.getPeerId();if(!r)return void c.error("Invalid bootstrap multiaddr without peer id");const i=n.createFromB58String(r);try{this.emit("peer",{id:i,multiaddrs:[t]})}catch(a){c.error("Invalid bootstrap peer id",a)}}))}stop(){this._timer&&clearInterval(this._timer),this._timer=null}}).tag="bootstrap"},8711:(e,t,r)=>{"use strict";const n=r(60720),s=r(91401),o=r(20838),{default:i}=r(60185),a=r(61135),c=n("libp2p-delegated-content-routing");c.error=n("libp2p-delegated-content-routing:error");e.exports=class{constructor(e,t){if(null==e)throw new Error("missing self peerId");if(null==t)throw new Error("missing ipfs http client");this._client=t,this.peerId=e;const r={concurrency:4};this._httpQueue=new i(r),this._httpQueueRefs=new i(Object.assign({},r,{concurrency:2}));const{protocol:n,host:s,port:o}=t.getEndpointConfig();c(`enabled DelegatedContentRouting via ${n}://${s}:${o}`)}async*findProviders(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};c(`findProviders starts: ${e}`),t.timeout=t.timeout||3e4;let r=0;const n=a(),o=a();this._httpQueue.add((()=>(n.resolve(),o.promise)));try{await n.promise;for await(const{id:n,addrs:o}of this._client.dht.findProvs(e,{numProviders:t.numProviders,timeout:t.timeout}))yield{id:s.parse(n),multiaddrs:o},r++}catch(i){throw c.error("findProviders errored:",i),i}finally{o.resolve(),c(`findProviders finished: ${e} found ${r} providers`)}}async provide(e){c(`provide starts: ${e}`),await this._httpQueueRefs.add((async()=>{await this._client.block.stat(e),await o(this._client.dht.provide(e))})),c(`provide finished: ${e}`)}}},55585:(e,t,r)=>{"use strict";const n=r(91401),{base58btc:s}=r(43019),{default:o}=r(60185),i=r(61135),a=r(60720),c=a("libp2p-delegated-peer-routing");c.error=a("libp2p-delegated-peer-routing:error");e.exports=class{constructor(e){if(null==e)throw new Error("missing ipfs http client");this._client=e,this._httpQueue=new o({concurrency:4});const{protocol:t,host:r,port:n}=e.getEndpointConfig();c(`enabled DelegatedPeerRouting via ${t}://${r}:${n}`)}async findPeer(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=e;n.isPeerId(r)&&(r=e.toB58String()),c("findPeer starts: "+e),t.timeout=t.timeout||3e4;try{return await this._httpQueue.add((async()=>{const{addrs:n}=await this._client.dht.findPeer(r,{timeout:t.timeout});return{id:e,multiaddrs:n}}))}catch(s){if(s.message.includes("not found"))return;throw s}finally{c("findPeer finished: "+e)}}async*getClosestPeers(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const r=s.encode(e).substring(1);c("getClosestPeers starts:",r),t.timeout=t.timeout||3e4;const o=i(),a=i();this._httpQueue.add((()=>(o.resolve(),a.promise)));try{await o.promise;for await(const e of this._client.dht.query(r,{timeout:t.timeout}))if(1===e.type)for(const t of e.responses)yield{id:n.parse(t.id),multiaddrs:t.addrs};else c("getClosestPeers unhandled response",e)}catch(l){throw c.error("getClosestPeers errored:",l),l}finally{a.resolve(),c("getClosestPeers finished:",r)}}}},97153:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),s=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&n(t,e,r);return s(t,e),t},i=this&&this.__awaiter||function(e,t,r,n){return new(r||(r=Promise))((function(s,o){function i(e){try{c(n.next(e))}catch(t){o(t)}}function a(e){try{c(n.throw(e))}catch(t){o(t)}}function c(e){var t;e.done?s(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(i,a)}c((n=n.apply(e,t||[])).next())}))};const a=o(r(20008)),c=r(57904),l=r(19971),d=o(r(76371)),h=r(29519),u=r(22687),p=r(38071),f=r(97389),g=r(99375),y=r(53112),w=r(91401),m=r(50650),v=r(76371);class b extends a.default{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};var r;const n=[d.GossipsubIDv11,d.GossipsubIDv10],s=Object.assign(Object.assign({gossipIncoming:!0,fallbackToFloodsub:!0,floodPublish:!0,doPX:!1,directPeers:[],D:d.GossipsubD,Dlo:d.GossipsubDlo,Dhi:d.GossipsubDhi,Dscore:d.GossipsubDscore,Dout:d.GossipsubDout,Dlazy:d.GossipsubDlazy,heartbeatInterval:d.GossipsubHeartbeatInterval,fanoutTTL:d.GossipsubFanoutTTL,mcacheLength:d.GossipsubHistoryLength,mcacheGossip:d.GossipsubHistoryGossip,seenTTL:d.GossipsubSeenTTL},t),{scoreParams:f.createPeerScoreParams(t.scoreParams),scoreThresholds:f.createPeerScoreThresholds(t.scoreThresholds)});s.fallbackToFloodsub&&n.push(d.FloodsubID),super(Object.assign({debugName:"libp2p:gossipsub",multicodecs:n,libp2p:e},s)),this._options=s,this.direct=new Set(s.directPeers.map((e=>e.id.toB58String()))),this.acceptFromWhitelist=new Map,s.directPeers.forEach((t=>{e.peerStore.addressBook.add(t.id,t.addrs)})),this.seenCache=new y.SimpleTimeCache({validityMs:s.seenTTL}),this.mesh=new Map,this.fanout=new Map,this.lastpub=new Map,this.gossip=new Map,this.control=new Map,this.peerhave=new Map,this.iasked=new Map,this.backoff=new Map,this.outbound=new Map,this.messageCache=t.messageCache||new c.MessageCache(s.mcacheGossip,s.mcacheLength),this.getFastMsgIdStr=null!==(r=t.fastMsgIdFn)&&void 0!==r?r:void 0,this.fastMsgIdCache=t.fastMsgIdFn?new y.SimpleTimeCache({validityMs:s.seenTTL}):void 0,this.heartbeat=new h.Heartbeat(this),this.heartbeatTicks=0,this.gossipTracer=new g.IWantTracer,this._libp2p=e,this.score=new f.PeerScore(this._options.scoreParams,e.connectionManager)}_decodeRpc(e){return l.RPC.decode(e)}_encodeRpc(e){return l.RPC.encode(e).finish()}_addPeer(e,t){const r=super._addPeer(e,t);this.score.addPeer(e.toB58String());let n=!1;for(const s of this._libp2p.connectionManager.getAll(e))if("outbound"===s.stat.direction&&Array.from(s.registry.values()).some((e=>t===e.protocol))){n=!0;break}return this.outbound.set(r.id.toB58String(),n),r}_removePeer(e){const t=super._removePeer(e),r=e.toB58String();for(const n of this.mesh.values())n.delete(r);for(const n of this.fanout.values())n.delete(r);return this.gossip.delete(r),this.control.delete(r),this.outbound.delete(r),this.score.removePeer(r),this.acceptFromWhitelist.delete(r),t}_processRpc(e,t,r){const n=Object.create(null,{_processRpc:{get:()=>super._processRpc}});return i(this,void 0,void 0,(function*(){return!!(yield n._processRpc.call(this,e,t,r))&&(r.control&&(yield this._processRpcControlMessage(e,r.control)),!0)}))}_processRpcControlMessage(e,t){return i(this,void 0,void 0,(function*(){if(!t)return;const r=t.ihave?this._handleIHave(e,t.ihave):[],n=t.iwant?this._handleIWant(e,t.iwant):[],s=t.graft?yield this._handleGraft(e,t.graft):[];if(t.prune&&this._handlePrune(e,t.prune),!r.length&&!n.length&&!s.length)return;const o=p.createGossipRpc(n,{iwant:r,prune:s});this._sendRpc(e,o)}))}_processRpcMessage(e){const t=Object.create(null,{_processRpcMessage:{get:()=>super._processRpcMessage}});return i(this,void 0,void 0,(function*(){let r;if(this.getFastMsgIdStr&&this.fastMsgIdCache){const t=yield this.getFastMsgIdStr(e);if(r=this.fastMsgIdCache.get(t),void 0!==r)return void this.score.duplicateMessage(e,r);r=p.messageIdToString(yield this.getMsgId(e)),this.fastMsgIdCache.put(t,r)}else if(r=p.messageIdToString(yield this.getMsgId(e)),this.seenCache.has(r))return void this.score.duplicateMessage(e,r);this.seenCache.put(r),yield this.score.validateMessage(r),yield t._processRpcMessage.call(this,e)}))}_acceptFrom(e){if(this.direct.has(e))return!0;const t=Date.now(),r=this.acceptFromWhitelist.get(e);if(r&&r.messagesAccepted<v.ACCEPT_FROM_WHITELIST_MAX_MESSAGES&&r.acceptUntil>=t)return r.messagesAccepted+=1,!0;const n=this.score.score(e);return n>=v.ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE?this.acceptFromWhitelist.set(e,{messagesAccepted:0,acceptUntil:t+v.ACCEPT_FROM_WHITELIST_DURATION_MS}):this.acceptFromWhitelist.delete(e),n>=this._options.scoreThresholds.graylistThreshold}validate(e){const t=Object.create(null,{validate:{get:()=>super.validate}});return i(this,void 0,void 0,(function*(){try{yield t.validate.call(this,e)}catch(r){const t=yield this.getCanonicalMsgIdStr(e);throw this.score.rejectMessage(e,t,r.code),this.gossipTracer.rejectMessage(t,r.code),r}}))}_handleIHave(e,t){if(!t.length)return[];const r=this.score.score(e);if(r<this._options.scoreThresholds.gossipThreshold)return this.log("IHAVE: ignoring peer %s with score below threshold [ score = %d ]",e,r),[];const n=(this.peerhave.get(e)||0)+1;if(this.peerhave.set(e,n),n>d.GossipsubMaxIHaveMessages)return this.log("IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring",e,n),[];const s=this.iasked.get(e)||0;if(s>=d.GossipsubMaxIHaveLength)return this.log("IHAVE: peer %s has already advertised too many messages (%d); ignoring",e,s),[];const o=new Map;if(t.forEach((e=>{let{topicID:t,messageIDs:r}=e;t&&r&&this.mesh.has(t)&&r.forEach((e=>{const t=p.messageIdToString(e);this.seenCache.has(t)||o.set(t,e)}))})),!o.size)return[];let i=o.size;i+s>d.GossipsubMaxIHaveLength&&(i=d.GossipsubMaxIHaveLength-s),this.log("IHAVE: Asking for %d out of %d messages from %s",i,o.size,e);let a=Array.from(o.values());return p.shuffle(a),a=a.slice(0,i),this.iasked.set(e,s+i),this.gossipTracer.addPromise(e,a),[{messageIDs:a}]}_handleIWant(e,t){if(!t.length)return[];const r=this.score.score(e);if(r<this._options.scoreThresholds.gossipThreshold)return this.log("IWANT: ignoring peer %s with score below threshold [score = %d]",e,r),[];const n=new Map;return t.forEach((t=>{let{messageIDs:r}=t;r&&r.forEach((t=>{const r=p.messageIdToString(t),[s,o]=this.messageCache.getForPeer(r,e);s&&(o>d.GossipsubGossipRetransmission?this.log("IWANT: Peer %s has asked for message %s too many times: ignoring request",e,t):n.set(r,s))}))})),n.size?(this.log("IWANT: Sending %d messages to %s",n.size,e),Array.from(n.values()).map(a.utils.normalizeOutRpcMessage)):[]}_handleGraft(e,t){return i(this,void 0,void 0,(function*(){const r=[],n=this.score.score(e),s=this._now();let o=this._options.doPX;return t.forEach((t=>{let{topicID:i}=t;var a;if(!i)return;const c=this.mesh.get(i);if(!c)return void(o=!1);if(c.has(e))return;if(this.direct.has(e))return this.log("GRAFT: ignoring request from direct peer %s",e),r.push(i),void(o=!1);const l=null===(a=this.backoff.get(i))||void 0===a?void 0:a.get(e);if("number"===typeof l&&s<l){this.log("GRAFT: ignoring backed off peer %s",e),this.score.addPenalty(e,1),o=!1;const t=l+d.GossipsubGraftFloodThreshold-d.GossipsubPruneBackoff;return s<t&&this.score.addPenalty(e,1),this._addBackoff(e,i),void r.push(i)}return n<0?(this.log("GRAFT: ignoring peer %s with negative score: score=%d, topic=%s",e,n,i),r.push(i),o=!1,void this._addBackoff(e,i)):c.size>=this._options.Dhi&&!this.outbound.get(e)?(r.push(i),void this._addBackoff(e,i)):(this.log("GRAFT: Add mesh link from %s in %s",e,i),this.score.graft(e,i),void c.add(e))})),r.length?Promise.all(r.map((t=>this._makePrune(e,t,o)))):[]}))}_handlePrune(e,t){const r=this.score.score(e);t.forEach((t=>{let{topicID:n,backoff:s,peers:o}=t;if(!n)return;const i=this.mesh.get(n);if(i&&(this.log("PRUNE: Remove mesh link to %s in %s",e,n),this.score.prune(e,n),i.delete(e),"number"===typeof s&&s>0?this._doAddBackoff(e,n,1e3*s):this._addBackoff(e,n),o&&o.length)){if(r<this._options.scoreThresholds.acceptPXThreshold)return void this.log("PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]",e,r,n);this._pxConnect(o)}}))}_addBackoff(e,t){this._doAddBackoff(e,t,d.GossipsubPruneBackoff)}_doAddBackoff(e,t,r){let n=this.backoff.get(t);n||(n=new Map,this.backoff.set(t,n));const s=this._now()+r;(n.get(e)||0)<s&&n.set(e,s)}_applyIwantPenalties(){this.gossipTracer.getBrokenPromises().forEach(((e,t)=>{this.log("peer %s didn't follow up in %d IWANT requests; adding penalty",t,e),this.score.addPenalty(t,e)}))}_clearBackoff(){if(this.heartbeatTicks%d.GossipsubPruneBackoffTicks!==0)return;const e=this._now();this.backoff.forEach(((t,r)=>{t.forEach(((r,n)=>{r<e&&t.delete(n)})),0===t.size&&this.backoff.delete(r)}))}_directConnect(){if(this.heartbeatTicks%d.GossipsubDirectConnectTicks!==0)return;const e=[];this.direct.forEach((t=>{const r=this.peers.get(t);r&&r.isWritable||e.push(t)})),e.length&&e.forEach((e=>{this._connect(e)}))}_pxConnect(e){return i(this,void 0,void 0,(function*(){e.length>d.GossipsubPrunePeers&&(p.shuffle(e),e=e.slice(0,d.GossipsubPrunePeers));const t=[];yield Promise.all(e.map((e=>i(this,void 0,void 0,(function*(){if(!e.peerID)return;const r=w.createFromBytes(e.peerID).toB58String();if(!this.peers.has(r))if(e.signedPeerRecord)try{const n=yield m.openAndCertify(e.signedPeerRecord,"libp2p-peer-record"),s=n.peerId.toB58String();if(r!==s)return void this.log("bogus peer record obtained through px: peer ID %s doesn't match expected peer %s",s,r);if(!this._libp2p.peerStore.addressBook.consumePeerRecord(n))return void this.log("bogus peer record obtained through px: could not add peer record to address book");t.push(r)}catch(n){this.log("bogus peer record obtained through px: invalid signature or not a peer record")}else t.push(r)}))))),t.length&&t.forEach((e=>this._connect(e)))}))}start(){const e=Object.create(null,{start:{get:()=>super.start}});return i(this,void 0,void 0,(function*(){yield e.start.call(this),this.heartbeat.start(),this.score.start(),this._directPeerInitial=setTimeout((()=>{this.direct.forEach((e=>{this._connect(e)}))}),d.GossipsubDirectConnectInitialDelay)}))}stop(){const e=Object.create(null,{stop:{get:()=>super.stop}});return i(this,void 0,void 0,(function*(){yield e.stop.call(this),this.heartbeat.stop(),this.score.stop(),this.mesh=new Map,this.fanout=new Map,this.lastpub=new Map,this.gossip=new Map,this.control=new Map,this.peerhave=new Map,this.iasked=new Map,this.backoff=new Map,this.outbound=new Map,this.gossipTracer.clear(),this.seenCache.clear(),this.fastMsgIdCache&&this.fastMsgIdCache.clear(),clearTimeout(this._directPeerInitial)}))}_connect(e){this.log("Initiating connection with %s",e),this._libp2p.dialProtocol(w.createFromB58String(e),this.multicodecs)}subscribe(e){super.subscribe(e),this.join(e)}unsubscribe(e){super.unsubscribe(e),this.leave(e)}join(e){if(!this.started)throw new Error("Gossipsub has not started");this.log("JOIN %s",e);const t=this.fanout.get(e);if(t)t.forEach((e=>{this.score.score(e)<0&&t.delete(e)})),t.size<this._options.D&&u.getGossipPeers(this,e,this._options.D-t.size,(e=>!t.has(e)&&!this.direct.has(e)&&this.score.score(e)>=0)).forEach((e=>t.add(e))),this.mesh.set(e,t),this.fanout.delete(e),this.lastpub.delete(e);else{const t=u.getGossipPeers(this,e,this._options.D,(e=>!this.direct.has(e)&&this.score.score(e)>=0));this.mesh.set(e,t)}this.mesh.get(e).forEach((t=>{this.log("JOIN: Add mesh link to %s in %s",t,e),this._sendGraft(t,e)}))}leave(e){if(!this.started)throw new Error("Gossipsub has not started");this.log("LEAVE %s",e);const t=this.mesh.get(e);t&&(t.forEach((t=>{this.log("LEAVE: Remove mesh link to %s in %s",t,e),this._sendPrune(t,e)})),this.mesh.delete(e))}getCanonicalMsgIdStr(e){var t,r;return i(this,void 0,void 0,(function*(){return this.fastMsgIdCache&&this.getFastMsgIdStr&&null!==(r=null!==(t=this.getCachedMsgIdStr(e))&&void 0!==t?t:this.fastMsgIdCache.get(this.getFastMsgIdStr(e)))&&void 0!==r?r:p.messageIdToString(yield this.getMsgId(e))}))}getCachedMsgIdStr(e){}_publish(e){return i(this,void 0,void 0,(function*(){const t=yield this.getCanonicalMsgIdStr(e);e.receivedFrom!==this.peerId.toB58String()&&(this.score.deliverMessage(e,t),this.gossipTracer.deliverMessage(t)),this.seenCache.put(t),this.messageCache.put(e,t);const r=new Set;e.topicIDs.forEach((t=>{const n=this.topics.get(t);if(n)if(this._options.floodPublish&&e.from===this.peerId.toB58String())n.forEach((e=>{(this.direct.has(e)||this.score.score(e)>=this._options.scoreThresholds.publishThreshold)&&r.add(e)}));else{this.direct.forEach((e=>{r.add(e)})),n.forEach((e=>{const t=this.score.score(e),n=this.peers.get(e);n&&n.protocol===d.FloodsubID&&t>=this._options.scoreThresholds.publishThreshold&&r.add(e)}));let e=this.mesh.get(t);if(!e||!e.size){if(e=this.fanout.get(t),!e){const r=u.getGossipPeers(this,t,this._options.D,(e=>this.score.score(e)>=this._options.scoreThresholds.publishThreshold));r.size>0?(e=r,this.fanout.set(t,r)):e=new Set}this.lastpub.set(t,this._now())}e.forEach((e=>{r.add(e)}))}}));const n=p.createGossipRpc([a.utils.normalizeOutRpcMessage(e)]);r.forEach((t=>{t!==e.from&&this._sendRpc(t,n)}))}))}_sendGraft(e,t){const r=[{topicID:t}],n=p.createGossipRpc([],{graft:r});this._sendRpc(e,n)}_sendPrune(e,t){return i(this,void 0,void 0,(function*(){const r=[yield this._makePrune(e,t,this._options.doPX)],n=p.createGossipRpc([],{prune:r});this._sendRpc(e,n)}))}_sendRpc(e,t){const r=this.peers.get(e);if(!r||!r.isWritable)return;const n=this.control.get(e);n&&(this._piggybackControl(e,t,n),this.control.delete(e));const s=this.gossip.get(e);s&&(this._piggybackGossip(e,t,s),this.gossip.delete(e)),r.write(l.RPC.encode(t).finish())}_piggybackControl(e,t,r){const n=(r.graft||[]).filter((t=>{let{topicID:r}=t;return(r&&this.mesh.get(r)||new Set).has(e)})),s=(r.prune||[]).filter((t=>{let{topicID:r}=t;return!(r&&this.mesh.get(r)||new Set).has(e)}));(n.length||s.length)&&(t.control?(t.control.graft=t.control.graft&&t.control.graft.concat(n),t.control.prune=t.control.prune&&t.control.prune.concat(s)):t.control={ihave:[],iwant:[],graft:n,prune:s})}_piggybackGossip(e,t,r){t.control||(t.control={ihave:[],iwant:[],graft:[],prune:[]}),t.control.ihave=r}_sendGraftPrune(e,t,r){return i(this,void 0,void 0,(function*(){const n=this._options.doPX;for(const[s,o]of e){const e=o.map((e=>({topicID:e})));let i=[];const a=t.get(s);a&&(i=yield Promise.all(a.map((e=>this._makePrune(s,e,n&&!r.get(s))))),t.delete(s));const c=p.createGossipRpc([],{graft:e,prune:i});this._sendRpc(s,c)}for(const[e,s]of t){const t=yield Promise.all(s.map((t=>this._makePrune(e,t,n&&!r.get(e))))),o=p.createGossipRpc([],{prune:t});this._sendRpc(e,o)}}))}_emitGossip(e,t){const r=this.messageCache.getGossipIDs(e);if(!r.length)return;p.shuffle(r),r.length>d.GossipsubMaxIHaveLength&&this.log("too many messages for gossip; will truncate IHAVE list (%d messages)",r.length);const n=[],s=this.topics.get(e);if(!s)return;s.forEach((e=>{const r=this.peers.get(e);r&&!t.has(e)&&!this.direct.has(e)&&p.hasGossipProtocol(r.protocol)&&this.score.score(e)>=this._options.scoreThresholds.gossipThreshold&&n.push(e)}));let o=this._options.Dlazy;const i=d.GossipsubGossipFactor*n.length;i>o&&(o=i),o>n.length?o=n.length:p.shuffle(n),n.slice(0,o).forEach((t=>{let n=r;r.length>d.GossipsubMaxIHaveLength&&(n=p.shuffle(n.slice()).slice(0,d.GossipsubMaxIHaveLength)),this._pushGossip(t,{topicID:e,messageIDs:n})}))}_flush(){for(const[e,t]of this.gossip.entries()){this.gossip.delete(e);const r=p.createGossipRpc([],{ihave:t});this._sendRpc(e,r)}for(const[e,t]of this.control.entries()){this.control.delete(e);const r=p.createGossipRpc([],{graft:t.graft,prune:t.prune});this._sendRpc(e,r)}}_pushGossip(e,t){this.log("Add gossip to %s",e);const r=this.gossip.get(e)||[];this.gossip.set(e,r.concat(t))}_now(){return Date.now()}_makePrune(e,t,r){return i(this,void 0,void 0,(function*(){if(this.peers.get(e).protocol===d.GossipsubIDv10)return{topicID:t,peers:[]};const n=d.GossipsubPruneBackoff/1e3;if(!r)return{topicID:t,peers:[],backoff:n};const s=u.getGossipPeers(this,t,d.GossipsubPrunePeers,(t=>t!==e&&this.score.score(t)>=0)),o=yield Promise.all(Array.from(s).map((e=>i(this,void 0,void 0,(function*(){const t=w.createFromB58String(e);return{peerID:t.toBytes(),signedPeerRecord:yield this._libp2p.peerStore.addressBook.getRawEnvelope(t)}})))));return{topicID:t,peers:o,backoff:n}}))}}b.multicodec=d.GossipsubIDv11,e.exports=b},90983:(e,t,r)=>{"use strict";const n=r(37567),s=Symbol.for("@libp2p/js-interfaces/topology/multicodec-topology"),o=r(60720),i=Object.assign(o("libp2p:topology:multicodec-topology"),{error:o("libp2p:topology:multicodec-topology:error")});class a extends n{constructor(e){let{min:t,max:r,multicodecs:n,handlers:s}=e;if(super({min:t,max:r,handlers:s}),!n)throw new Error("one or more multicodec should be provided");if(!s)throw new Error("the handlers should be provided");if("function"!==typeof s.onConnect)throw new Error("the 'onConnect' handler must be provided");if("function"!==typeof s.onDisconnect)throw new Error("the 'onDisconnect' handler must be provided");this.multicodecs=Array.isArray(n)?n:[n],this._registrar=void 0,this._onProtocolChange=this._onProtocolChange.bind(this),this._onPeerConnect=this._onPeerConnect.bind(this)}get[Symbol.toStringTag](){return"Topology"}get[s](){return!0}static isMulticodecTopology(e){return Boolean(e&&e[s])}async setRegistrar(e){this._registrar=e,this._registrar.peerStore.on("change:protocols",this._onProtocolChange),this._registrar.connectionManager.on("peer:connect",this._onPeerConnect),await this._updatePeers(this._registrar.peerStore.getPeers())}async _updatePeers(e){for await(const{id:t,protocols:r}of e)if(this.multicodecs.filter((e=>r.includes(e))).length){this.peers.add(t.toB58String());const e=this._registrar.getConnection(t);e&&this._onConnect(t,e)}else this.peers.delete(t.toB58String())}async _onProtocolChange(e){let{peerId:t,protocols:r}=e;try{const e=this.peers.has(t.toB58String()),n=r.filter((e=>this.multicodecs.includes(e)));e&&0===n.length&&this._onDisconnect(t);for(const s of r)if(this.multicodecs.includes(s)){const e=await this._registrar.peerStore.get(t);return void await this._updatePeers([e])}}catch(n){i.error(n)}}async _onPeerConnect(e){try{const t=e.remotePeer,r=await this._registrar.peerStore.protoBook.get(t);if(!r)return;this.multicodecs.find((e=>r.includes(e)))&&(this.peers.add(t.toB58String()),this._onConnect(t,e))}catch(t){i.error(t)}}}e.exports=a},49616:(e,t,r)=>{"use strict";const{KadDHT:n}=r(58415),{DualKadDHT:s}=r(70022);e.exports={create:e=>new s(new n({...e,protocol:"/ipfs/kad/1.0.0",lan:!1}),new n({...e,protocol:"/ipfs/lan/kad/1.0.0",clientMode:!1,lan:!0}),e.libp2p)}},48402:(e,t,r)=>{"use strict";e.exports=r(64736)},64736:(e,t,r)=>{"use strict";const n=r(89962),s=r(31730),o=r(60720)("libp2p:mplex"),i=r(7155),a=r(14910),c=r(11999),{MessageTypes:l,MessageTypeNames:d}=r(88809),h=r(91126);class u{constructor(e){e="function"===typeof(e=e||{})?{onStream:e}:e,this._streamId=0,this._streams={initiators:new Map,receivers:new Map},this._options=e,this.sink=this._createSink(),this.source=this._createSource(),this.onStream=e.onStream,this.onStreamEnd=e.onStreamEnd}get streams(){const e=[];return this._streams.initiators.forEach((t=>{e.push(t)})),this._streams.receivers.forEach((t=>{e.push(t)})),e}newStream(e){const t=this._streamId++;e=null==e?t.toString():String(e);const r=this._streams.initiators;return this._newStream({id:t,name:e,type:"initiator",registry:r})}_newReceiverStream(e){let{id:t,name:r}=e;const n=this._streams.receivers;return this._newStream({id:t,name:r,type:"receiver",registry:n})}_newStream(e){let{id:t,name:r,type:n,registry:s}=e;if(s.has(t))throw new Error(`${n} stream ${t} already exists!`);o("new %s stream %s %s",n,t,r);const i=h({id:t,name:r,send:e=>(o.enabled&&o("%s stream %s %s send",n,t,r,{...e,type:d[e.type],data:e.data&&e.data.slice()}),this.source.push(e)),type:n,onEnd:()=>{o("%s stream %s %s ended",n,t,r),s.delete(t),this.onStreamEnd&&this.onStreamEnd(i)},maxMsgSize:this._options.maxMsgSize});return s.set(t,i),i}_createSink(){return async e=>{this._options.signal&&(e=i(e,this._options.signal));try{await n(e,a.decode,c(this._options.maxMsgSize),(async e=>{for await(const t of e)for(const e of t)this._handleIncoming(e)}))}catch(t){return o("error in sink",t),this.source.end(t)}this.source.end()}}_createSource(){const e=s({onEnd:e=>{const{initiators:t,receivers:r}=this._streams;for(const n of t.values())n.abort(e);for(const n of r.values())n.abort(e)},writev:!0});return Object.assign(a.encode(e),{push:e.push,end:e.end,return:e.return})}_handleIncoming(e){let{id:t,type:r,data:n}=e;if(o.enabled&&o("incoming message",{id:t,type:d[r],data:n.slice()}),r===l.NEW_STREAM&&this.onStream){const e=this._newReceiverStream({id:t,name:n.toString()});return this.onStream(e)}const s=(1&r?this._streams.initiators:this._streams.receivers).get(t);if(!s)return o("missing stream %s",t);switch(r){case l.MESSAGE_INITIATOR:case l.MESSAGE_RECEIVER:s.source.push(n);break;case l.CLOSE_INITIATOR:case l.CLOSE_RECEIVER:s.close();break;case l.RESET_INITIATOR:case l.RESET_RECEIVER:s.reset();break;default:o("unknown message type %s",r)}}}u.multicodec="/mplex/6.7.0",e.exports=u},16758:(e,t,r)=>{"use strict";e.exports={Record:r(91453),validator:r(36782),selection:r(55980)}},84856:(e,t,r)=>{"use strict";const n=r(60720),s=n("libp2p:webrtc-star");s.error=n("libp2p:webrtc-star:error");const{EventEmitter:o}=r(36571),i=r(15504),a=r(24177),{AbortError:c}=r(7155),l=r(33192),{supportsWebRTCDataChannels:d}=r(11747),{Multiaddr:h}=r(10006),u=r(44021),p=r(91401),{CODE_CIRCUIT:f}=r(85146),g=r(17931),y=r(92380),{cleanMultiaddr:w,cleanUrlSIO:m}=r(480);function v(){}e.exports=a(class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!e.upgrader)throw new Error("An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.");this._upgrader=e.upgrader,this.sioOptions={transports:["websocket"],"force new connection":!0},e.wrtc&&(this.wrtc=e.wrtc),this.sigReferences=new Map,this.discovery=new o,this.discovery.tag="webRTCStar",this.discovery._isStarted=!1,this.discovery.start=()=>{this.discovery._isStarted=!0},this.discovery.stop=()=>{this.discovery._isStarted=!1},this._peerDiscovered=this._peerDiscovered.bind(this)}async dial(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const r=await this._connect(e,t),n=y(r,{remoteAddr:e,signal:t.signal});s("new outbound connection %s",n.remoteAddr);const o=await this._upgrader.upgradeOutbound(n);return s("outbound connection %s upgraded",n.remoteAddr),o}_connect(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.signal&&t.signal.aborted)throw new c;const r={initiator:!0,trickle:!1,...t.spOptions||{}};this.wrtc&&(r.wrtc=this.wrtc);const n=e.toOptions(),o=(~~(1e9*Math.random())).toString(36)+Date.now();return new Promise(((a,d)=>{const h=this.sigReferences.get(m(e));if(!h||!h.listener)return d(i(new Error("unknown signal server to use"),"ERR_UNKNOWN_SIGNAL_SERVER"));const u=h.listener.io,p=Date.now();let f;s("dialing %s:%s",n.host,n.port);const g=new l(r),y=e=>{if(!f){const t=`connection error ${n.host}:${n.port}: ${e.message}`;s.error(t),_(e)}},w=()=>{s("connnection timeout %s:%s",n.host,n.port);const e=i(new Error(`connection timeout after ${Date.now()-p}ms`),"ERR_CONNECT_TIMEOUT");g.emit("error",e)},v=()=>{f=!0,s("connection opened %s:%s",n.host,n.port),_(null)},b=()=>{s.error("connection aborted %s:%s",n.host,n.port),g.destroy(),_(new c)},_=e=>{g.removeListener("timeout",w),g.removeListener("connect",v),t.signal&&t.signal.removeEventListener("abort",b),e?d(e):a(g)};g.on("error",y),g.once("timeout",w),g.once("connect",v),g.on("close",(()=>{g.removeListener("error",y)})),t.signal&&t.signal.addEventListener("abort",b),g.on("signal",(t=>{u.emit("ss-handshake",{intentId:o,srcMultiaddr:h.signallingAddr.toString(),dstMultiaddr:e.toString(),signal:t})})),u.on("ws-handshake",(e=>{e.intentId===o&&e.err&&(g.destroy(),d(i(e.err instanceof Error?e.err:new Error(e.err),"ERR_SIGNALLING_FAILED"))),e.intentId===o&&e.answer&&!g.destroyed&&g.signal(e.signal)}))}))}createListener(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1?arguments[1]:void 0;if(!d&&!this.wrtc)throw i(new Error("no WebRTC support"),"ERR_NO_WEBRTC_SUPPORT");return"function"===typeof e&&(t=e,e={}),t=t||v,g({handler:t,upgrader:this._upgrader},this,e)}filter(e){return(e=Array.isArray(e)?e:[e]).filter((e=>!e.protoCodes().includes(f)&&u.WebRTCStar.matches(e)))}_peerDiscovered(e){if(!this.discovery._isStarted)return;s("Peer Discovered:",e),e=w(e);const t=new h(e),r=p.createFromB58String(t.getPeerId());this.discovery.emit("peer",{id:r,multiaddrs:[t]})}},{className:"WebRTCStar",symbolName:"@libp2p/js-libp2p-webrtc-star/webrtcstar"})},62162:(e,t,r)=>{"use strict";const n=r(8317),s=r(24177),o=r(36381),{AbortError:i}=r(7155),a=r(61135),c=r(60720),l=c("libp2p:websockets");l.error=c("libp2p:websockets:error");const d=r(41257),h=r(53779),u=r(63221),p=r(17946);e.exports=s(class{constructor(e){let{upgrader:t,filter:r}=e;if(!t)throw new Error("An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.");this._upgrader=t,this._filter=r}async dial(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};l("dialing %s",e);const r=await this._connect(e,t),n=u(r,{remoteAddr:e,signal:t.signal});l("new outbound connection %s",n.remoteAddr);const s=await this._upgrader.upgradeOutbound(n);return l("outbound connection %s upgraded",n.remoteAddr),s}async _connect(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.signal&&t.signal.aborted)throw new i;const r=e.toOptions();l("dialing %s:%s",r.host,r.port);const s=a(),c=e=>{const t=`connection error: ${e.message}`;l.error(t),s.reject(e)},d=n(o(e),Object.assign({binary:!0},t));if(d.socket.on?d.socket.on("error",c):d.socket.onerror=c,!t.signal)return await Promise.race([d.connected(),s.promise]),l("connected %s",e),d;let h;const u=new Promise(((e,r)=>{if(h=()=>{r(new i),setTimeout((()=>{d.close()}))},t.signal.aborted)return h();t.signal.addEventListener("abort",h)}));try{await Promise.race([u,s.promise,d.connected()])}finally{t.signal.removeEventListener("abort",h)}return l("connected %s",e),d}createListener(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1?arguments[1]:void 0;return"function"===typeof e&&(t=e,e={}),h({handler:t,upgrader:this._upgrader},e)}filter(e){return e=Array.isArray(e)?e:[e],this._filter?this._filter(e):d.isBrowser||d.isWebWorker?p.dnsWss(e):p.all(e)}},{className:"WebSockets",symbolName:"@libp2p/js-libp2p-websockets/websockets"})},60403:(e,t,r)=>{"use strict";const n=r(60720),s=Object.assign(n("libp2p"),{error:n("libp2p:err")}),{EventEmitter:o}=r(36571),i=r(15504),a=r(91401),{Multiaddr:c}=r(10006),{MemoryDatastore:l}=r(51854),d=r(41216),h=r(34646),u=r(95096),{validate:p}=r(22586),{codes:f,messages:g}=r(90707),y=r(41404),w=r(27069),m=r(27202),v=r(66537),b=r(12271),_=r(44546),E=r(71464),k=r(67340),I=r(69725),S=r(61704),P=r(28623),D=r(80796),R=r(30324),C=r(74166),A=r(55763),T=r(6944),N=r(80850),{updateSelfPeerRecord:O}=r(23055);class B extends o{static async create(e){if(e.peerId)return new B(e);const t=await a.create();return e.peerId=t,new B(e)}constructor(e){if(super(),this._options=p(e),this.peerId=this._options.peerId,this.datastore=this._options.datastore,this._options.metrics.enabled){const e=new k({...this._options.metrics});this.metrics=e}if(this.connectionGater={denyDialPeer:async()=>Promise.resolve(!1),denyDialMultiaddr:async()=>Promise.resolve(!1),denyInboundConnection:async()=>Promise.resolve(!1),denyOutboundConnection:async()=>Promise.resolve(!1),denyInboundEncryptedConnection:async()=>Promise.resolve(!1),denyOutboundEncryptedConnection:async()=>Promise.resolve(!1),denyInboundUpgradedConnection:async()=>Promise.resolve(!1),denyOutboundUpgradedConnection:async()=>Promise.resolve(!1),filterMultiaddrForPeer:async()=>Promise.resolve(!0),...this._options.connectionGater},this.peerStore=new P({peerId:this.peerId,datastore:this.datastore&&this._options.peerStore.persistence?this.datastore:new l,addressFilter:this.connectionGater.filterMultiaddrForPeer}),this.addresses=this._options.addresses,this.addressManager=new y(this.peerId,this._options.addresses),this.addressManager.on("change:addresses",(()=>{O(this).catch((e=>{s.error("Error updating self peer record",e)}))})),this._modules=this._options.modules,this._config=this._options.config,this._transport=[],this._discovery=new Map,this.connectionManager=new w(this,{...this._options.connectionManager}),this._autodialler=new m(this,{enabled:this._config.peerDiscovery.autoDial,minConnections:this._options.connectionManager.minConnections,autoDialInterval:this._options.connectionManager.autoDialInterval}),this._options.keychain&&this._options.keychain.datastore){s("creating keychain");const e=E.generateOptions();this.keychain=new E(this._options.keychain.datastore,{...e,...this._options.keychain}),s("keychain constructed")}if(this.upgrader=new S({connectionGater:this.connectionGater,localPeer:this.peerId,metrics:this.metrics,onConnection:e=>this.connectionManager.onConnect(e),onConnectionEnd:e=>this.connectionManager.onDisconnect(e)}),this.transportManager=new I({libp2p:this,upgrader:this.upgrader,faultTolerance:this._options.transportManager.faultTolerance}),this.natManager=new N({peerId:this.peerId,addressManager:this.addressManager,transportManager:this.transportManager,...this._options.config.nat}),this.registrar=new R({peerStore:this.peerStore,connectionManager:this.connectionManager}),this.handle=this.handle.bind(this),this.registrar.handle=this.handle,!this._modules.connEncryption||!this._modules.connEncryption.length)throw i(new Error(g.CONN_ENCRYPTION_REQUIRED),f.CONN_ENCRYPTION_REQUIRED);if(this._modules.connEncryption.forEach((e=>{this.upgrader.cryptos.set(e.protocol,e)})),this.dialer=new _({transportManager:this.transportManager,connectionGater:this.connectionGater,peerStore:this.peerStore,metrics:this.metrics,...this._options.dialer}),this._modules.transport.forEach((e=>{const t=e.prototype[Symbol.toStringTag],r=this._config.transport[t];this.transportManager.add(t,e,r)})),this._config.relay.enabled&&(this.transportManager.add(v.prototype[Symbol.toStringTag],v),this.relay=new b(this)),this._modules.streamMuxer){this._modules.streamMuxer.forEach((e=>{this.upgrader.muxers.set(e.multicodec,e)})),this.identifyService=new C({libp2p:this})}if(this._modules.connProtector)this.upgrader.protector=this._modules.connProtector;else if(void 0!==globalThis.process&&globalThis.process.env&&globalThis.process.env.LIBP2P_FORCE_PNET)throw new Error("Private network is enforced, but no protector was provided");if(this._modules.dht){const e=this._modules.dht;this._dht=e.create({libp2p:this,...this._config.dht})}if(this._modules.pubsub){const e=this._modules.pubsub;this.pubsub=D(e,this,this._config.pubsub)}this.peerRouting=new d(this),this.contentRouting=new h(this),this._onDiscoveryPeer=this._onDiscoveryPeer.bind(this),this.fetchService=new A(this),this.pingService=new T(this)}emit(e){for(var t=arguments.length,r=new Array(t>1?t-1:0),n=1;n<t;n++)r[n-1]=arguments[n];return"error"!==e||this._events.error?super.emit(e,...r):(s.error(r),!1)}async start(){s("libp2p is starting"),this.identifyService&&await this.handle(Object.values(C.getProtocolStr(this)),this.identifyService.handleMessage),this.fetchService&&await this.handle(A.PROTOCOL,this.fetchService.handleMessage),this.pingService&&await this.handle(T.getProtocolStr(this),this.pingService.handleMessage);try{await this._onStarting(),await this._onDidStart(),s("libp2p has started")}catch(e){throw this.emit("error",e),s.error("An error occurred starting libp2p",e),await this.stop(),e}}async stop(){s("libp2p is stopping");try{this._isStarted=!1,this.identifyService&&await this.identifyService.stop(),this.relay&&this.relay.stop(),this.peerRouting.stop(),await this._autodialler.stop(),await(this._dht&&this._dht.stop());for(const e of this._discovery.values())e.removeListener("peer",this._onDiscoveryPeer);await Promise.all(Array.from(this._discovery.values(),(e=>e.stop()))),this._discovery=new Map,await this.connectionManager.stop(),await Promise.all([this.pubsub&&this.pubsub.stop(),this.metrics&&this.metrics.stop()]),await this.natManager.stop(),await this.transportManager.close(),await this.unhandle(A.PROTOCOL),await this.unhandle(T.getProtocolStr(this)),this.dialer.destroy()}catch(e){e&&(s.error(e),this.emit("error",e))}s("libp2p has stopped")}async loadKeychain(){if(this.keychain)try{await this.keychain.findKeyByName("self")}catch(e){await this.keychain.importPeer("self",this.peerId)}}isStarted(){return this._isStarted}get connections(){return this.connectionManager.connections}dial(e,t){return this._dial(e,t)}async dialProtocol(e,t,r){if(!t||!t.length)throw i(new Error("no protocols were provided to open a stream"),f.ERR_INVALID_PROTOCOLS_FOR_STREAM);return(await this._dial(e,r)).newStream(t)}async _dial(e,t){const{id:r,multiaddrs:n}=u(e);if(r.equals(this.peerId))throw i(new Error("Cannot dial self"),f.ERR_DIALED_SELF);let s=this.connectionManager.get(r);return s?n&&await this.peerStore.addressBook.add(r,n):s=await this.dialer.connectToPeer(e,t),s}get multiaddrs(){let e=this.addressManager.getAnnounceAddrs().map((e=>e.toString()));e.length||(e=this.transportManager.getAddrs().map((e=>e.toString()))),e=e.concat(this.addressManager.getObservedAddrs().map((e=>e.toString())));const t=this._options.addresses.announceFilter,r=new Set(e);return t(Array.from(r).map((e=>new c(e))))}async hangUp(e){const{id:t}=u(e),r=this.connectionManager.connections.get(t.toB58String());r&&await Promise.all(r.map((e=>e.close())))}fetch(e,t){return this.fetchService.fetch(e,t)}ping(e){const{id:t,multiaddrs:r}=u(e);return r?this.pingService.ping(r[0]):this.pingService.ping(t)}async handle(e,t){(e=Array.isArray(e)?e:[e]).forEach((e=>{this.upgrader.protocols.set(e,t)})),await this.peerStore.protoBook.add(this.peerId,e)}async unhandle(e){(e=Array.isArray(e)?e:[e]).forEach((e=>{this.upgrader.protocols.delete(e)})),await this.peerStore.protoBook.remove(this.peerId,e)}async _onStarting(){const e=this.addressManager.getListenAddrs();await this.transportManager.listen(e),this.natManager.start(),this._config.pubsub.enabled&&this.pubsub&&await this.pubsub.start(),this._config.dht.enabled&&(this._dht&&await this._dht.start(),this._dht.on("peer",this._onDiscoveryPeer)),this.metrics&&this.metrics.start(),this.identifyService&&await this.identifyService.start()}async _onDidStart(){this._isStarted=!0,this.peerStore.on("peer",(e=>{this.emit("peer:discovery",e),this._maybeConnect(e).catch((e=>{s.error(e)}))}));for await(const e of this.peerStore.getPeers())this.emit("peer:discovery",e.id);this.connectionManager.start(),await this._autodialler.start(),await this._setupPeerDiscovery(),this.relay&&this.relay.start(),this.peerRouting.start()}_onDiscoveryPeer(e){e.id.toB58String()!==this.peerId.toB58String()?(e.multiaddrs&&this.peerStore.addressBook.add(e.id,e.multiaddrs).catch((e=>s.error(e))),e.protocols&&this.peerStore.protoBook.set(e.id,e.protocols).catch((e=>s.error(e)))):s.error(new Error(f.ERR_DISCOVERED_SELF))}async _maybeConnect(e){if(!0===this._config.peerDiscovery.autoDial&&!this.connectionManager.get(e)){if((this._options.connectionManager.minConnections||0)>this.connectionManager.size){s("connecting to discovered peer %s",e.toB58String());try{await this.dialer.connectToPeer(e)}catch(t){s.error(`could not connect to discovered peer ${e.toB58String()} with ${t}`)}}}}async _setupPeerDiscovery(){const e=e=>{let t={enabled:!0};if(e.tag&&this._config.peerDiscovery&&this._config.peerDiscovery[e.tag]&&(t={...t,...this._config.peerDiscovery[e.tag]}),t.enabled&&!this._discovery.has(e.tag)){let r;r="function"===typeof e?new e(Object.assign({},t,{peerId:this.peerId,libp2p:this})):e,r.on("peer",this._onDiscoveryPeer),this._discovery.set(e.tag,r)}};for(const t of this._modules.peerDiscovery||[])e(t);for(const t of this.transportManager.getTransports())t.discovery&&e(t.discovery);await Promise.all(Array.from(this._discovery.values(),(e=>e.start())))}}e.exports=B},71038:e=>{"use strict";class t extends Map{constructor(e){super();const{system:t,component:r,metric:n,metrics:s}=e;this._system=t,this._component=r,this._metric=n,this._metrics=s,this._metrics.updateComponentMetric({system:this._system,component:this._component,metric:this._metric,value:this.size})}set(e,t){return super.set(e,t),this._metrics.updateComponentMetric({system:this._system,component:this._component,metric:this._metric,value:this.size}),this}delete(e){const t=super.delete(e);return this._metrics.updateComponentMetric({system:this._system,component:this._component,metric:this._metric,value:this.size}),t}clear(){super.clear(),this._metrics.updateComponentMetric({system:this._system,component:this._component,metric:this._metric,value:this.size})}}e.exports=e=>{let r,{system:n="libp2p",component:s,metric:o,metrics:i}=e;return r=i?new t({system:n,component:s,metric:o,metrics:i}):new Map,r}},44021:(e,t,r)=>{"use strict";const{Multiaddr:n}=r(10006),s=A("dns4"),o=A("dns6"),i=A("dnsaddr"),a=C(A("dns"),i,s,o),c=C(A("ip4"),A("ip6")),l=C(R(c,A("tcp")),R(a,A("tcp"))),d=R(c,A("udp")),h=R(d,A("utp")),u=R(d,A("quic")),p=C(R(l,A("ws")),R(a,A("ws"))),f=C(R(l,A("wss")),R(a,A("wss"))),g=C(R(l,A("http")),R(c,A("http")),R(a,A("http"))),y=C(R(l,A("https")),R(c,A("https")),R(a,A("https"))),w=C(R(p,A("p2p-webrtc-star"),A("p2p")),R(f,A("p2p-webrtc-star"),A("p2p")),R(p,A("p2p-webrtc-star")),R(f,A("p2p-webrtc-star"))),m=C(R(p,A("p2p-websocket-star"),A("p2p")),R(f,A("p2p-websocket-star"),A("p2p")),R(p,A("p2p-websocket-star")),R(f,A("p2p-websocket-star"))),v=C(R(g,A("p2p-webrtc-direct"),A("p2p")),R(y,A("p2p-webrtc-direct"),A("p2p")),R(g,A("p2p-webrtc-direct")),R(y,A("p2p-webrtc-direct"))),b=C(p,f,g,y,w,v,l,h,u,a),_=C(R(b,A("p2p-stardust"),A("p2p")),R(b,A("p2p-stardust"))),E=C(R(b,A("p2p")),w,v,A("p2p")),k=C(R(E,A("p2p-circuit"),E),R(E,A("p2p-circuit")),R(A("p2p-circuit"),E),R(b,A("p2p-circuit")),R(A("p2p-circuit"),b),A("p2p-circuit")),I=()=>C(R(k,I),k),S=I(),P=C(R(S,E,S),R(E,S),R(S,E),S,E);function D(e){return function(t){if(!n.isMultiaddr(t))try{t=new n(t)}catch(s){return!1}const r=e(t.protoNames());return null!==r&&(!0===r||!1===r?r:0===r.length)}}function R(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];function n(e){if(e.length<t.length)return null;let r=e;return t.some((t=>(r="function"===typeof t?t().partialMatch(e):t.partialMatch(e),Array.isArray(r)&&(e=r),null===r))),r}return{toString:function(){return"{ "+t.join(" ")+" }"},input:t,matches:D(n),partialMatch:n}}function C(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];function n(e){let r=null;return t.some((t=>{const n="function"===typeof t?t().partialMatch(e):t.partialMatch(e);return!!n&&(r=n,!0)})),r}const s={toString:function(){return"{ "+t.join(" ")+" }"},input:t,matches:D(n),partialMatch:n};return s}function A(e){const t=e;return{toString:function(){return t},matches:function(e){let r;if("string"===typeof e||e instanceof Uint8Array)try{r=new n(e)}catch(o){return!1}else r=e;const s=r.protoNames();return 1===s.length&&s[0]===t},partialMatch:function(e){return 0===e.length?null:e[0]===t?e.slice(1):null}}}e.exports={DNS:a,DNS4:s,DNS6:o,DNSADDR:i,IP:c,TCP:l,UDP:d,QUIC:u,UTP:h,HTTP:g,HTTPS:y,WebSockets:p,WebSocketsSecure:f,WebSocketStar:m,WebRTCStar:w,WebRTCDirect:v,Reliable:b,Stardust:_,Circuit:S,P2P:P,IPFS:P}},26494:(e,t,r)=>{const n=r(46338),s=r(23432),{default:o}=r(60185),{timeout:i}=r(17474),a=r(548),c={};let l;function d(e,t){let r;const n=new Promise((e=>{r=e}));return e.add((()=>i(new Promise((e=>{r((()=>{e()}))})),t.timeout))),n}const h={concurrency:1/0,timeout:846e5,global:r.g,singleProcess:!1};e.exports=(e,t)=>(t||(t={}),"object"===typeof e&&(t=e,e="lock"),e||(e="lock"),t=Object.assign({},h,t),l||(l=n(t)||s(t),l.isWorker||(l.on("requestReadLock",((e,t)=>{c[e]&&c[e].readLock().then((e=>t().finally((()=>e()))))})),l.on("requestWriteLock",(async(e,t)=>{c[e]&&c[e].writeLock().then((e=>t().finally((()=>e()))))})))),c[e]||(c[e]=((e,t)=>{if(l.isWorker)return{readLock:l.readLock(e,t),writeLock:l.writeLock(e,t)};const r=new o({concurrency:1});let n=null;return{readLock:()=>{if(n)return d(n,t);n=new o({concurrency:t.concurrency,autoStart:!1});const e=n,s=d(n,t);return r.add((()=>(e.start(),e.onIdle().then((()=>{n===e&&(n=null)}))))),s},writeLock:()=>(n=null,d(r,t))}})(e,t)),c[e]),e.exports.Worker=function(e,t){let n;t=t||r.g.Worker;try{n=new t(e)}catch(s){s.message.includes("not a constructor")&&(n=t(e))}if(!n)throw new Error("Could not create Worker from",t);return a(n),n}},36381:(e,t,r)=>{const{Multiaddr:n}=r(10006),s=(e,t)=>t,o={ip4:s,ip6:(e,t,r,n)=>1===n.length&&"ip6"===n[0].protocol?t:`[${t}]`,tcp:(e,t,r,n,s)=>n.some((e=>["http","https","ws","wss"].includes(e.protocol)))?`${e}:${t}`:((e,t,r,n)=>{if(n&&!1===n.assumeHttp)return`tcp://${e}:${t}`;let s="tcp",o=`:${t}`;return"tcp"===r[r.length-1].protocol&&(s="443"===t?"https":"http",o="443"===t||"80"===t?"":o),`${s}://${e}${o}`})(e,t,n,s),udp:(e,t)=>`udp://${e}:${t}`,dnsaddr:s,dns4:s,dns6:s,ipfs:(e,t)=>`${e}/ipfs/${t}`,p2p:(e,t)=>`${e}/p2p/${t}`,http:e=>`http://${e}`,https:e=>`https://${e}`,ws:e=>`ws://${e}`,wss:e=>`wss://${e}`,"p2p-websocket-star":e=>`${e}/p2p-websocket-star`,"p2p-webrtc-star":e=>`${e}/p2p-webrtc-star`,"p2p-webrtc-direct":e=>`${e}/p2p-webrtc-direct`};e.exports=(e,t)=>{const r=new n(e),s=e.toString().split("/").slice(1);return r.tuples().map((e=>({protocol:s.shift(),content:e[1]?s.shift():null}))).reduce(((e,r,n,s)=>{const i=o[r.protocol];if(!i)throw new Error(`Unsupported protocol ${r.protocol}`);return i(e,r.content,n,s,t)}),"")}},31579:(e,t,r)=>{"use strict";const n=r(61558);e.exports=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!n(e)&&!Array.isArray(e))throw new TypeError("Expected a plain object or array");const{deep:r}=t,s=[],o=[],i=e=>{const t=s.indexOf(e);if(-1!==t)return o[t];const r=[];return s.push(e),o.push(r),r.push(...e.map((e=>Array.isArray(e)?i(e):n(e)?a(e):e))),r},a=e=>{const c=s.indexOf(e);if(-1!==c)return o[c];const l={},d=Object.keys(e).sort(t.compare);s.push(e),o.push(l);for(const t of d){const s=e[t];let o;o=r&&Array.isArray(s)?i(s):r&&n(s)?a(s):s,Object.defineProperty(l,t,{...Object.getOwnPropertyDescriptor(e,t),value:o})}return l};return Array.isArray(e)?r?i(e):e.slice():a(e)}},98767:(e,t,r)=>{"use strict";const{AbortController:n}=globalThis,s=r(46094);class o extends n{constructor(e){super(),this._ms=e,this._timer=s((()=>this.abort()),e),Object.setPrototypeOf(this,o.prototype)}abort(){return this._timer.clear(),super.abort()}clear(){this._timer.clear()}reset(){this._timer.clear(),this._timer=s((()=>this.abort()),this._ms)}}e.exports={TimeoutController:o}},75617:(e,t,r)=>{e.exports={encode:r(84243),decode:r(69504),encodingLength:r(83754)}},47922:(e,t,r)=>{"use strict";r.r(t),r.d(t,{code:()=>R,createLink:()=>P,createNode:()=>S,decode:()=>A,encode:()=>C,name:()=>D,prepare:()=>k,validate:()=>I});var n=r(32743);const s=new TextDecoder;function o(e,t){let r=0;for(let n=0;;n+=7){if(n>=64)throw new Error("protobuf: varint overflow");if(t>=e.length)throw new Error("protobuf: unexpected end of data");const s=e[t++];if(r+=n<28?(127&s)<<n:(127&s)*2**n,s<128)break}return[r,t]}function i(e,t){let r;[r,t]=o(e,t);const n=t+r;if(r<0||n<0)throw new Error("protobuf: invalid length");if(n>e.length)throw new Error("protobuf: unexpected end of data");return[e.subarray(t,n),n]}function a(e,t){let r;return[r,t]=o(e,t),[7&r,r>>3,t]}function c(e){const t={},r=e.length;let n=0;for(;n<r;){let r,c;if([r,c,n]=a(e,n),1===c){if(t.Hash)throw new Error("protobuf: (PBLink) duplicate Hash section");if(2!==r)throw new Error(`protobuf: (PBLink) wrong wireType (${r}) for Hash`);if(void 0!==t.Name)throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");if(void 0!==t.Tsize)throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");[t.Hash,n]=i(e,n)}else if(2===c){if(void 0!==t.Name)throw new Error("protobuf: (PBLink) duplicate Name section");if(2!==r)throw new Error(`protobuf: (PBLink) wrong wireType (${r}) for Name`);if(void 0!==t.Tsize)throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");let o;[o,n]=i(e,n),t.Name=s.decode(o)}else{if(3!==c)throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${c}`);if(void 0!==t.Tsize)throw new Error("protobuf: (PBLink) duplicate Tsize section");if(0!==r)throw new Error(`protobuf: (PBLink) wrong wireType (${r}) for Tsize`);[t.Tsize,n]=o(e,n)}}if(n>r)throw new Error("protobuf: (PBLink) unexpected end of data");return t}const l=new TextEncoder,d=2**32;function h(e,t){let r=t.length;if("number"===typeof e.Tsize){if(e.Tsize<0)throw new Error("Tsize cannot be negative");if(!Number.isSafeInteger(e.Tsize))throw new Error("Tsize too large for encoding");r=f(t,r,e.Tsize)-1,t[r]=24}if("string"===typeof e.Name){const n=l.encode(e.Name);r-=n.length,t.set(n,r),r=f(t,r,n.length)-1,t[r]=18}return e.Hash&&(r-=e.Hash.length,t.set(e.Hash,r),r=f(t,r,e.Hash.length)-1,t[r]=10),t.length-r}function u(e){const t=function(e){let t=0;if(e.Data){const r=e.Data.length;t+=1+r+g(r)}if(e.Links)for(const r of e.Links){const e=p(r);t+=1+e+g(e)}return t}(e),r=new Uint8Array(t);let n=t;if(e.Data&&(n-=e.Data.length,r.set(e.Data,n),n=f(r,n,e.Data.length)-1,r[n]=10),e.Links)for(let s=e.Links.length-1;s>=0;s--){const t=h(e.Links[s],r.subarray(0,n));n-=t,n=f(r,n,t)-1,r[n]=18}return r}function p(e){let t=0;if(e.Hash){const r=e.Hash.length;t+=1+r+g(r)}if("string"===typeof e.Name){const r=l.encode(e.Name).length;t+=1+r+g(r)}return"number"===typeof e.Tsize&&(t+=1+g(e.Tsize)),t}function f(e,t,r){const n=t-=g(r);for(;r>=2147483648;)e[t++]=127&r|128,r/=128;for(;r>=128;)e[t++]=127&r|128,r>>>=7;return e[t]=r,n}function g(e){return e%2===0&&e++,Math.floor((function(e){let t=0;e>=d&&(e=Math.floor(e/d),t=32);e>=65536&&(e>>>=16,t+=16);e>=256&&(e>>>=8,t+=8);return t+y[e]}(e)+6)/7)}const y=[0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8],w=["Data","Links"],m=["Hash","Name","Tsize"],v=new TextEncoder;function b(e,t){if(e===t)return 0;const r=e.Name?v.encode(e.Name):[],n=t.Name?v.encode(t.Name):[];let s=r.length,o=n.length;for(let i=0,a=Math.min(s,o);i<a;++i)if(r[i]!==n[i]){s=r[i],o=n[i];break}return s<o?-1:o<s?1:0}function _(e,t){return!Object.keys(e).some((e=>!t.includes(e)))}function E(e){if("object"===typeof e.asCID){const t=n.CID.asCID(e);if(!t)throw new TypeError("Invalid DAG-PB form");return{Hash:t}}if("object"!==typeof e||Array.isArray(e))throw new TypeError("Invalid DAG-PB form");const t={};if(e.Hash){let s=n.CID.asCID(e.Hash);try{s||("string"===typeof e.Hash?s=n.CID.parse(e.Hash):e.Hash instanceof Uint8Array&&(s=n.CID.decode(e.Hash)))}catch(r){throw new TypeError(`Invalid DAG-PB form: ${r.message}`)}s&&(t.Hash=s)}if(!t.Hash)throw new TypeError("Invalid DAG-PB form");return"string"===typeof e.Name&&(t.Name=e.Name),"number"===typeof e.Tsize&&(t.Tsize=e.Tsize),t}function k(e){if((e instanceof Uint8Array||"string"===typeof e)&&(e={Data:e}),"object"!==typeof e||Array.isArray(e))throw new TypeError("Invalid DAG-PB form");const t={};if(void 0!==e.Data)if("string"===typeof e.Data)t.Data=v.encode(e.Data);else{if(!(e.Data instanceof Uint8Array))throw new TypeError("Invalid DAG-PB form");t.Data=e.Data}if(void 0!==e.Links){if(!Array.isArray(e.Links))throw new TypeError("Invalid DAG-PB form");t.Links=e.Links.map(E),t.Links.sort(b)}else t.Links=[];return t}function I(e){if(!e||"object"!==typeof e||Array.isArray(e))throw new TypeError("Invalid DAG-PB form");if(!_(e,w))throw new TypeError("Invalid DAG-PB form (extraneous properties)");if(void 0!==e.Data&&!(e.Data instanceof Uint8Array))throw new TypeError("Invalid DAG-PB form (Data must be a Uint8Array)");if(!Array.isArray(e.Links))throw new TypeError("Invalid DAG-PB form (Links must be an array)");for(let t=0;t<e.Links.length;t++){const r=e.Links[t];if(!r||"object"!==typeof r||Array.isArray(r))throw new TypeError("Invalid DAG-PB form (bad link object)");if(!_(r,m))throw new TypeError("Invalid DAG-PB form (extraneous properties on link object)");if(!r.Hash)throw new TypeError("Invalid DAG-PB form (link must have a Hash)");if(r.Hash.asCID!==r.Hash)throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");if(void 0!==r.Name&&"string"!==typeof r.Name)throw new TypeError("Invalid DAG-PB form (link Name must be a string)");if(void 0!==r.Tsize&&("number"!==typeof r.Tsize||r.Tsize%1!==0))throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");if(t>0&&-1===b(r,e.Links[t-1]))throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)")}}function S(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return k({Data:e,Links:t})}function P(e,t,r){return E({Hash:r,Name:e,Tsize:t})}const D="dag-pb",R=112;function C(e){I(e);const t={};return e.Links&&(t.Links=e.Links.map((e=>{const t={};return e.Hash&&(t.Hash=e.Hash.bytes),void 0!==e.Name&&(t.Name=e.Name),void 0!==e.Tsize&&(t.Tsize=e.Tsize),t}))),e.Data&&(t.Data=e.Data),u(t)}function A(e){const t=function(e){const t=e.length;let r,n,s=0,o=!1;for(;s<t;){let t,l;if([t,l,s]=a(e,s),2!==t)throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${t}`);if(1===l){if(n)throw new Error("protobuf: (PBNode) duplicate Data section");[n,s]=i(e,s),r&&(o=!0)}else{if(2!==l)throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${l}`);{if(o)throw new Error("protobuf: (PBNode) duplicate Links section");let t;r||(r=[]),[t,s]=i(e,s),r.push(c(t))}}}if(s>t)throw new Error("protobuf: (PBNode) unexpected end of data");const l={};return n&&(l.Data=n),l.Links=r||[],l}(e),r={};return t.Data&&(r.Data=t.Data),t.Links&&(r.Links=t.Links.map((e=>{const t={};try{t.Hash=n.CID.decode(e.Hash)}catch(r){}if(!t.Hash)throw new Error("Invalid Hash field found in link, expected CID");return void 0!==e.Name&&(t.Name=e.Name),void 0!==e.Tsize&&(t.Tsize=e.Tsize),t}))),r}},64429:(e,t,r)=>{"use strict";r.d(t,{Dy:()=>o.D,Jx:()=>s.Jx,WU:()=>o.W,cv:()=>n.cv});var n=r(61041),s=r(4712),o=r(96585)},53460:(e,t,r)=>{"use strict";r.d(t,{BB:()=>c,Dz:()=>a,Pu:()=>w,mL:()=>l,nI:()=>d,qu:()=>f,tP:()=>h,un:()=>p,zo:()=>u});const n=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&"function"===typeof globalThis.Buffer.isBuffer,s=new TextDecoder,o=new TextEncoder;function i(e){return n&&globalThis.Buffer.isBuffer(e)}function a(e){return e instanceof Uint8Array?i(e)?new Uint8Array(e.buffer,e.byteOffset,e.byteLength):e:Uint8Array.from(e)}const c=n?(e,t,r)=>r-t>64?globalThis.Buffer.from(e.subarray(t,r)).toString("utf8"):y(e,t,r):(e,t,r)=>r-t>64?s.decode(e.subarray(t,r)):y(e,t,r),l=n?e=>e.length>64?globalThis.Buffer.from(e):g(e):e=>e.length>64?o.encode(e):g(e),d=e=>Uint8Array.from(e),h=n?(e,t,r)=>i(e)?new Uint8Array(e.subarray(t,r)):e.slice(t,r):(e,t,r)=>e.slice(t,r),u=n?(e,t)=>(e=e.map((e=>e instanceof Uint8Array?e:globalThis.Buffer.from(e))),a(globalThis.Buffer.concat(e,t))):(e,t)=>{const r=new Uint8Array(t);let n=0;for(let s of e)n+s.length>r.length&&(s=s.subarray(0,r.length-n)),r.set(s,n),n+=s.length;return r},p=n?e=>globalThis.Buffer.allocUnsafe(e):e=>new Uint8Array(e);function f(e,t){if(i(e)&&i(t))return e.compare(t);for(let r=0;r<e.length;r++)if(e[r]!==t[r])return e[r]<t[r]?-1:1;return 0}function g(e){let t,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1/0;const n=e.length;let s=null;const o=[];for(let i=0;i<n;++i){if(t=e.charCodeAt(i),t>55295&&t<57344){if(!s){if(t>56319){(r-=3)>-1&&o.push(239,191,189);continue}if(i+1===n){(r-=3)>-1&&o.push(239,191,189);continue}s=t;continue}if(t<56320){(r-=3)>-1&&o.push(239,191,189),s=t;continue}t=65536+(s-55296<<10|t-56320)}else s&&(r-=3)>-1&&o.push(239,191,189);if(s=null,t<128){if((r-=1)<0)break;o.push(t)}else if(t<2048){if((r-=2)<0)break;o.push(t>>6|192,63&t|128)}else if(t<65536){if((r-=3)<0)break;o.push(t>>12|224,t>>6&63|128,63&t|128)}else{if(!(t<1114112))throw new Error("Invalid code point");if((r-=4)<0)break;o.push(t>>18|240,t>>12&63|128,t>>6&63|128,63&t|128)}}return o}function y(e,t,r){const n=[];for(;t<r;){const s=e[t];let o=null,i=s>239?4:s>223?3:s>191?2:1;if(t+i<=r){let r,n,a,c;switch(i){case 1:s<128&&(o=s);break;case 2:r=e[t+1],128===(192&r)&&(c=(31&s)<<6|63&r,c>127&&(o=c));break;case 3:r=e[t+1],n=e[t+2],128===(192&r)&&128===(192&n)&&(c=(15&s)<<12|(63&r)<<6|63&n,c>2047&&(c<55296||c>57343)&&(o=c));break;case 4:r=e[t+1],n=e[t+2],a=e[t+3],128===(192&r)&&128===(192&n)&&128===(192&a)&&(c=(15&s)<<18|(63&r)<<12|(63&n)<<6|63&a,c>65535&&c<1114112&&(o=c))}}null===o?(o=65533,i=1):o>65535&&(o-=65536,n.push(o>>>10&1023|55296),o=56320|1023&o),n.push(o),t+=i}return w(n)}function w(e){const t=e.length;if(t<=4096)return String.fromCharCode.apply(String,e);let r="",n=0;for(;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=4096));return r}},92526:(e,t,r)=>{"use strict";r.d(t,{DO:()=>i,IR:()=>n,OO:()=>s});const n="CBOR decode error:",s="CBOR encode error:",o=[];function i(e,t,r){if(e.length-t<r)throw new Error(`${n} not enough data for type`)}o[23]=1,o[24]=2,o[25]=3,o[26]=5,o[27]=9},4712:(e,t,r)=>{"use strict";r.d(t,{Jx:()=>h});var n=r(92526),s=r(96585),o=r(14829);const i={strict:!1,allowIndefinite:!0,allowUndefined:!0,allowBigInt:!0};class a{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.pos=0,this.data=e,this.options=t}done(){return this.pos>=this.data.length}next(){const e=this.data[this.pos];let t=o.PS[e];if(void 0===t){const r=o.cW[e];if(!r)throw new Error(`${n.IR} no decoder for major type ${e>>>5} (byte 0x${e.toString(16).padStart(2,"0")})`);const s=31&e;t=r(this.data,this.pos,s,this.options)}return this.pos+=t.encodedLength,t}}const c=Symbol.for("DONE"),l=Symbol.for("BREAK");function d(e,t){if(e.done())return c;const r=e.next();if(r.type===s.D.break)return l;if(r.type.terminal)return r.value;if(r.type===s.D.array)return function(e,t,r){const s=[];for(let o=0;o<e.value;o++){const i=d(t,r);if(i===l){if(e.value===1/0)break;throw new Error(`${n.IR} got unexpected break to lengthed array`)}if(i===c)throw new Error(`${n.IR} found array but not enough entries (got ${o}, expected ${e.value})`);s[o]=i}return s}(r,e,t);if(r.type===s.D.map)return function(e,t,r){const s=!0===r.useMaps,o=s?void 0:{},i=s?new Map:void 0;for(let a=0;a<e.value;a++){const h=d(t,r);if(h===l){if(e.value===1/0)break;throw new Error(`${n.IR} got unexpected break to lengthed map`)}if(h===c)throw new Error(`${n.IR} found map but not enough entries (got ${a} [no key], expected ${e.value})`);if(!0!==s&&"string"!==typeof h)throw new Error(`${n.IR} non-string keys not supported (got ${typeof h})`);const u=d(t,r);if(u===c)throw new Error(`${n.IR} found map but not enough entries (got ${a} [no value], expected ${e.value})`);s?i.set(h,u):o[h]=u}return s?i:o}(r,e,t);if(r.type===s.D.tag){if(t.tags&&"function"===typeof t.tags[r.value]){const n=d(e,t);return t.tags[r.value](n)}throw new Error(`${n.IR} tag not supported (${r.value})`)}throw new Error("unsupported")}function h(e,t){if(!(e instanceof Uint8Array))throw new Error(`${n.IR} data to decode must be a Uint8Array`);const r=(t=Object.assign({},i,t)).tokenizer||new a(e,t),s=d(r,t);if(s===c)throw new Error(`${n.IR} did not find any content to decode`);if(s===l)throw new Error(`${n.IR} got unexpected break`);if(!r.done())throw new Error(`${n.IR} too many terminals, data makes no sense`);return s}},61041:(e,t,r)=>{"use strict";r.d(t,{cv:()=>P,w$:()=>S});var n=r(86525),s=r(96585),o=r(56130),i=r(92526),a=r(14829),c=r(53460),l=r(9679),d=r(26421),h=r(99609),u=r(95665),p=r(88925),f=r(68613),g=r(50688),y=r(46947);const w={float64:!1,mapSorter:function(e,t){const r=Array.isArray(e[0])?e[0][0]:e[0],n=Array.isArray(t[0])?t[0][0]:t[0];if(r.type!==n.type)return r.type.compare(n.type);const s=r.type.major,o=m[s].compareTokens(r,n);0===o&&console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");return o},quickEncodeToken:a.JN};const m=function(){const e=[];return e[s.D.uint.major]=l.Fh,e[s.D.negint.major]=d.UT,e[s.D.bytes.major]=h.hg,e[s.D.string.major]=u.YW,e[s.D.array.major]=p.HF,e[s.D.map.major]=f.KI,e[s.D.tag.major]=g.xy,e[s.D.float.major]=y.tA,e}(),v=new o.Bl;class b{constructor(e,t){this.obj=e,this.parent=t}includes(e){let t=this;do{if(t.obj===e)return!0}while(t=t.parent);return!1}static createCheck(e,t){if(e&&e.includes(t))throw new Error(`${i.OO} object contains circular references`);return new b(t,e)}}const _={null:new s.W(s.D.null,null),undefined:new s.W(s.D.undefined,void 0),true:new s.W(s.D.true,!0),false:new s.W(s.D.false,!1),emptyArray:new s.W(s.D.array,0),emptyMap:new s.W(s.D.map,0)},E={number:(e,t,r,n)=>Number.isInteger(e)&&Number.isSafeInteger(e)?e>=0?new s.W(s.D.uint,e):new s.W(s.D.negint,e):new s.W(s.D.float,e),bigint:(e,t,r,n)=>e>=BigInt(0)?new s.W(s.D.uint,e):new s.W(s.D.negint,e),Uint8Array:(e,t,r,n)=>new s.W(s.D.bytes,e),string:(e,t,r,n)=>new s.W(s.D.string,e),boolean:(e,t,r,n)=>e?_.true:_.false,null:(e,t,r,n)=>_.null,undefined:(e,t,r,n)=>_.undefined,ArrayBuffer:(e,t,r,n)=>new s.W(s.D.bytes,new Uint8Array(e)),DataView:(e,t,r,n)=>new s.W(s.D.bytes,new Uint8Array(e.buffer,e.byteOffset,e.byteLength)),Array(e,t,r,n){if(!e.length)return!0===r.addBreakTokens?[_.emptyArray,new s.W(s.D.break)]:_.emptyArray;n=b.createCheck(n,e);const o=[];let i=0;for(const s of e)o[i++]=k(s,r,n);return r.addBreakTokens?[new s.W(s.D.array,e.length),o,new s.W(s.D.break)]:[new s.W(s.D.array,e.length),o]},Object(e,t,r,n){const o="Object"!==t,i=o?e.keys():Object.keys(e),a=o?e.size:i.length;if(!a)return!0===r.addBreakTokens?[_.emptyMap,new s.W(s.D.break)]:_.emptyMap;n=b.createCheck(n,e);const c=[];let l=0;for(const s of i)c[l++]=[k(s,r,n),k(o?e.get(s):e[s],r,n)];return function(e,t){t.mapSorter&&e.sort(t.mapSorter)}(c,r),r.addBreakTokens?[new s.W(s.D.map,a),c,new s.W(s.D.break)]:[new s.W(s.D.map,a),c]}};E.Map=E.Object,E.Buffer=E.Uint8Array;for(const D of"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))E[`${D}Array`]=E.DataView;function k(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=arguments.length>2?arguments[2]:void 0;const s=(0,n.is)(e),o=t&&t.typeEncoders&&t.typeEncoders[s]||E[s];if("function"===typeof o){const n=o(e,s,t,r);if(null!=n)return n}const a=E[s];if(!a)throw new Error(`${i.OO} unsupported type: ${s}`);return a(e,s,t,r)}function I(e,t,r,n){if(Array.isArray(t))for(const s of t)I(e,s,r,n);else r[t.type.major](e,t,n)}function S(e,t,r){const n=k(e,r);if(!Array.isArray(n)&&r.quickEncodeToken){const e=r.quickEncodeToken(n);if(e)return e;const s=t[n.type.major];if(s.encodedSize){const e=s.encodedSize(n,r),t=new o.Bl(e);if(s(t,n,r),1!==t.chunks.length)throw new Error(`Unexpected error: pre-calculated length for ${n} was wrong`);return(0,c.Dz)(t.chunks[0])}}return v.reset(),I(v,n,t,r),v.toBytes(!0)}function P(e,t){return t=Object.assign({},w,t),S(e,m,t)}},25937:(e,t,r)=>{"use strict";r.d(t,{c:()=>l});var n=r(96585),s=r(61041),o=r(92526),i=r(53460);class a extends Array{constructor(){super(),this.inRecursive=[]}prefix(e){const t=this.inRecursive[this.inRecursive.length-1];t&&(t.type===n.D.array&&(t.elements++,1!==t.elements&&e.push([44])),t.type===n.D.map&&(t.elements++,1!==t.elements&&(t.elements%2===1?e.push([44]):e.push([58]))))}[n.D.uint.major](e,t){this.prefix(e);const r=String(t.value),n=[];for(let s=0;s<r.length;s++)n[s]=r.charCodeAt(s);e.push(n)}[n.D.negint.major](e,t){this[n.D.uint.major](e,t)}[n.D.bytes.major](e,t){throw new Error(`${o.OO} unsupported type: Uint8Array`)}[n.D.string.major](e,t){this.prefix(e);const r=(0,i.mL)(JSON.stringify(t.value));e.push(r.length>32?(0,i.Dz)(r):r)}[n.D.array.major](e,t){this.prefix(e),this.inRecursive.push({type:n.D.array,elements:0}),e.push([91])}[n.D.map.major](e,t){this.prefix(e),this.inRecursive.push({type:n.D.map,elements:0}),e.push([123])}[n.D.tag.major](e,t){}[n.D.float.major](e,t){if("break"===t.type.name){const t=this.inRecursive.pop();if(t){if(t.type===n.D.array)e.push([93]);else{if(t.type!==n.D.map)throw new Error("Unexpected recursive type; this should not happen!");e.push([125])}return}throw new Error("Unexpected break; this should not happen!")}if(void 0===t.value)throw new Error(`${o.OO} unsupported type: undefined`);if(this.prefix(e),"true"===t.type.name)return void e.push([116,114,117,101]);if("false"===t.type.name)return void e.push([102,97,108,115,101]);if("null"===t.type.name)return void e.push([110,117,108,108]);const r=String(t.value),s=[];let i=!1;for(let n=0;n<r.length;n++)s[n]=r.charCodeAt(n),i||46!==s[n]&&101!==s[n]&&69!==s[n]||(i=!0);i||(s.push(46),s.push(48)),e.push(s)}}const c={addBreakTokens:!0,mapSorter:function(e,t){if(Array.isArray(e[0])||Array.isArray(t[0]))throw new Error(`${o.OO} complex map keys are not supported`);const r=e[0],s=t[0];if(r.type!==n.D.string||s.type!==n.D.string)throw new Error(`${o.OO} non-string map keys are not supported`);if(r<s)return-1;if(r>s)return 1;throw new Error(`${o.OO} unexpected duplicate map keys, this is not supported`)}};function l(e,t){return t=Object.assign({},c,t),(0,s.w$)(e,new a,t)}},14829:(e,t,r)=>{"use strict";r.d(t,{JN:()=>m,PS:()=>w,cW:()=>y});var n=r(96585),s=r(9679),o=r(26421),i=r(99609),a=r(95665),c=r(88925),l=r(68613),d=r(50688),h=r(46947),u=r(92526),p=r(53460);function f(e,t,r){throw new Error(`${u.IR} encountered invalid minor (${r}) for major ${e[t]>>>5}`)}function g(e){return()=>{throw new Error(`${u.IR} ${e}`)}}const y=[];for(let v=0;v<=23;v++)y[v]=f;y[24]=s.Km,y[25]=s.Zh,y[26]=s.cs,y[27]=s.uN,y[28]=f,y[29]=f,y[30]=f,y[31]=f;for(let v=32;v<=55;v++)y[v]=f;y[56]=o.yr,y[57]=o.r0,y[58]=o.wy,y[59]=o.ec,y[60]=f,y[61]=f,y[62]=f,y[63]=f;for(let v=64;v<=87;v++)y[v]=i.Ii;y[88]=i.UQ,y[89]=i.BS,y[90]=i.zU,y[91]=i.ME,y[92]=f,y[93]=f,y[94]=f,y[95]=g("indefinite length bytes/strings are not supported");for(let v=96;v<=119;v++)y[v]=a.nt;y[120]=a.Bq,y[121]=a.h,y[122]=a.q0,y[123]=a.bc,y[124]=f,y[125]=f,y[126]=f,y[127]=g("indefinite length bytes/strings are not supported");for(let v=128;v<=151;v++)y[v]=c.Ju;y[152]=c.h7,y[153]=c.OC,y[154]=c.lY,y[155]=c.a8,y[156]=f,y[157]=f,y[158]=f,y[159]=c.s5;for(let v=160;v<=183;v++)y[v]=l._K;y[184]=l.G,y[185]=l.qe,y[186]=l.IY,y[187]=l.F2,y[188]=f,y[189]=f,y[190]=f,y[191]=l.ng;for(let v=192;v<=215;v++)y[v]=d.qJ;y[216]=d.ZR,y[217]=d.CF,y[218]=d.vP,y[219]=d.MV,y[220]=f,y[221]=f,y[222]=f,y[223]=f;for(let v=224;v<=243;v++)y[v]=g("simple values are not supported");y[244]=f,y[245]=f,y[246]=f,y[247]=h.h1,y[248]=g("simple values are not supported"),y[249]=h.mW,y[250]=h.GI,y[251]=h.vV,y[252]=f,y[253]=f,y[254]=f,y[255]=h.y7;const w=[];for(let v=0;v<24;v++)w[v]=new n.W(n.D.uint,v,1);for(let v=-1;v>=-24;v--)w[31-v]=new n.W(n.D.negint,v,1);function m(e){switch(e.type){case n.D.false:return(0,p.nI)([244]);case n.D.true:return(0,p.nI)([245]);case n.D.null:return(0,p.nI)([246]);case n.D.bytes:return e.value.length?void 0:(0,p.nI)([64]);case n.D.string:return""===e.value?(0,p.nI)([96]):void 0;case n.D.array:return 0===e.value?(0,p.nI)([128]):void 0;case n.D.map:return 0===e.value?(0,p.nI)([160]):void 0;case n.D.uint:return e.value<24?(0,p.nI)([Number(e.value)]):void 0;case n.D.negint:if(e.value>=-24)return(0,p.nI)([31-Number(e.value)])}}w[64]=new n.W(n.D.bytes,new Uint8Array(0),1),w[96]=new n.W(n.D.string,"",1),w[128]=new n.W(n.D.array,0,1),w[160]=new n.W(n.D.map,0,1),w[244]=new n.W(n.D.false,!1,1),w[245]=new n.W(n.D.true,!0,1),w[246]=new n.W(n.D.null,null,1)},96585:(e,t,r)=>{"use strict";r.d(t,{D:()=>n,W:()=>s});class n{constructor(e,t,r){this.major=e,this.majorEncoded=e<<5,this.name=t,this.terminal=r}toString(){return`Type[${this.major}].${this.name}`}compare(e){return this.major<e.major?-1:this.major>e.major?1:0}}n.uint=new n(0,"uint",!0),n.negint=new n(1,"negint",!0),n.bytes=new n(2,"bytes",!0),n.string=new n(3,"string",!0),n.array=new n(4,"array",!1),n.map=new n(5,"map",!1),n.tag=new n(6,"tag",!1),n.float=new n(7,"float",!0),n.false=new n(7,"false",!0),n.true=new n(7,"true",!0),n.null=new n(7,"null",!0),n.undefined=new n(7,"undefined",!0),n.break=new n(7,"break",!0);class s{constructor(e,t,r){this.type=e,this.value=t,this.encodedLength=r,this.encodedBytes=void 0,this.byteValue=void 0}toString(){return`Token[${this.type}].${this.value}`}}},62287:(e,t,r)=>{"use strict";r.r(t),r.d(t,{BaseDatastore:()=>o.e,Errors:()=>u,KeyTransformDatastore:()=>a.v,MemoryDatastore:()=>i.MemoryDatastore,MountDatastore:()=>l.L,NamespaceDatastore:()=>h.v,ShardingDatastore:()=>c.G,TieredDatastore:()=>d.z,shard:()=>p});var n=r(66957),s=r(87511),o=r(8954),i=r(51854),a=r(13252),c=r(64661),l=r(11524),d=r(97823),h=r(69611);const u=n,p=s},49301:(e,t,r)=>{"use strict";r.d(t,{m:()=>l});var n=r(96032),s=r(43019),o=r(48009),i=r(71038);const a=o.v.Wantlist.WantType.Block,c=o.v.Wantlist.WantType.Have;class l{constructor(e,t){this.set=t?i({system:"ipfs",component:"bitswap",metric:"wantlist",metrics:t.metrics}):new Map,this._stats=e}get length(){return this.set.size}add(e,t,r){const o=e.toString(s.base58btc),i=this.set.get(o);i?(i.inc(),i.priority=t,i.wantType===c&&r===a&&(i.wantType=r)):(this.set.set(o,new n.D(e,t,r)),this._stats&&this._stats.push(null,"wantListSize",1))}remove(e){const t=e.toString(s.base58btc),r=this.set.get(t);r&&(r.dec(),r.hasRefs()||(this.set.delete(t),this._stats&&this._stats.push(null,"wantListSize",-1)))}removeForce(e){this.set.has(e)&&this.set.delete(e)}forEach(e){return this.set.forEach(e)}entries(){return this.set.entries()}sortedEntries(){return new Map((e=e=>e[1].key,t=Array.from(this.set.entries()),Array.prototype.slice.call(t,0).sort(((t,r)=>{const n=e(t),s=e(r);return n<s?-1:n>s?1:0}))));var e,t}contains(e){const t=e.toString(s.base58btc);return this.set.has(t)}get(e){const t=e.toString(s.base58btc);return this.set.get(t)}}l.Entry=n.D},40389:(e,t,r)=>{"use strict";r.d(t,{n:()=>l});var n=r(15504),s=r(55194),o=r(62469),i=r(60191),a=r(47664),c=r(5724);async function*l(e,t){if("string"===typeof e||e instanceof String||(0,a._t)(e)||(0,a.Lj)(e)||e._readableState)throw n(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"),"ERR_UNEXPECTED_INPUT");if((0,a.Os)(e)&&(e=s(e)),Symbol.iterator in e||Symbol.asyncIterator in e){const r=o(e),{value:s,done:c}=await r.peek();if(c)return void(yield*[]);if(r.push(s),Number.isInteger(s))throw n(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"),"ERR_UNEXPECTED_INPUT");if(s._readableState)return void(yield*i(r,(e=>d({content:e},t))));if((0,a._t)(s))return void(yield d({content:r},t));if((0,a.Mk)(s)||s[Symbol.iterator]||s[Symbol.asyncIterator]||(0,a.Os)(s)||(0,a.Lj)(s))return void(yield*i(r,(e=>d(e,t))))}if((0,a.Mk)(e))throw n(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"),"ERR_UNEXPECTED_INPUT");throw n(new Error("Unexpected input: "+typeof e),"ERR_UNEXPECTED_INPUT")}async function d(e,t){const{path:r,mode:n,mtime:s,content:o}=e,i={path:r||"",mode:(0,c.tK)(n),mtime:(0,c.Xu)(s)};return o?i.content=await t(o):r||(i.content=await t(e)),i}},41048:(e,t,r)=>{"use strict";r.d(t,{a:()=>a});var n=r(98767),s=r(98691),o=r(73620);class i extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"request timed out"),this.name="TimeoutError",this.code=i.code}}function a(e,t){return function(){for(var r=arguments.length,a=new Array(r),c=0;c<r;c++)a[c]=arguments[c];const l=a[null==t?a.length-1:t];if(!l||!l.timeout)return e(...a);const d="string"===typeof l.timeout?(0,o.Z)(l.timeout):l.timeout,h=new n.TimeoutController(d);l.signal=(0,s.anySignal)([l.signal,h.signal]);const u=e(...a),p=new Promise(((e,t)=>{h.signal.addEventListener("abort",(()=>{t(new i)}))})),f=Date.now(),g=()=>{if(h.signal.aborted)throw new i;if(Date.now()-f>d)throw h.abort(),new i};return u[Symbol.asyncIterator]?async function*(){const e=u[Symbol.asyncIterator]();try{for(;;){const{value:t,done:r}=await Promise.race([e.next(),p]);if(r)break;g(),yield t}}catch(t){throw g(),t}finally{h.clear(),e.return&&e.return()}}():(async()=>{try{const e=await Promise.race([u,p]);return g(),e}catch(e){throw g(),e}finally{h.clear()}})()}}i.code="ERR_TIMEOUT"},70962:(e,t,r)=>{"use strict";r.d(t,{Y:()=>o});var n=r(26494);let s;function o(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(s)return s;const t=n({singleProcess:e});return s={readLock:e=>async function(){const r=await t.readLock();try{for(var n=arguments.length,s=new Array(n),o=0;o<n;o++)s[o]=arguments[o];return await e.apply(null,s)}finally{r()}},writeLock:e=>async function(){const r=await t.writeLock();try{for(var n=arguments.length,s=new Array(n),o=0;o<n;o++)s[o]=arguments[o];return await e.apply(null,s)}finally{r()}}},s}},61542:(e,t,r)=>{"use strict";r.d(t,{x:()=>h});var n=r(32743),s=r(5724),o=r(47922),i=r(92829),a=r(60720),c=r(15504),l=r(97085);const d=a("ipfs:mfs:utils:with-mfs-root");async function h(e,t){if(t&&t.signal&&t.signal.aborted)throw c(new Error("Request aborted"),"ERR_ABORTED",{name:"Aborted"});let r;await e.repo.datastore.open();try{const t=await e.repo.datastore.get(l.Nt);r=n.CID.decode(t)}catch(a){if("ERR_NOT_FOUND"!==a.code)throw a;d("Creating new MFS root");const h=o.encode({Data:new s.fL({type:"directory"}).marshal(),Links:[]}),u=await i.sha256.digest(h);if(r=n.CID.createV0(u),await e.repo.blocks.put(r,h),t&&t.signal&&t.signal.aborted)throw c(new Error("Request aborted"),"ERR_ABORTED",{name:"Aborted"});await e.repo.datastore.put(l.Nt,r.bytes)}return d(`Loaded MFS root /ipfs/${r}`),r}},58120:(e,t,r)=>{"use strict";r.d(t,{k0:()=>u.CID,Ue:()=>od,bf:()=>id});var n={};r.r(n),r.d(n,{code:()=>y,decode:()=>m,encode:()=>w,name:()=>g});var s={};r.r(s),r.d(s,{code:()=>D,decode:()=>C,encode:()=>R,name:()=>P});var o=r(664),i=r(41257),a=r(60720),c=r(15504),l=r(5724),d=r(47922),h=r(64429),u=r(32743);const p={float64:!0,typeEncoders:{Object:function(e){if(e.asCID!==e)return null;const t=u.CID.asCID(e);if(!t)return null;const r=new Uint8Array(t.bytes.byteLength+1);return r.set(t.bytes,1),[new h.WU(h.Dy.tag,42),new h.WU(h.Dy.bytes,r)]},undefined:function(){throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")},number:function(e){if(Number.isNaN(e))throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");if(e===1/0||e===-1/0)throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");return null}}};const f={allowIndefinite:!1,coerceUndefinedToNull:!0,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,tags:[]};f.tags[42]=function(e){if(0!==e[0])throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");return u.CID.decode(e.subarray(1))};const g="dag-cbor",y=113,w=e=>h.cv(e,p),m=e=>h.Jx(e,f);var v=r(28546),b=r(63225),_=r(54743);function E(e){const t=b.base64.encode(e).slice(1);return[new h.WU(h.Dy.map,1/0,1),new h.WU(h.Dy.string,"/",1),new h.WU(h.Dy.map,1/0,1),new h.WU(h.Dy.string,"bytes",5),new h.WU(h.Dy.string,t,t.length),new h.WU(h.Dy.break,void 0,1),new h.WU(h.Dy.break,void 0,1)]}const k={typeEncoders:{Object:function(e){if(e.asCID!==e)return null;const t=v.k0.asCID(e);if(!t)return null;const r=t.toString();return[new h.WU(h.Dy.map,1/0,1),new h.WU(h.Dy.string,"/",1),new h.WU(h.Dy.string,r,r.length),new h.WU(h.Dy.break,void 0,1)]},Uint8Array:E,Buffer:E,undefined:function(){throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")},number:function(e){if(Number.isNaN(e))throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");if(e===1/0||e===-1/0)throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");return null}}};class I extends _.d2{constructor(e,t){super(e,t),this.tokenBuffer=[]}done(){return 0===this.tokenBuffer.length&&super.done()}_next(){return this.tokenBuffer.length>0?this.tokenBuffer.pop():super.next()}next(){const e=this._next();if(e.type===h.Dy.map){const e=this._next();if(e.type===h.Dy.string&&"/"===e.value){const e=this._next();if(e.type===h.Dy.string){if(this._next().type!==h.Dy.break)throw new Error("Invalid encoded CID form");return this.tokenBuffer.push(e),new h.WU(h.Dy.tag,42,0)}if(e.type===h.Dy.map){const e=this._next();if(e.type===h.Dy.string&&"bytes"===e.value){const e=this._next();if(e.type===h.Dy.string){for(let e=0;e<2;e++){if(this._next().type!==h.Dy.break)throw new Error("Invalid encoded Bytes form")}const t=b.base64.decode(`m${e.value}`);return new h.WU(h.Dy.bytes,t,e.value.length)}this.tokenBuffer.push(e)}this.tokenBuffer.push(e)}this.tokenBuffer.push(e)}this.tokenBuffer.push(e)}return e}}const S={allowIndefinite:!1,allowUndefined:!1,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,tags:[]};S.tags[42]=v.k0.parse;const P="dag-json",D=297,R=e=>_.cv(e,k),C=e=>{const t=Object.assign(S,{tokenizer:new I(e,S)});return _.Jx(e,t)};var A=r(58735),T=r.t(A,2),N=r(80073),O=r(40963),B=r(38167);class j extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"not initialized"),this.name="NotInitializedError",this.code=j.code}}j.code="ERR_NOT_INITIALIZED";class x extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"cannot initialize an initializing node"),this.name="AlreadyInitializingError",this.code=L.code}}x.code="ERR_ALREADY_INITIALIZING";class L extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"cannot re-initialize an initialized node"),this.name="AlreadyInitializedError",this.code=L.code}}L.code="ERR_ALREADY_INITIALIZED";class M extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"not started"),this.name="NotStartedError",this.code=M.code}}M.code="ERR_NOT_STARTED";class $ extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"cannot start, already startin"),this.name="AlreadyStartingError",this.code=$.code}}$.code="ERR_ALREADY_STARTING";class U extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"cannot start, already started"),this.name="AlreadyStartedError",this.code=U.code}}U.code="ERR_ALREADY_STARTED";class F extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"not enabled"),this.name="NotEnabledError",this.code=F.code}}F.code="ERR_NOT_ENABLED";var z=r(68425),W=r(97085);class H{static create(e){let{start:t,stop:r}=e;return new H(t,r)}static async start(e,t){const{state:r,activate:n}=e;switch(r.status){case"stopped":try{const r=n(t);e.state={status:"starting",ready:r};const s=await r;return e.state={status:"started",value:s},s}catch(s){throw e.state={status:"stopped"},s}case"starting":throw new $;case"started":throw new U;case"stopping":return await r.ready,await H.start(e,t);default:return H.panic(e)}}static async stop(e){const{state:t,deactivate:r}=e;switch(t.status){case"stopped":break;case"starting":try{await t.ready}catch(n){}return await H.stop(e);case"stopping":return await t.ready;case"started":r&&await r(t.value),e.state={status:"stopped"};break;default:H.panic(t)}}static try(e){let{state:t}=e;return"started"===t.status?t.value:null}static async use(e,t){let{state:r}=e;switch(r.status){case"started":return r.value;case"starting":return await(0,W.Fb)(r.ready,t);default:throw new M}}static panic(e){let{state:t}=e;const r=JSON.stringify({status:t.status});throw RangeError(`Service in invalid state ${r}, should never happen if you see this please report a bug`)}constructor(e,t){this.activate=e,this.deactivate=t,this.state={status:"stopped"}}async use(e){return await H.use(this,e)}try(){return H.try(this)}}var K=r(42623),G=r(60185),q=r(68170);const V=new K.E(1e3),X=new(G.default?G.default:G)({concurrency:4}),Y=e=>{if(e.Path)return e.Path;throw new Error(e.Message)};async function J(e,t){return async function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const r=new URLSearchParams(t);r.set("arg",e);const n=r.toString();if(!t.nocache&&V.has(n)){const e=V.get(n);return Y(e)}const s=await X.add((async()=>{const e=await q.get("https://ipfs.io/api/v0/dns",{searchParams:r}),t=new URL(e.url).search.slice(1),n=await e.json();return V.set(t,n,6e4),n}));return Y(s)}(e,t)}var Q=r(41048);function Z(e){return e.endsWith(".eth")&&(e=e.replace(/.eth$/,".eth.link")),e}var ee=r(7022),te=r(13380),re=r(91401);function ne(e){try{return re.parse(e).toBytes()}catch{return u.CID.parse(e).bytes}}var se=r(16586);async function*oe(e){if(null===e||void 0===e)throw c(new Error(`Unexpected input: ${e}`),"ERR_UNEXPECTED_INPUT");const t=u.CID.asCID(e);if(t)yield ie({cid:t});else{if(!(e instanceof String||"string"===typeof e)){if(null!=e.cid||null!=e.path)return yield ie(e);if(Symbol.iterator in e){const t=e[Symbol.iterator](),r=t.next();if(r.done)return t;if(u.CID.asCID(r.value)||r.value instanceof String||"string"===typeof r.value){yield ie({cid:r.value});for(const e of t)yield ie({cid:e});return}if(null!=r.value.cid||null!=r.value.path){yield ie(r.value);for(const e of t)yield ie(e);return}throw c(new Error("Unexpected input: "+typeof e),"ERR_UNEXPECTED_INPUT")}if(Symbol.asyncIterator in e){const t=e[Symbol.asyncIterator](),r=await t.next();if(r.done)return t;if(u.CID.asCID(r.value)||r.value instanceof String||"string"===typeof r.value){yield ie({cid:r.value});for await(const e of t)yield ie({cid:e});return}if(null!=r.value.cid||null!=r.value.path){yield ie(r.value);for await(const e of t)yield ie(e);return}throw c(new Error("Unexpected input: "+typeof e),"ERR_UNEXPECTED_INPUT")}throw c(new Error("Unexpected input: "+typeof e),"ERR_UNEXPECTED_INPUT")}yield ie({path:e})}}function ie(e){const t=e.cid||`${e.path}`;if(!t)throw c(new Error("Unexpected input: Please path either a CID or an IPFS path"),"ERR_UNEXPECTED_INPUT");const r={path:t,recursive:!1!==e.recursive};return null!=e.metadata&&(r.metadata=e.metadata),r}const ae={direct:"direct",recursive:"recursive",indirect:"indirect",all:"all"};function ce(e,t,r){const n={type:e,cid:t};return r&&(n.metadata=r),n}class le{constructor(e){let{codecs:t,repo:r}=e;const n=function(e){let{repo:t,codecs:r}=e;return(0,Q.a)((async function*(e){const n=async function*(){for await(const{path:n,recursive:s,metadata:o}of oe(e)){const{cid:e}=await(0,W.i3)(t,r,n),{reason:i}=await t.pins.isPinnedWithType(e,[ae.recursive,ae.direct]);if("recursive"===i&&!s)throw new Error(`${e} already pinned recursively`);s?await t.pins.pinRecursively(e,{metadata:o}):await t.pins.pinDirectly(e,{metadata:o}),yield e}};if(!Boolean((arguments.length>1&&void 0!==arguments[1]?arguments[1]:{}).lock))return void(yield*n());const s=await t.gcLock.readLock();try{yield*n()}finally{s()}}))}({codecs:t,repo:r});this.addAll=n,this.add=function(e){let{addAll:t}=e;return function(e){let r,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const s=u.CID.asCID(e);return r=t(s?[{cid:s,...n}]:[{path:e.toString(),...n}],n),se(r)}}({addAll:n});const s=function(e){let{repo:t,codecs:r}=e;return(0,Q.a)((async function*(e){const n=await t.gcLock.readLock();try{for await(const{path:n,recursive:s}of oe(e)){const{cid:e}=await(0,W.i3)(t,r,n),{pinned:o,reason:i}=await t.pins.isPinnedWithType(e,ae.all);if(!o)throw new Error(`${e} is not pinned`);switch(i){case ae.recursive:if(!s)throw new Error(`${e} is pinned recursively`);await t.pins.unpin(e),yield e;break;case ae.direct:await t.pins.unpin(e),yield e;break;default:throw new Error(`${e} is pinned indirectly under ${i}`)}}}finally{n()}}))}({codecs:t,repo:r});this.rmAll=s,this.rm=function(e){let{rmAll:t}=e;return async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await se(t([{path:e,...r}],r));if(!n)throw new Error("CID expected");return n}}({rmAll:s}),this.ls=function(e){let{repo:t,codecs:r}=e;return(0,Q.a)((async function*(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=ae.all;if(e.type&&(n=e.type,!Object.keys(ae).includes(n)))throw c(new Error("Invalid pin type"),"ERR_INVALID_PIN_TYPE");if(e.paths){let s=!1;for await(const{path:o}of oe(e.paths)){const{cid:e}=await(0,W.i3)(t,r,o),{reason:i,pinned:a,parent:l,metadata:d}=await t.pins.isPinnedWithType(e,n);if(!a)throw c(new Error(`path '${o}' is not pinned`),"ERR_NOT_PINNED");switch(i){case ae.direct:case ae.recursive:s=!0,yield ce(i,e,d);break;default:s=!0,yield ce(`${ae.indirect} through ${l}`,e,d)}}if(!s)throw new Error("No match found")}else{if(n===ae.recursive||n===ae.all)for await(const{cid:e,metadata:r}of t.pins.recursiveKeys())yield ce(ae.recursive,e,r);if(n===ae.indirect||n===ae.all)for await(const r of t.pins.indirectKeys(e))yield ce(ae.indirect,r);if(n===ae.direct||n===ae.all)for await(const{cid:e,metadata:r}of t.pins.directKeys())yield ce(ae.direct,e,r)}}))}({codecs:t,repo:r}),this.remote={add:function(e){return Promise.reject(new Error("Not implemented"))},ls:async function*(e){return Promise.reject(new Error("Not implemented"))},rm:function(e){return Promise.reject(new Error("Not implemented"))},rmAll:function(e){return Promise.reject(new Error("Not implemented"))},service:{add:(e,t)=>Promise.reject(new Error("Not implemented")),rm:function(e){return Promise.reject(new Error("Not implemented"))},ls:function(){return Promise.reject(new Error("Not implemented"))}}}}}var de=r(82149),he=r(66957),ue=r(93314),pe=r(10764),fe=r(51199),ge=r(70380),ye=r(17578),we=r(79357),me=r(52769),ve=r(61163),be=r(19061),_e=r(90309),Ee=r(86034);const ke=Object.assign(a("jsipns"),{error:a("jsipns:error")}),Ie=N.identity.code,Se=(0,z.fromString)("/ipns/"),Pe="/ipns/",De=Pe.length,Re=async(e,t,r,n,s,o)=>{r=BigInt(r);const i=(0,z.fromString)(s.toString()),a=await xe(e,t,n,i),c=Ce(t,i,n,r,o),l=Me(c),d={value:t,signature:a,validityType:n,validity:i,sequence:r,ttl:o,signatureV2:await e.sign(l),data:c};return ke(`ipns entry for ${t} created`),d},Ce=(e,t,r,n,s)=>{const o={Value:e,Validity:t,ValidityType:r,Sequence:n,TTL:s};return h.cv(o)},Ae=async(e,t)=>{const{value:r,validityType:n,validity:s}=t;let o,i,a;t.signatureV2&&t.data?(i=t.signatureV2,o=Me(t.data),Te(t)):(i=t.signature,o=Le(r,n,s));try{a=await e.verify(o,i)}catch(l){a=!1}if(!a)throw ke.error("record signature verification failed"),c(new Error("record signature verification failed"),Ee.SY);if(n===be.X.ValidityType.EOL){let e;try{e=(0,_e.r)((0,ue.toString)(s))}catch(d){throw ke.error("unrecognized validity format (not an rfc3339 format)"),c(new Error("unrecognized validity format (not an rfc3339 format)"),Ee.vH)}if(e.getTime()<Date.now())throw ke.error("record has expired"),c(new Error("record has expired"),Ee.L0)}else if(n)throw ke.error("unrecognized validity type"),c(new Error("unrecognized validity type"),Ee.Fl);ke(`ipns entry for ${r} is valid`)},Te=e=>{if(!e.data)throw c(new Error("Record data is missing"),Ee.BL);const t=h.Jx(e.data);if(Number.isInteger(t.Sequence)&&(t.Sequence=BigInt(t.Sequence)),Number.isInteger(t.TTL)&&(t.TTL=BigInt(t.TTL)),!(0,pe.equals)(t.Value,e.value))throw c(new Error('Field "value" did not match between protobuf and CBOR'),Ee.SY);if(!(0,pe.equals)(t.Validity,e.validity))throw c(new Error('Field "validity" did not match between protobuf and CBOR'),Ee.SY);if(t.ValidityType!==e.validityType)throw c(new Error('Field "validityType" did not match between protobuf and CBOR'),Ee.SY);if(t.Sequence!==e.sequence)throw c(new Error('Field "sequence" did not match between protobuf and CBOR'),Ee.SY);if(t.TTL!==e.ttl)throw c(new Error('Field "ttl" did not match between protobuf and CBOR'),Ee.SY)},Ne=async(e,t)=>{if(!t||!e){const e=new Error("one or more of the provided parameters are not defined");throw ke.error(e),c(e,Ee.eb)}let r;if(t.pubKey){try{r=ge.keys.unmarshalPublicKey(t.pubKey)}catch(n){throw ke.error(n),n}if(!(await re.createFromPubKey(t.pubKey)).equals(e))throw c(new Error("Embedded public key did not match PeerID"),Ee.TO)}else e.pubKey&&(r=e.pubKey);if(r)return r;throw c(new Error("no public key is available"),Ee.eb)},Oe=e=>we.base32upper.encode(e).slice(1),Be=e=>new de.Key(`/ipns/${Oe(e)}`),je=e=>{const t=(0,z.fromString)("/pk/"),r=(0,z.fromString)("/ipns/");return{routingPubKey:new de.Key((0,me.concat)([t,e]),!1),pkKey:new de.Key(Oe((0,me.concat)([t,e]))),routingKey:new de.Key((0,me.concat)([r,e]),!1),ipnsKey:new de.Key(Oe((0,me.concat)([r,e])))}},xe=(e,t,r,n)=>{try{const s=Le(t,r,n);return e.sign(s)}catch(s){throw ke.error("record signature creation failed"),c(new Error("record signature creation failed: "+s.message),Ee.FB)}},Le=(e,t,r)=>{const n=(0,z.fromString)((e=>{if("0"===e.toString())return"EOL";const t=new Error(`unrecognized validity type ${e.toString()}`);throw ke.error(t),c(t,Ee.Fl)})(t));return(0,me.concat)([e,r,n])},Me=e=>{const t=(0,z.fromString)("ipns-signature:");return(0,me.concat)([t,e])},$e=e=>{const t=ye.decode(e.id);return t.code!==Ie?null:ge.keys.unmarshalPublicKey(t.digest)},Ue=e=>be.X.encode({...e,sequence:ve.fromString(e.sequence.toString()),ttl:null==e.ttl?void 0:ve.fromString(e.ttl.toString())}).finish(),Fe=e=>{const t=be.X.decode(e),r=be.X.toObject(t,{defaults:!1,arrays:!0,objects:!1});return{value:r.value,signature:r.signature,validityType:r.validityType,validity:r.validity,sequence:Object.hasOwnProperty.call(r,"sequence")?BigInt(`${r.sequence}`):0,pubKey:r.pubKey,ttl:Object.hasOwnProperty.call(r,"ttl")?BigInt(`${r.ttl}`):void 0,signatureV2:r.signatureV2,data:r.data}},ze={validate:async(e,t)=>{const r=Fe(e),n=t.slice(Se.length),s=re.createFromBytes(n),o=await Ne(s,r);await Ae(o,r)},select:(e,t)=>{const r=Fe(e),n=Fe(t);if(r.signatureV2&&!n.signatureV2)return 0;if(n.signatureV2&&!r.signatureV2)return 1;if(r.sequence>n.sequence)return 0;if(r.sequence<n.sequence)return 1;const s=(0,_e.r)((0,ue.toString)(r.validity));return(0,_e.r)((0,ue.toString)(n.validity)).getTime()>s.getTime()?1:0}},We=Object.assign(a("ipfs:ipns:publisher"),{error:a("ipfs:ipns:publisher:error")}),He=(0,he.notFoundError)().code,Ke=36e5;class Ge{constructor(e,t){this._routing=e,this._datastore=t}async publishWithEOL(e,t,r){if(!e||!e.bytes)throw c(new Error("invalid private key"),"ERR_INVALID_PRIVATE_KEY");const n=await re.createFromPrivKey(e.bytes),s=await this._updateOrCreateRecord(e,t,r,n);return this._putRecordToRouting(s,n)}publish(e,t){return this.publishWithEOL(e,t,Ke)}async _putRecordToRouting(e,t){if(!re.isPeerId(t)){const e="peerId received is not valid";throw We.error(e),c(new Error(e),"ERR_INVALID_PEER_ID")}const r=t.pubKey,n=await(async(e,t)=>{if(!e||!e.bytes||!t){const e=new Error("one or more of the provided parameters are not defined");throw ke.error(e),c(e,Ee.eb)}let r,n;try{r=await re.createFromPubKey(e.bytes)}catch(s){throw c(s,Ee.Qk)}try{n=$e(r)}catch(s){throw ke.error(s),c(s,Ee.kH)}if(n)return null;try{t.pubKey=ge.keys.marshalPublicKey(e)}catch(s){throw ke.error(s),s}return t})(r,e),s=je(t.toBytes());return await this._publishEntry(s.routingKey,n||e),n||e}async _publishEntry(e,t){const r=de.Key.asKey(e);if(!r){const e="datastore key does not have a valid format";throw We.error(e),c(new Error(e),"ERR_INVALID_DATASTORE_KEY")}let n;try{n=Ue(t)}catch(s){throw We.error(s),s}try{const e=await this._routing.put(r.uint8Array(),n);return We(`ipns record for ${(0,ue.toString)(r.uint8Array(),"base32")} was stored in the routing`),e}catch(s){const e=`ipns record for ${(0,ue.toString)(r.uint8Array(),"base32")} could not be stored in the routing - ${s.stack}`;throw We.error(e),We.error(s),c(new Error(e),"ERR_PUTTING_TO_ROUTING")}}async _getPublished(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!re.isPeerId(e)){const e="peerId received is not valid";throw We.error(e),c(new Error(e),"ERR_INVALID_PEER_ID")}const r=!1!==t.checkRouting;try{const t=await this._datastore.get(Be(e.id));return this._unmarshalData(t)}catch(n){if(n.code!==He){const t=`unexpected error getting the ipns record ${e.id} from datastore`;throw We.error(t),c(new Error(t),"ERR_UNEXPECTED_DATASTORE_RESPONSE")}if(!r)throw c(n,"ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED");try{const t=je(e.toBytes()),r=await this._routing.get(t.routingKey.uint8Array());return this._unmarshalData(r)}catch(n){throw We.error(n),n}}}_unmarshalData(e){try{return Fe(e)}catch(t){throw c(t,"ERR_INVALID_RECORD_DATA")}}async _updateOrCreateRecord(e,t,r,n){if(!re.isPeerId(n)){const e="peerId received is not valid";throw We.error(e),c(new Error(e),"ERR_INVALID_PEER_ID")}const s={checkRouting:!0};let o;try{o=await this._getPublished(n,s)}catch(l){if(l.code!==He){const e=`unexpected error when determining the last published IPNS record for ${n.id} ${l.stack}`;throw We.error(e),c(new Error(e),"ERR_DETERMINING_PUBLISHED_RECORD")}}let i,a=0;o&&void 0!==o.sequence&&(a=(0,pe.equals)(o.value,t)?BigInt(o.sequence):BigInt(o.sequence)+BigInt(1));try{i=await((e,t,r,n)=>{const s=new fe(Date.now()+Number(n)),o=be.X.ValidityType.EOL,[i,a]=n.toString().split("."),c=BigInt(i)*BigInt(1e5)+BigInt(a||0);return Re(e,t,r,o,s,c)})(e,t,a,r)}catch(l){const e=`ipns record for ${t} could not be created`;throw We.error(l),c(new Error(e),"ERR_CREATING_IPNS_RECORD")}try{const e=Ue(i);return await this._datastore.put(Be(n.id),e),We(`ipns record for ${(0,ue.toString)(t,"base32")} was stored in the datastore`),i}catch(l){const e=`ipns record for ${t} could not be stored in the datastore`;throw We.error(e),c(new Error(e),"ERR_STORING_IN_DATASTORE")}}}Ge.defaultRecordLifetime=Ke;const qe=Object.assign(a("ipfs:ipns:republisher"),{error:a("ipfs:ipns:republisher:error")});class Ve{constructor(e,t,r,n){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{pass:""};this._publisher=e,this._datastore=t,this._peerId=r,this._keychain=n,this._options=s,this._republishHandle=null}async start(){if(this._republishHandle)throw c(new Error("republisher is already running"),"ERR_REPUBLISH_ALREADY_RUNNING");const e={_task:null,_inflightTask:null,_timeoutId:null,runPeriodically:t=>{e._timeoutId=setTimeout((async()=>{e._timeoutId=null;try{e._inflightTask=e._task(),await e._inflightTask,e._task&&e.runPeriodically(t)}catch(r){qe.error(r)}}),t())},cancel:async()=>{null!=e._timeoutId&&clearTimeout(e._timeoutId),e._task=null,await e._inflightTask}},{privKey:t}=this._peerId,{pass:r}=this._options;let n=!0;e._task=()=>this._republishEntries(t,r),e.runPeriodically((()=>n?(n=!1,this._options.initialBroadcastInterval||6e4):this._options.broadcastInterval||144e5)),this._republishHandle=e}async stop(){const e=this._republishHandle;if(!e)throw c(new Error("republisher is not running"),"ERR_REPUBLISH_NOT_RUNNING");this._republishHandle=null,await e.cancel()}async _republishEntries(e,t){try{await this._republishEntry(e)}catch(r){const e="cannot republish entry for the node's private key";return void qe.error(e)}if(t)try{const e=await this._keychain.listKeys();for(const r of e){if("self"===r.name)continue;const e=await this._keychain.exportKey(r.name,t),n=await ge.keys.import(e,t);await this._republishEntry(n)}}catch(r){qe.error(r)}}async _republishEntry(e){if(!e||!e.bytes)throw c(new Error("invalid private key"),"ERR_INVALID_PRIVATE_KEY");try{const t=await re.createFromPrivKey(e.bytes),r=await this._getPreviousValue(t);await this._publisher.publishWithEOL(e,r,864e5)}catch(t){if("ERR_NO_ENTRY_FOUND"===t.code)return;throw t}}async _getPreviousValue(e){if(!re.isPeerId(e))throw c(new Error("invalid peer ID"),"ERR_INVALID_PEER_ID");try{const r=await this._datastore.get(Be(e.id));if(!(r instanceof Uint8Array))throw c(new Error("found ipns record that we couldn't process"),"ERR_INVALID_IPNS_RECORD");try{return Fe(r).value}catch(t){throw qe.error(t),c(new Error("found ipns record that we couldn't convert to a value"),"ERR_INVALID_IPNS_RECORD")}}catch(t){if(t&&t.notFound)throw c(new Error(`no previous entry for record with id: ${e.id}`),"ERR_NO_ENTRY_FOUND");throw t}}}const Xe=Object.assign(a("ipfs:ipns:resolver"),{error:a("ipfs:ipns:resolver:error")}),Ye=he.notFoundError().code;class Je{constructor(e){this._routing=e}async resolve(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("string"!==typeof e)throw c(new Error("invalid name"),"ERR_INVALID_NAME");const r=t.recursive&&"true"===t.recursive.toString(),n=e.split("/");if(3!==n.length||""!==n[0])throw c(new Error("invalid name"),"ERR_INVALID_NAME");const s=n[2];let o=1/0;r&&(o=32);const i=await this.resolver(s,o);return Xe(`${e} was locally resolved correctly`),i}async resolver(e,t){if(0===t){const e="could not resolve name (recursion limit of 32 exceeded)";throw Xe.error(e),c(new Error(e),"ERR_RESOLVE_RECURSION_LIMIT")}const r=await this._resolveName(e),n=r.split("/");return"ipfs"!==n[1]&&t?this.resolver(n[2],t-1):r}async _resolveName(e){const t=re.parse(e),{routingKey:r}=je(t.toBytes());let n,s;try{n=await this._routing.get(r.uint8Array())}catch(o){if(Xe.error("could not get record from routing",o),o.code===Ye)throw c(new Error(`record requested for ${e} was not found in the network`),"ERR_NO_RECORD_FOUND");throw c(new Error(`unexpected error getting the ipns record ${t.toString()}`),"ERR_UNEXPECTED_ERROR_GETTING_RECORD")}try{s=Fe(n)}catch(o){throw Xe.error("could not unmarshal record",o),c(new Error("found ipns record that we couldn't convert to a value"),"ERR_INVALID_RECORD_RECEIVED")}return this._validateRecord(t,s)}async _validateRecord(e,t){const r=await Ne(e,t);return await Ae(r,t),(0,ue.toString)(t.value)}}var Qe=r(87167);class Ze{constructor(e){this.lru=Qe(e)}get(e){const t=this.lru.get(e);if(t)return t.expire&&t.expire<Date.now()?void this.lru.remove(e):t.value}set(e,t,r){this.lru.set(e,{value:t,expire:Date.now()+r})}has(e){return!!this.get(e)}remove(e){this.lru.remove(e)}clear(){this.lru.clear()}}const et=Object.assign(a("ipfs:ipns"),{error:a("ipfs:ipns:error")});class tt{constructor(e,t,r,n,s){this.publisher=new Ge(e,t),this.republisher=new Ve(this.publisher,t,r,n,s),this.resolver=new Je(e),this.cache=new Ze(1e3),this.routing=e}async publish(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Ge.defaultRecordLifetime;try{const n=await(0,re.createFromPrivKey)(e.bytes);await this.publisher.publishWithEOL(e,t,r),et(`IPNS value ${(0,ue.toString)(t,"base32")} was published correctly`);const s=n.toB58String(),o=parseFloat(r),i=o<6e4?o:6e4;return this.cache.set(s,t,i),et(`IPNS value ${(0,ue.toString)(t,"base32")} was cached correctly`),{name:s,value:t}}catch(n){throw et.error(n),n}}async resolve(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("string"!==typeof e)throw c(new Error("name received is not valid"),"ERR_INVALID_NAME");if(!t.nocache&&!t.recursive){const t=e.split("/")[2],r=this.cache.get(t);if(r)return r}try{const r=await this.resolver.resolve(e,t);return et(`IPNS record from ${e} was resolved correctly`),r}catch(r){throw et.error(r),r}}async initializeKeyspace(e,t){return this.publish(e,t,Ge.defaultRecordLifetime)}}var rt=r(97823),nt=r(21613),st=r(43019),ot=r(22984),it=r(62287);const at="/record/";function ct(e){return(0,ue.toString)(e,"base32")}function lt(e){("string"===typeof e||e instanceof String)&&(e=(0,z.fromString)(e.toString()));return`/record/${(0,ue.toString)(e,"base64url")}`}const dt=Object.assign(a("datastore-pubsub:publisher"),{error:a("datastore-pubsub:publisher:error")});class ht extends it.BaseDatastore{constructor(e,t,r,n,s){if(super(),!n)throw c(new TypeError("missing validator"),"ERR_INVALID_PARAMETERS");if("function"!==typeof n.validate)throw c(new TypeError("missing validate function"),"ERR_INVALID_PARAMETERS");if("function"!==typeof n.select)throw c(new TypeError("missing select function"),"ERR_INVALID_PARAMETERS");if(s&&"function"!==typeof s)throw c(new TypeError("invalid subscriptionKeyFn received"),"ERR_INVALID_PARAMETERS");this._pubsub=e,this._datastore=t,this._peerId=r,this._validator=n,this._handleSubscriptionKeyFn=s,this._onMessage=this._onMessage.bind(this)}async put(e,t){if(!(e instanceof Uint8Array)){const e="datastore key does not have a valid format";throw dt.error(e),c(new Error(e),"ERR_INVALID_DATASTORE_KEY")}if(!(t instanceof Uint8Array)){const e="received value is not a Uint8Array";throw dt.error(e),c(new Error(e),"ERR_INVALID_VALUE_RECEIVED")}const r=lt(e);dt(`publish value for topic ${r}`),await this._pubsub.publish(r,t)}async get(e){if(!(e instanceof Uint8Array)){const e="datastore key does not have a valid format";throw dt.error(e),c(new Error(e),"ERR_INVALID_DATASTORE_KEY")}const t=lt(e),r=await this._pubsub.getTopics();if(r&&Array.isArray(r)&&r.indexOf(t)>-1)return this._getLocal(e);try{this._pubsub.on(t,this._onMessage),await this._pubsub.subscribe(t)}catch(n){const e=`cannot subscribe topic ${t}`;throw dt.error(e),c(new Error(e),"ERR_SUBSCRIBING_TOPIC")}return dt(`subscribed values for key ${t}`),this._getLocal(e)}unsubscribe(e){const t=lt(e);return this._pubsub.removeListener(t,this._onMessage),this._pubsub.unsubscribe(t)}async _getLocal(e){const t=new ot.s("/"+ct(e),!1);let r;try{r=await this._datastore.get(t)}catch(n){if("ERR_NOT_FOUND"!==n.code){const e=`unexpected error getting the ipns record for ${t.toString()}`;throw dt.error(e),c(new Error(e),"ERR_UNEXPECTED_ERROR_GETTING_RECORD")}const e=`local record requested was not found for ${t.toString()}`;throw dt.error(e),c(new Error(e),"ERR_NOT_FOUND")}if(!(r instanceof Uint8Array)){const e="found record that we couldn't convert to a value";throw dt.error(e),c(new Error(e),"ERR_INVALID_RECORD_RECEIVED")}return r}async _onMessage(e){const{data:t,from:r,topicIDs:n}=e;let s;try{s=function(e){if(e.substring(0,at.length)!==at)throw c(new Error("topic received is not from a record"),"ERR_TOPIC_IS_NOT_FROM_RECORD_NAMESPACE");const t=e.substring(at.length);return(0,z.fromString)(t,"base64url")}(n[0])}catch(o){return void dt.error(o)}if(dt(`message received for topic ${n[0]}`),r!==this._peerId.toB58String()){if(this._handleSubscriptionKeyFn){let e;try{e=await this._handleSubscriptionKeyFn(s)}catch(o){return void dt.error("message discarded by the subscriptionKeyFn")}s=e}try{await this._storeIfSubscriptionIsBetter(s,t)}catch(o){dt.error(o)}}else dt("message discarded as it is from the same peer")}async _storeIfSubscriptionIsBetter(e,t){let r=!1;try{r=await this._isBetter(e,t)}catch(n){if("ERR_NOT_VALID_RECORD"!==n.code)throw n}r&&await this._storeRecord(e,t)}async _validateRecord(e,t){return this._validator.validate(e,t)}async _selectRecord(e,t){return 0===await this._validator.select(e,t)}async _isBetter(e,t){try{await this._validateRecord(t,e)}catch(s){const e="record received through pubsub is not valid";throw dt.error(e),c(new Error(e),"ERR_NOT_VALID_RECORD")}const r=new ot.s(e);let n;try{n=await this._getLocal(r.uint8Array())}catch(s){return!0}return!(0,pe.equals)(n,t)&&this._selectRecord(e,[n,t])}async _storeRecord(e,t){const r=new ot.s("/"+ct(e),!1);await this._datastore.put(r,t),dt(`record for ${lt(e)} was stored in the datastore`)}}const ut=Object.assign(a("ipfs:ipns:pubsub"),{error:a("ipfs:ipns:pubsub:error")});class pt{constructor(e,t,r){this._subscriptions={},this._handleSubscriptionKey=this._handleSubscriptionKey.bind(this),this._pubsubDs=new ht(e,t,r,ze,this._handleSubscriptionKey)}async put(e,t){try{await this._pubsubDs.put(e,t)}catch(r){throw ut.error(r),r}}async get(e){let t,r;try{t=await this._pubsubDs.get(e)}catch(s){r=s}const n=e.slice(0,De);if((0,ue.toString)(n)===Pe){const t=st.base58btc.encode(e).substring(1),r=st.base58btc.encode(e.slice(De)).substring(1);this._subscriptions[t]=r,ut(`subscribed to pubsub topic ${t}, id ${r}`)}if(r)throw r;return t}_handleSubscriptionKey(e){e instanceof Uint8Array&&(e=(0,ue.toString)(e,"base58btc"));const t=this._subscriptions[e];if(!t)throw c(new Error(`key ${e} does not correspond to a subscription`),"ERR_INVALID_KEY");let r;try{r=je((0,z.fromString)(t,"base58btc"))}catch(n){throw ut.error(n),n}return r.routingKey.uint8Array()}getSubscriptions(){return Object.values(this._subscriptions).filter(Boolean).map((e=>`/ipns/${e}`))}async cancel(e){if("string"!==typeof e)throw c(new Error("invalid subscription name"),"ERR_INVALID_SUBSCRIPTION_NAME");e.startsWith(Pe)&&(e=e.substring(De));const t=Object.keys(this._subscriptions).find((t=>this._subscriptions[t]===e));if(!t)return{canceled:!1};const r=(0,z.fromString)(t);return this._pubsubDs.unsubscribe(r),delete this._subscriptions[t],ut(`unsubscribed pubsub ${t}: ${e}`),{canceled:!0}}}var ft=r(16758);const gt=Object.assign(a("ipfs:ipns:offline-datastore"),{error:a("ipfs:ipns:offline-datastore:error")});class yt{constructor(e){this._repo=e,this.stores=[]}async put(e,t){if(!(e instanceof Uint8Array))throw c(new Error("Offline datastore key must be a Uint8Array"),"ERR_INVALID_KEY");if(!(t instanceof Uint8Array))throw c(new Error("Offline datastore value must be a Uint8Array"),"ERR_INVALID_VALUE");let r;try{r=this._routingKey(e)}catch(s){throw gt.error(s),c(new Error("Not possible to generate the routing key"),"ERR_GENERATING_ROUTING_KEY")}const n=new ft.Record(e,t);return this._repo.datastore.put(r,n.serialize())}async get(e){if(!(e instanceof Uint8Array))throw c(new Error("Offline datastore key must be a Uint8Array"),"ERR_INVALID_KEY");let t;try{t=this._routingKey(e)}catch(s){throw gt.error(s),c(new Error("Not possible to generate the routing key"),"ERR_GENERATING_ROUTING_KEY")}const r=await this._repo.datastore.get(t);let n;try{n=ft.Record.deserialize(r)}catch(s){throw gt.error(s),s}return n.value}_routingKey(e){return new de.Key("/dht/record/"+(0,ue.toString)(e,"base32"),!1)}}var wt=r(20838);const mt=Object.assign(a("ipfs:ipns:dht-datastore"),{error:a("ipfs:ipns:dht-datastore:error")});class vt{constructor(e){this._dht=e}async put(e,t){try{await wt(this._dht.put(e,t))}catch(r){throw mt.error(r),r}}async get(e){for await(const t of this._dht.get(e))if("VALUE"===t.name)return t.value;throw(0,he.notFoundError)()}}const bt=a("ipfs:components:ipns");class _t{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{pass:""};this.options=e,this.offline=null,this.online=null}getIPNS(){const e=this.online||this.offline;if(e)return e;throw new j}get routing(){return this.getIPNS().routing}startOffline(e){let{repo:t,peerId:r,keychain:n}=e;if(null!=this.offline)throw new L;bt("initializing IPNS keyspace");const s=new yt(t),o=new tt(s,t.datastore,r,n,this.options);this.offline=o}async startOnline(e){let{libp2p:t,repo:r,peerId:n,keychain:s}=e;if(null!=this.online)throw new L;const o=function(e){let{libp2p:t,repo:r,peerId:n,options:s}=e;const o=[];let i;if(nt(s,"EXPERIMENTAL.ipnsPubsub",!1)){const e=t.pubsub,s=r.datastore;i=new pt(e,s,n),o.push(i)}if(!nt(s,"offline",!1)&&t._config&&t._config.dht&&t._config.dht.enabled&&o.push(new vt(t._dht)),nt(s,"offline",!1)||0===o.length){const e=new yt(r);o.push(e)}return new rt.z(o)}({libp2p:t,repo:r,peerId:n,options:this.options}),i=new tt(o,r.datastore,n,s,this.options);await i.republisher.start(),this.online=i}async stop(){const e=this.online;e&&(await e.republisher.stop(),this.online=null)}publish(e,t,r){return this.getIPNS().publish(e,t,r)}resolve(e,t){return this.getIPNS().resolve(e,t)}initializeKeyspace(e,t){return this.getIPNS().initializeKeyspace(e,t)}}var Et=r(73620),kt=r(7901);async function It(e,t,r){let{ipns:n,repo:s,codecs:o}=e;if(te.ipnsPath(t))return n.resolve(t);const{cid:i,path:a}=(0,kt.B)(t);await wt((0,W.DB)(i,a||"",o,s,r))}const St=Object.assign(a("ipfs:name:publish"),{error:a("ipfs:name:publish:error")});var Pt=r(71659),Dt=r(47937);const Rt=o.Z.bind({ignoreUndefined:!0}),Ct=Object.assign(a("ipfs:name:resolve"),{error:a("ipfs:name:resolve:error")}),At=(e,t)=>t.length>0?e+"/"+t.join("/"):e;function Tt(e,t){if(!e||!t||!t.ipnsPubsub)throw c(new Error("IPNS pubsub subsystem is not enabled"),"ERR_IPNS_PUBSUB_NOT_ENABLED");if(e.routing instanceof pt)return e.routing;const r=(e.routing.stores||[]).find((e=>e instanceof pt));if(!r)throw c(new Error("IPNS pubsub datastore not found"),"ERR_PUBSUB_DATASTORE_NOT_FOUND");return r}class Nt{constructor(e){let{ipns:t,options:r}=e;this.cancel=function(e){let{ipns:t,options:r}=e;const n=r.EXPERIMENTAL;return(0,Q.a)((async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Tt(t,n).cancel(e,r)}))}({ipns:t,options:r}),this.state=function(e){let{ipns:t,options:r}=e;const n=r.EXPERIMENTAL;return(0,Q.a)((async function(){try{return{enabled:Boolean(Tt(t,n))}}catch(e){return{enabled:!1}}}))}({ipns:t,options:r}),this.subs=function(e){let{ipns:t,options:r}=e;const n=r.EXPERIMENTAL;return(0,Q.a)((async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return Tt(t,n).getSubscriptions(e)}))}({ipns:t,options:r})}}class Ot{constructor(e){let{dns:t,ipns:r,repo:n,codecs:s,peerId:o,isOnline:i,keychain:a,options:l}=e;this.publish=function(e){let{ipns:t,repo:r,codecs:n,peerId:s,isOnline:o,keychain:i}=e;const a=async e=>{if("self"===e)return s.privKey;try{const t=await i.exportKey(e,"temp");return await ge.keys.import(t,"temp")}catch(t){throw St.error(t),c(t,"ERR_CANNOT_GET_KEY")}};return(0,Q.a)((async function(e){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const i=!(!1===s.resolve),l=s.lifetime||"24h",d=s.key||"self";if(!o())throw c(new Error(W.yH),"OFFLINE_ERROR");try{e=(0,W.AH)(e)}catch(g){throw St.error(g),g}let h=0;try{h=(0,Et.Z)(l)||0,h=parseFloat(h.toFixed(6))}catch(g){throw St.error(g),g}const u=await Promise.all([a(d),i?It({ipns:t,repo:r,codecs:n},e):Promise.resolve()]),p=(0,z.fromString)(e),f=await t.publish(u[0],p,h);return{name:f.name,value:(0,ue.toString)(f.value)}}))}({ipns:r,repo:n,codecs:s,peerId:o,isOnline:i,keychain:a}),this.resolve=function(e){let{dns:t,ipns:r,peerId:n,isOnline:s,options:{offline:o}}=e;return(0,Q.a)((async function*(e){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(i=Rt({nocache:!1,recursive:!0},i),o&&i&&i.nocache)throw c(new Error("cannot specify both offline and nocache"),"ERR_NOCACHE_AND_OFFLINE");if(!s()&&!o)throw c(new Error(W.yH),"OFFLINE_ERROR");e||(e=n.toB58String()),e.startsWith("/ipns/")||(e=`/ipns/${e}`);let[a,l,...d]=e.slice(1).split("/");try{if("1"===l.substring(0,1)){const e=re.parse(l),t=ye.decode(e.toBytes());l=u.CID.createV1(114,t).toString(Pt.base36)}else{const e=u.CID.parse(l);1===e.version&&(l=e.toString(Pt.base36))}}catch(p){if(Dt(l))return void(yield At(await t(l,i),d));throw Ct.error(p),c(new Error("Invalid IPNS name"),"ERR_IPNS_INVALID_NAME")}const h=await r.resolve(`/${a}/${l}`,i);yield At(h instanceof Uint8Array?(0,ue.toString)(h):h,d)}))}({dns:t,ipns:r,peerId:o,isOnline:i,options:l}),this.pubsub=new Nt({ipns:r,options:l})}}var Bt=r(98767),jt=r(98691);const xt=(0,he.notFoundError)().code,Lt="<dst>",Mt="<src> -> <dst>";function $t(e,t,r){const{cid:n,path:s}=(0,kt.B)(t);return!1!==r.preload&&e(n),`/ipfs/${n}${s||""}`}async function*Ut(e,t,r,n,s){const o=await e(n,s),{cid:i}=(0,kt.B)(o),a=null!=s.maxDepth?s.maxDepth:1/0,c=s.unique||!1;for await(const l of async function*(e,t,r,n,s,o){const i=new Set;async function*a(r,c){const l=c+1;if(!(l>n))try{for await(const n of async function*(e,t,r,n){const s=await e.blocks.get(r,n),o=(await t.getCodec(r.code)).decode(s),i=r.code===d.code,a=[];for(const[c,l]of zt(o,a)){if(i){const e=c.match(/^Links\/(\d+)\/Hash$/);if(e){const t=Number(e[1]);if(t<o.Links.length){yield{name:o.Links[t].Name,cid:l};continue}}}yield{name:c,cid:l}}}(e,t,r.cid,o))yield{parent:r,node:n,isDuplicate:s&&i.has(n.cid.toString())},s&&i.add(n.cid.toString()),yield*a(n,l)}catch(h){throw h.code===xt&&(h.message=`Could not find object with CID: ${r.cid}`),h}}yield*a({cid:r},0)}(t,r,i,a,c,s))l.parent&&(l.isDuplicate||(yield{ref:Ft(l.parent.cid,l.node.cid,l.node.name,s.format)}))}function Ft(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"",n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Lt,s=n.replace(/<src>/g,e.toString());return s=s.replace(/<dst>/g,t.toString()),s=s.replace(/<linkname>/g,r),s}const zt=function*(e,t){if(null!=e&&!(e instanceof Uint8Array)){for(const[r,n]of Object.entries(e)){const e=[...t,r];if(null!=n&&"object"===typeof n)if(Array.isArray(n))for(const[t,r]of n.entries()){const n=[...e,t],s=u.CID.asCID(r);s?yield[n.join("/"),s]:"object"===typeof r&&(yield*zt(r,n))}else{const t=u.CID.asCID(n);t?yield[e.join("/"),t]:yield*zt(n,e)}}return[]}};function Wt(e){let{repo:t}=e;return(0,Q.a)((async function*(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};for await(const r of t.blocks.queryKeys({},{signal:e.signal}))yield{ref:r.toString()}}))}function Ht(e){let{network:t}=e;return(0,Q.a)((async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=(await t.use(e)).bitswap,n=r.stat().snapshot;return{provideBufLen:parseInt(n.providesBufferLength.toString()),blocksReceived:BigInt(n.blocksReceived.toString()),wantlist:Array.from(r.getWantlist()).map((e=>e[1].cid)),peers:r.peers().map((e=>e.toB58String())),dupBlksReceived:BigInt(n.dupBlksReceived.toString()),dupDataReceived:BigInt(n.dupDataReceived.toString()),dataReceived:BigInt(n.dataReceived.toString()),blocksSent:BigInt(n.blocksSent.toString()),dataSent:BigInt(n.dataSent.toString())}}))}class Kt{constructor(e){let{network:t}=e;this.wantlist=function(e){let{network:t}=e;return(0,Q.a)((async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{bitswap:r}=await t.use(e),n=r.getWantlist();return Array.from(n).map((e=>e[1].cid))}))}({network:t}),this.wantlistForPeer=function(e){let{network:t}=e;return(0,Q.a)((async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{bitswap:n}=await t.use(r),s=n.wantlistForPeer(re.createFromB58String(e));return Array.from(s).map((e=>e[1].cid))}))}({network:t}),this.unwant=function(e){let{network:t}=e;return(0,Q.a)((async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{bitswap:n}=await t.use(r);return Array.isArray(e)||(e=[e]),n.unwant(e)}))}({network:t}),this.stat=Ht({network:t})}}var Gt=r(44021);function qt(e){try{return Gt.IPFS.matches(e)}catch(t){return!1}}var Vt=r(10006);var Xt=r(10036);class Yt{constructor(e){let{repo:t}=e;this.add=function(e){let{repo:t}=e;return(0,Q.a)((async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!qt(e))throw new Error(`${e} is not a valid Multiaddr`);const n=await t.config.getAll(r),s=n.Bootstrap||[];return s.push(e.toString()),n.Bootstrap=Array.from(new Set(s)).sort(((e,t)=>e.localeCompare(t))),await t.config.replace(n),{Peers:[e]}}))}({repo:t}),this.list=function(e){let{repo:t}=e;return(0,Q.a)((async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return{Peers:(await t.config.get("Bootstrap",e)||[]).map((e=>new Vt.Multiaddr(e)))}}))}({repo:t}),this.rm=function(e){let{repo:t}=e;return(0,Q.a)((async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!qt(e))throw new Error(`${e} is not a valid Multiaddr`);const n=await t.config.getAll(r);return n.Bootstrap=(n.Bootstrap||[]).filter((t=>t.toString()!==e.toString())),await t.config.replace(n),{Peers:[e]}}))}({repo:t}),this.clear=function(e){let{repo:t}=e;return(0,Q.a)((async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await t.config.getAll(e),n=r.Bootstrap||[];return r.Bootstrap=[],await t.config.replace(r),{Peers:n.map((e=>new Vt.Multiaddr(e)))}}))}({repo:t}),this.reset=function(e){let{repo:t}=e;return(0,Q.a)((async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await t.config.getAll(e);return r.Bootstrap=(0,Xt.Z)().Bootstrap,await t.config.replace(r),{Peers:(0,Xt.Z)().Bootstrap.map((e=>new Vt.Multiaddr(e)))}}))}({repo:t})}}var Jt=r(1833),Qt=r(60191),Zt=r(93663),er=r(89962);function tr(e){return e instanceof Uint8Array?u.CID.decode(e):u.CID.parse(e.toString())}class rr{constructor(e){let{codecs:t,hashers:r,preload:n,repo:s}=e;this.get=function(e){let{preload:t,repo:r}=e;return(0,Q.a)((async function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return!1!==n.preload&&t(e),r.blocks.get(e,n)}))}({preload:n,repo:s}),this.put=function(e){let{codecs:t,hashers:r,repo:n,preload:s}=e;return(0,Q.a)((async function(e){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const i=o.pin?await n.gcLock.readLock():null;try{const a=null!=o.version?o.version:0,c=o.format||(0===a?"dag-pb":"raw"),l=await r.getHasher(o.mhtype||"sha2-256"),d=await l.digest(e),h=await t.getCodec(c),p=u.CID.create(a,h.code,d);return await n.blocks.put(p,e,{signal:o.signal}),!1!==o.preload&&s(p),!0===o.pin&&await n.pins.pinRecursively(p,{signal:o.signal}),p}finally{i&&i()}}))}({codecs:t,hashers:r,preload:n,repo:s}),this.rm=function(e){let{repo:t}=e;return(0,Q.a)((async function*(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};Array.isArray(e)||(e=[e]);const n=await t.gcLock.writeLock();try{yield*(0,er.pipe)(e,(e=>Qt(e,(e=>async()=>{const n={cid:e=tr(e)};try{if(!await t.blocks.has(e))throw c(new Error("block not found"),"ERR_BLOCK_NOT_FOUND");await t.blocks.delete(e)}catch(s){r.force||(s.message=`cannot remove ${e}: ${s.message}`,n.error=s)}return n}))),(e=>Jt(e,{concurrency:8})),(e=>Zt(e,(()=>!r.quiet))))}finally{n()}}))}({repo:s}),this.stat=function(e){let{repo:t,preload:r}=e;return(0,Q.a)((async function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};e=tr(e),!1!==n.preload&&r(e);return{cid:e,size:(await t.blocks.get(e)).length}}))}({preload:n,repo:s})}}var nr=r(55194),sr=r(31156),or=r(62469),ir=r(21958),ar=r(47664);async function*cr(e){yield e}async function lr(e){if((0,ar._t)(e))return cr(dr(e));if("string"===typeof e||e instanceof String)return cr(dr(e.toString()));if((0,ar.Lj)(e))return sr(e);if((0,ar.Os)(e)&&(e=nr(e)),Symbol.iterator in e||Symbol.asyncIterator in e){const t=or(e),{value:r,done:n}=await t.peek();if(n)return cr(new Uint8Array(0));if(t.push(r),Number.isInteger(r))return cr(Uint8Array.from(await ir(t)));if((0,ar._t)(r)||"string"===typeof r||r instanceof String)return Qt(t,dr)}throw c(new Error(`Unexpected input: ${e}`),"ERR_UNEXPECTED_INPUT")}function dr(e){return e instanceof Uint8Array?e:ArrayBuffer.isView(e)?new Uint8Array(e.buffer,e.byteOffset,e.byteLength):e instanceof ArrayBuffer?new Uint8Array(e):Array.isArray(e)?Uint8Array.from(e):(0,z.fromString)(e.toString())}async function hr(e,t){const{path:r,mode:n,mtime:s,content:o}=e,i={path:r||"",mode:(0,l.tK)(n),mtime:(0,l.Xu)(s)};return o?i.content=await t(o):r||(i.content=await t(e)),i}function ur(e){return async function*(e,t){if(null===e||void 0===e)throw c(new Error(`Unexpected input: ${e}`),"ERR_UNEXPECTED_INPUT");if("string"===typeof e||e instanceof String)yield hr(e.toString(),t);else if((0,ar._t)(e)||(0,ar.Lj)(e))yield hr(e,t);else{if((0,ar.Os)(e)&&(e=nr(e)),Symbol.iterator in e||Symbol.asyncIterator in e){const r=or(e),{value:n,done:s}=await r.peek();if(s)return void(yield{content:[]});if(r.push(n),Number.isInteger(n)||(0,ar._t)(n)||"string"===typeof n||n instanceof String)return void(yield hr(r,t));throw c(new Error("Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead"),"ERR_UNEXPECTED_INPUT")}if(!(0,ar.Mk)(e))throw c(new Error('Unexpected input: cannot convert "'+typeof e+'" into ImportCandidate'),"ERR_UNEXPECTED_INPUT");yield hr(e,t)}}(e,lr)}var pr=r(46224),fr=r(40389);function gr(e){return(0,fr.n)(e,lr)}var yr=r(67835);const wr=o.Z.bind({ignoreUndefined:!0});function mr(e){return async function*(t){for await(const r of t){let t=r.cid;1===e.cidVersion&&(t=t.toV1());let n=r.path?r.path:t.toString();e.wrapWithDirectory&&!r.path&&(n=""),yield{path:n,cid:t,size:r.size,mode:r.unixfs&&r.unixfs.mode,mtime:r.unixfs&&r.unixfs.mtime}}}}function vr(e,t){return async function*(r){for await(const n of r){(!n.path||t.wrapWithDirectory?""===n.path:!n.path.includes("/"))&&!t.onlyHash&&!1!==t.preload&&e(n.cid),yield n}}}function br(e,t){return async function*(r){for await(const n of r){const r=!(n.path&&n.path.includes("/"));(null==t.pin||t.pin)&&r&&!t.onlyHash&&await e.pins.pinRecursively(n.cid),yield n}}}var _r=r(48206);var Er=r(53659),kr=r(4813),Ir=r(42407);class Sr{constructor(e){let{preload:t,repo:r,hashers:n,options:s}=e;const o=function(e){let{repo:t,preload:r,hashers:n,options:s}=e;const o=s&&s.sharding;return(0,Q.a)((async function*(e){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const i=wr({shardSplitThreshold:o?1e3:1/0,strategy:"balanced"},s,{...(0,yr.Aq)(s.chunker)});i.hashAlg&&"sha2-256"!==i.hashAlg&&1!==i.cidVersion&&(i.cidVersion=1),i.trickle&&(i.strategy="trickle"),"trickle"===i.strategy&&(i.leafType="raw",i.reduceSingleLeafToSelf=!1),i.cidVersion>0&&void 0===i.rawLeaves&&(i.rawLeaves=!0),void 0!==i.hashAlg&&void 0===i.rawLeaves&&(i.rawLeaves=!0),delete i.trickle;const a={};if(i.progress){const e=i.progress;i.progress=(t,r)=>{a[r]||(a[r]=0),a[r]+=t,e(a[r],r)}}let c;null!=i.hashAlg&&(c=await n.getHasher(i.hashAlg));const l=(0,er.pipe)(gr(e),(e=>(0,pr.Z)(e,t.blocks,{...i,hasher:c,pin:!1})),mr(i),vr(r,i),br(t,i)),d=await t.gcLock.readLock();try{for await(const e of l)delete a[e.path],yield e}finally{d()}}))}({preload:t,repo:r,options:s,hashers:n});this.addAll=o,this.add=function(e){let{addAll:t}=e;return async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await se(t(ur(e),r));if(null==n)throw Error("Failed to add a file, if you see this please report a bug");return n}}({addAll:o}),this.cat=function(e){let{repo:t,preload:r}=e;return(0,Q.a)((async function*(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(e=(0,W.JU)(e),!1!==n.preload){const t=e.split("/");r(u.CID.parse(t[0]))}const s=await(0,_r.OY)(e,t.blocks,n);if("directory"===s.type)throw new Error("this dag node is a directory");if(!s.content)throw new Error("this dag node has no content");yield*s.content(n)}))}({repo:r,preload:t}),this.get=function(e){let{repo:t,preload:r}=e;return(0,Q.a)((async function*(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(null!=n.compressionLevel&&(n.compressionLevel<-1||n.compressionLevel>9))throw c(new Error("Compression level must be between -1 and 9"),"ERR_INVALID_PARAMS");if(!1!==n.preload){let t;try{t=(0,W.JU)(e).split("/")}catch(i){throw c(i,"ERR_INVALID_PATH")}r(u.CID.parse(t[0]))}const s=u.CID.asCID(e)||e,o=await(0,_r.OY)(s,t.blocks,n);if("file"===o.type||"raw"===o.type){const e=[];return n.compress&&!0!==n.archive?e.push(o.content):e.push([{header:{name:o.path,mode:"file"===o.type&&o.unixfs.mode,mtime:"file"===o.type&&o.unixfs.mtime?new Date(1e3*o.unixfs.mtime.secs):void 0,size:o.size,type:"file"},body:o.content()}],(0,Er.pack)(),(e=>Qt(e,(e=>e.slice())))),n.compress&&e.push((async function*(e){const t=await Ir(e);yield kr.gzip(t,{level:n.compressionLevel||6})})),void(yield*(0,er.pipe)(...e))}if("directory"!==o.type)throw c(new Error("Not a UnixFS node"),"ERR_NOT_UNIXFS");{const e=[(0,_r.BE)(s,t.blocks,n),async function*(e){for await(const t of e){const e={header:{name:t.path,size:t.size}};if("file"===t.type)e.header.type="file",e.header.mode=null!=t.unixfs.mode?t.unixfs.mode:void 0,e.header.mtime=t.unixfs.mtime?new Date(1e3*t.unixfs.mtime.secs):void 0,e.body=t.content();else if("raw"===t.type)e.header.type="file",e.body=t.content();else{if("directory"!==t.type)throw c(new Error("Not a UnixFS node"),"ERR_NOT_UNIXFS");e.header.type="directory",e.header.mode=null!=t.unixfs.mode?t.unixfs.mode:void 0,e.header.mtime=t.unixfs.mtime?new Date(1e3*t.unixfs.mtime.secs):void 0}yield e}},(0,Er.pack)(),e=>Qt(e,(e=>e.slice()))];if(n.compress){if(!n.archive)throw c(new Error("file is not regular"),"ERR_INVALID_PATH");n.compress&&e.push((async function*(e){const t=await Ir(e);yield kr.gzip(t,{level:n.compressionLevel||6})}))}yield*(0,er.pipe)(...e)}}))}({repo:r,preload:t}),this.ls=function(e){let{repo:t,preload:r}=e;return(0,Q.a)((async function*(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const s=(0,W.JU)(e),o=s.split("/");!1!==n.preload&&r(u.CID.parse(o[0]));const i=u.CID.asCID(s)||s,a=await(0,_r.OY)(i,t.blocks,n);if("file"!==a.type){if("directory"!==a.type)throw c(new Error(`Unknown UnixFS type ${a.type}`),"ERR_UNKNOWN_UNIXFS_TYPE");for await(const e of a.content())yield(0,W.jr)(e)}else yield(0,W.jr)(a)}))}({repo:r,preload:t})}}var Pr=r(22123);const Dr=Object.assign(a("ipfs:components:id"),{error:a("ipfs:components:id:error")});async function Rr(e,t,r){let n=await t.peerStore.get(e);n||(n=await async function(e,t,r){for await(const s of t._dht.findPeer(e,r))if("FINAL_PEER"===s.name)break;const n=await t.peerStore.get(e);if(!n)throw c(new Error("Could not find peer"),"ERR_NOT_FOUND");return n}(e,t,r));let s=e.pubKey?e.pubKey:await t.peerStore.keyBook.get(e);if(!s)try{s=await t._dht.getPublicKey(e,r)}catch(o){Dr.error("Could not load public key for",e.toB58String(),o)}return{...n,publicKey:s,metadata:n.metadata||new Map,addresses:n.addresses.map((e=>e.multiaddr))}}var Cr=r(69201);const Ar={server:{description:"Recommended for nodes with public IPv4 address (servers, VPSes, etc.), disables host and content discovery and UPnP in local networks.",transform:e=>(Cr(e,"Discovery.MDNS.Enabled",!1),Cr(e,"Discovery.webRTCStar.Enabled",!1),e.Swarm={...e.Swarm||{},DisableNatPortMap:!0},e)},"local-discovery":{description:"Sets default values to fields affected by `server` profile, enables discovery and UPnP in local networks.",transform:e=>(Cr(e,"Discovery.MDNS.Enabled",!0),Cr(e,"Discovery.webRTCStar.Enabled",!0),Cr(e,"Swarm",{...e.Swarm||{},DisableNatPortMap:!1}),e)},test:{description:"Reduces external interference, useful for running ipfs in test environments. Note that with these settings node won't be able to talk to the rest of the network without manual bootstrap.",transform:e=>{const t=(0,Xt.Z)();return Cr(e,"Addresses.API",t.Addresses.API?"/ip4/127.0.0.1/tcp/0":""),Cr(e,"Addresses.Gateway",t.Addresses.Gateway?"/ip4/127.0.0.1/tcp/0":""),Cr(e,"Addresses.Swarm",t.Addresses.Swarm.length?["/ip4/127.0.0.1/tcp/0"]:[]),Cr(e,"Addresses.Delegates",[]),Cr(e,"Bootstrap",[]),Cr(e,"Discovery.MDNS.Enabled",!1),Cr(e,"Discovery.webRTCStar.Enabled",!1),Cr(e,"Swarm",{...e.Swarm||{},DisableNatPortMap:!0}),e}},"default-networking":{description:"Restores default network settings. Inverse profile of the `test` profile.",transform:e=>{const t=(0,Xt.Z)();return Cr(e,"Addresses.API",t.Addresses.API),Cr(e,"Addresses.Gateway",t.Addresses.Gateway),Cr(e,"Addresses.Swarm",t.Addresses.Swarm),Cr(e,"Addresses.Delegates",t.Addresses.Delegates),Cr(e,"Bootstrap",t.Bootstrap),Cr(e,"Discovery.MDNS.Enabled",t.Discovery.MDNS.Enabled),Cr(e,"Discovery.webRTCStar.Enabled",t.Discovery.webRTCStar.Enabled),Cr(e,"Swarm",{...e.Swarm||{},DisableNatPortMap:!1}),e}},lowpower:{description:"Reduces daemon overhead on the system. May affect node functionality,performance of content discovery and data fetching may be degraded. Recommended for low power systems.",transform:e=>{const t=e.Swarm||{},r=t.ConnMgr||{};return r.LowWater=20,r.HighWater=40,t.ConnMgr=r,e.Swarm=t,e}},"default-power":{description:'Inverse of "lowpower" profile.',transform:e=>{const t=(0,Xt.Z)();return e.Swarm=t.Swarm,e}}},Tr=a("ipfs:core:config");async function Nr(e){return Object.keys(Ar).map((e=>({name:e,description:Ar[e].description})))}const Or=function(){let{enumerable:e=!0,configurable:t=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return{enumerable:e,configurable:t,writable:!1}},Br=function*(e,t){if(null!=e&&!(e instanceof Uint8Array))for(const[r,n]of Object.entries(e)){const e=[...t,r];if(null!=n&&"object"===typeof n)if(Array.isArray(n))for(const[t,r]of n.entries()){const n=[...e,t],s=v.k0.asCID(r);s?yield[n.join("/"),s]:"object"===typeof r&&(yield*Br(r,n))}else{const t=v.k0.asCID(n);t?yield[e.join("/"),t]:yield*Br(n,e)}}},jr=function*(e,t){if(null!=e)for(const[r,n]of Object.entries(e)){const e=[...t,r];if(yield e.join("/"),null!=n&&!(n instanceof Uint8Array)&&"object"===typeof n&&!v.k0.asCID(n))if(Array.isArray(n))for(const[t,r]of n.entries()){const n=[...e,t];yield n.join("/"),"object"!==typeof r||v.k0.asCID(r)||(yield*jr(r,n))}else yield*jr(n,e)}};class xr{constructor(e){let{cid:t,bytes:r,value:n}=e;if(!t||!r||"undefined"===typeof n)throw new Error("Missing required argument");this.cid=t,this.bytes=r,this.value=n,this.asBlock=this,Object.defineProperties(this,{cid:Or(),bytes:Or(),value:Or(),asBlock:Or()})}links(){return Br(this.value,[])}tree(){return jr(this.value,[])}get(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"/";return((e,t)=>{let r=e;for(const[n,s]of t.entries()){if(r=r[s],null==r)throw new Error(`Object has no property at ${t.slice(0,n+1).map((e=>`[${JSON.stringify(e)}]`)).join("")}`);const e=v.k0.asCID(r);if(e)return{value:e,remaining:t.slice(n+1).join("/")}}return{value:r}})(this.value,e.split("/").filter(Boolean))}}const Lr=e=>{let{bytes:t,cid:r,value:n,codec:s}=e;const o=void 0!==n?n:s&&s.decode(t);if(void 0===o)throw new Error('Missing required argument, must either provide "value" or "codec"');return new xr({cid:r,bytes:t,value:o})};var Mr=r(75617);function $r(e){const t=w({version:1,roots:e}),r=Mr.encode(t.length),n=new Uint8Array(r.length+t.length);return n.set(r,0),n.set(t,r.length),n}var Ur=r(54595);const Fr=18,zr=32,Wr=112;async function Hr(e){const t=await e.upTo(8),r=Mr.decode(t);return e.seek(Mr.decode.bytes),r}async function Kr(e){const t=await Hr(e);if(0===t)throw new Error("Invalid CAR header (zero length)");const r=await e.exactly(t);e.seek(t);const n=m(r);if(null==n||Array.isArray(n)||"object"!==typeof n)throw new Error("Invalid CAR header format");if(1!==n.version){if("string"===typeof n.version)throw new Error(`Invalid CAR version: "${n.version}"`);throw new Error(`Invalid CAR version: ${n.version}`)}if(!Array.isArray(n.roots))throw new Error("Invalid CAR header format");if(Object.keys(n).filter((e=>"roots"!==e&&"version"!==e)).length)throw new Error("Invalid CAR header format");return n}async function Gr(e){const t=await e.exactly(2);if(t[0]===Fr&&t[1]===zr){const t=await e.exactly(34);e.seek(34);const r=ye.decode(t);return u.CID.create(0,Wr,r)}const r=await Hr(e);if(1!==r)throw new Error(`Unexpected CID version (${r})`);const n=await Hr(e),s=await async function(e){const t=await e.upTo(8);Mr.decode(t);const r=Mr.decode.bytes,n=Mr.decode(t.subarray(Mr.decode.bytes)),s=r+Mr.decode.bytes+n,o=await e.exactly(s);return e.seek(s),o}(e),o=ye.decode(s);return u.CID.create(r,n,o)}async function qr(e){const t=e.pos;let r=await Hr(e);if(0===r)throw new Error("Invalid CAR section (zero length)");r+=e.pos-t;return{cid:await Gr(e),length:r,blockLength:r-(e.pos-t)}}async function Vr(e){const{cid:t,blockLength:r}=await qr(e),n=await e.exactly(r);return e.seek(r),{bytes:n,cid:t}}async function Xr(e){const t=e.pos,{cid:r,length:n,blockLength:s}=await qr(e),o={cid:r,length:n,blockLength:s,offset:t,blockOffset:e.pos};return e.seek(o.blockLength),o}function Yr(e){let t=0;return{upTo:async r=>e.subarray(t,t+Math.min(r,e.length-t)),async exactly(r){if(r>e.length-t)throw new Error("Unexpected end of data");return e.subarray(t,t+r)},seek(e){t+=e},get pos(){return t}}}function Jr(e){const t=e[Symbol.asyncIterator]();return function(e){let t=0,r=0,n=0,s=new Uint8Array(0);const o=async t=>{r=s.length-n;const o=[s.subarray(n)];for(;r<t;){const t=await e();if(null==t)break;r<0?t.length>r&&o.push(t.subarray(-r)):o.push(t),r+=t.length}s=new Uint8Array(o.reduce(((e,t)=>e+t.length),0));let i=0;for(const e of o)s.set(e,i),i+=e.length;n=0};return{upTo:async e=>(s.length-n<e&&await o(e),s.subarray(n,n+Math.min(s.length-n,e))),async exactly(e){if(s.length-n<e&&await o(e),s.length-n<e)throw new Error("Unexpected end of data");return s.subarray(n,n+e)},seek(e){t+=e,n+=e},get pos(){return t}}}((async function(){const e=await t.next();return e.done?null:e.value}))}class Qr{constructor(e,t){this._encoder=t,this._mutex=t.setRoots(e),this._ended=!1}async put(e){if(!(e.bytes instanceof Uint8Array)||!e.cid)throw new TypeError("Can only write {cid, bytes} objects");if(this._ended)throw new Error("Already closed");const t=u.CID.asCID(e.cid);if(!t)throw new TypeError("Can only write {cid, bytes} objects");return this._mutex=this._mutex.then((()=>this._encoder.writeBlock({cid:t,bytes:e.bytes}))),this._mutex}async close(){if(this._ended)throw new Error("Already closed");return await this._mutex,this._ended=!0,this._encoder.close()}static create(e){e=function(e){if(void 0===e)return[];if(!Array.isArray(e)){const t=u.CID.asCID(e);if(!t)throw new TypeError("roots must be a single CID or an array of CIDs");return[t]}const t=[];for(const r of e){const e=u.CID.asCID(r);if(!e)throw new TypeError("roots must be a single CID or an array of CIDs");t.push(e)}return t}(e);const{encoder:t,iterator:r}=en();return{writer:new Qr(e,t),out:new Zr(r)}}static createAppender(){const{encoder:e,iterator:t}=en();e.setRoots=()=>Promise.resolve();return{writer:new Qr([],e),out:new Zr(t)}}static async updateRootsInBytes(e,t){const r=Yr(e);await Kr(r);const n=$r(t);if(r.pos!==n.length)throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${r.pos} bytes, new header is ${n.length} bytes)`);return e.set(n,0),e}}class Zr{constructor(e){this._iterator=e}[Symbol.asyncIterator](){if(this._iterating)throw new Error("Multiple iterator not supported");return this._iterating=!0,this._iterator}}function en(){const e=(0,Ur.U)(),{writer:t,iterator:r}=e,n=function(e){return{async setRoots(t){const r=$r(t);await e.write(r)},async writeBlock(t){const{cid:r,bytes:n}=t;await e.write(new Uint8Array(Mr.encode(r.bytes.length+n.length))),await e.write(r.bytes),n.length&&await e.write(n)},close:async()=>e.end()}}(t);return{encoder:n,iterator:r}}var tn=r(96602),rn=r(39928);const nn=async e=>{let{cid:t,load:r,seen:n}=e;n=n||new Set;const s=t.toString(st.base58btc);if(n.has(s))return;const o=await r(t);if(n.add(s),null!==o)for(const[,i]of o.links())await nn({cid:i,load:r,seen:n})},sn=a("ipfs:components:dag:import"),on=[tn.code,rn.code];function an(e,t,r,n){return async s=>{const o=await n.getCodec(s.code);if(!o)throw new Error(`Can't decode links in block with codec 0x${s.code.toString(16)} to form complete DAG`);const i=await e.blocks.get(s,r);return sn(`Adding block ${s} to car`),await t.put({cid:s,bytes:i}),on.includes(s.code)?null:Lr({bytes:i,cid:s,codec:o})}}var cn=r(45454);class ln{constructor(e,t,r){this._version=e,this._roots=t,this._iterable=r,this._decoded=!1}get version(){return this._version}async getRoots(){return this._roots}}class dn extends ln{[Symbol.asyncIterator](){if(this._decoded)throw new Error("Cannot decode more than once");if(!this._iterable)throw new Error("Block iterable not found");return this._decoded=!0,this._iterable[Symbol.asyncIterator]()}static async fromBytes(e){const{version:t,roots:r,iterator:n}=await hn(e);return new dn(t,r,n)}static async fromIterable(e){const{version:t,roots:r,iterator:n}=await un(e);return new dn(t,r,n)}}Symbol.asyncIterator;async function hn(e){if(!(e instanceof Uint8Array))throw new TypeError("fromBytes() requires a Uint8Array");return pn(Yr(e))}async function un(e){if(!e||"function"!==typeof e[Symbol.asyncIterator])throw new TypeError("fromIterable() requires an async iterable");return pn(Jr(e))}async function pn(e){const t=function(e){const t=Kr(e);return{header:()=>t,async*blocks(){for(await t;(await e.upTo(8)).length>0;)yield await Vr(e)},async*blocksIndex(){for(await t;(await e.upTo(8)).length>0;)yield await Xr(e)}}}(e),{version:r,roots:n}=await t.header();return{version:r,roots:n,iterator:t.blocks()}}const fn=a("ipfs:components:dag:import");async function gn(e,t,r){const n=await dn.fromIterable(r),s=await n.getRoots();return await wt(e.blocks.putMany(Qt(n,(e=>{let{cid:t,bytes:r}=e;return fn(`Import block ${t}`),{key:t,value:r}})),{signal:t.signal})),s}class yn{constructor(e){let{repo:t,codecs:r,hashers:n,preload:s}=e;this.export=function(e){let{repo:t,preload:r,codecs:n}=e;return(0,Q.a)((async function*(e){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};!1!==s.preload&&r(e);const o=u.CID.asCID(e);if(!o)throw new Error(`Unexpected error converting CID type: ${e}`);sn(`Exporting ${o} as car`);const{writer:i,out:a}=await Qr.create([o]);let c=null;(async()=>{try{const e=an(t,i,{signal:s.signal,timeout:s.timeout},n);await nn({cid:o,load:e})}catch(e){c=e}finally{i.close()}})();for await(const t of a){if(c)break;yield t}if(c)throw c}))}({repo:t,preload:s,codecs:r}),this.get=function(e){let{codecs:t,repo:r,preload:n}=e;return(0,Q.a)((async function(e){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!1!==s.preload&&n(e),s.path){const n=s.localResolve?await cn((0,W.DB)(e,s.path,t,r,s)):await se((0,W.DB)(e,s.path,t,r,s));if(!n)throw c(new Error("Not found"),"ERR_NOT_FOUND");return n}const o=await t.getCodec(e.code),i=await r.blocks.get(e,s);return{value:o.decode(i),remainderPath:""}}))}({codecs:r,repo:t,preload:s}),this.import=function(e){let{repo:t}=e;return(0,Q.a)((async function*(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await t.gcLock.readLock();try{const o={signal:r.signal,timeout:r.timeout},i=or(e),{value:a,done:c}=await i.peek();if(c)return;let l;a&&i.push(a),l=a instanceof Uint8Array?[i]:i;for await(const e of l){const n=await gn(t,o,e);if(!1!==r.pinRoots)for(const e of n){let r="";try{await t.blocks.has(e)?(fn(`Pinning root ${e}`),await t.pins.pinRecursively(e)):r="blockstore: block not found"}catch(s){r=s.message}yield{root:{cid:e,pinErrorMsg:r}}}}}finally{n()}}))}({repo:t}),this.resolve=function(e){let{repo:t,codecs:r,preload:n}=e;return(0,Q.a)((async function(e){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{cid:o}=(0,kt.B)(e);return!1!==s.preload&&n(o),(0,W.i3)(t,r,e,s)}))}({repo:t,codecs:r,preload:s}),this.put=function(e){let{repo:t,codecs:r,hashers:n,preload:s}=e;return(0,Q.a)((async function(e){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const i=o.pin?await t.gcLock.readLock():null;try{const a=await r.getCodec(o.storeCodec||"dag-cbor");if(!a)throw new Error(`Unknown storeCodec ${o.storeCodec}, please configure additional BlockCodecs for this IPFS instance`);if(o.inputCodec){if(!(e instanceof Uint8Array))throw new Error("Can only inputCodec on raw bytes that can be decoded");const t=await r.getCodec(o.inputCodec);if(!t)throw new Error(`Unknown inputCodec ${o.inputCodec}, please configure additional BlockCodecs for this IPFS instance`);e=t.decode(e)}const c=null!=o.version?o.version:1,l=await n.getHasher(o.hashAlg||"sha2-256");if(!l)throw new Error(`Unknown hash algorithm ${o.hashAlg}, please configure additional MultihashHashers for this IPFS instance`);const d=a.encode(e),h=await l.digest(d),p=u.CID.create(c,a.code,h);return await t.blocks.put(p,d,{signal:o.signal}),o.pin&&await t.pins.pinRecursively(p),!1!==o.preload&&s(p),p}finally{i&&i()}}))}({repo:t,codecs:r,hashers:n,preload:s})}}var wn=r(36381),mn=r(76297);const vn=Object.assign(a("ipfs:preload"),{error:a("ipfs:preload:error")}),bn=new(G.default?G.default:G)({concurrency:4});function _n(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return vn(e),bn.add((async()=>{const r=(await q.post(e,{signal:t.signal})).body.getReader();try{for(;;){const{done:e}=await r.read();if(e)return}}finally{r.releaseLock()}}))}const En=Object.assign(a("ipfs:preload"),{error:a("ipfs:preload:error")});function kn(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(e.enabled=Boolean(e.enabled),e.addresses=e.addresses||[],e.cache=e.cache||1e3,!e.enabled||!e.addresses.length){En("preload disabled");const e=()=>{};return Object.assign(e,{start:()=>{},stop:()=>{}})}let t=!0,r=[];const n=e.addresses.map(wn),s=Qe(e.cache),o=async e=>{try{if(t)throw new Error(`preload ${e} but preloader is not started`);const i=e.toString();if(s.has(i))return;s.set(i,!0);const a=mn(n);let c=!1;const l=Date.now();for(const e of a){if(t)throw new Error(`preload aborted for ${i}`);let n;try{n=new AbortController,r=r.concat(n),await _n(`${e}/api/v0/refs?r=true&arg=${encodeURIComponent(i)}`,{signal:n.signal}),c=!0}catch(o){"aborted"!==o.type&&En.error(o)}finally{r=r.filter((e=>e!==n))}if(c)break}En(`${c?"":"un"}successfully preloaded ${i} in ${Date.now()-l}ms`)}catch(o){En.error(o)}};return o.start=()=>{t=!1},o.stop=()=>{t=!0,En(`aborting ${r.length} pending preload request(s)`),r.forEach((e=>e.abort())),r=[]},o}const In=Object.assign(a("ipfs:mfs-preload"),{error:a("ipfs:mfs-preload:error")});var Sn=r(70962),Pn=r(91025),Dn=r(62442),Rn=r(12944),Cn=r(2723),An=r(65887),Tn=r(39849),Nn=r(74009),On=r(87956),Bn=r(56792),jn=r(17300),xn=r(48396);const Ln={stat:Pn.y},Mn={chmod:Dn.b,cp:Rn.h,flush:Cn.k,mkdir:An.T,mv:Tn.f,rm:Nn.Q,touch:On.T},$n={write:jn.g,read:Bn.k,ls:xn.c},Un=e=>{let{options:t,mfs:r,operations:n,lock:s}=e;Object.keys(n).forEach((e=>{r[e]=s(n[e](t))}))},Fn={repoOwner:!0,repo:null};function zn(e){let{repo:t,preload:r,hashers:n,options:s}=e;const o=function(e){const{repoOwner:t}=Object.assign({},Fn||{},e),r=(0,Sn.Y)(t),n={};return Un({options:e,mfs:n,operations:Ln,lock:e=>r.readLock(e)}),Un({options:e,mfs:n,operations:Mn,lock:e=>r.writeLock(e)}),Object.keys($n).forEach((t=>{n[t]=$n[t](e)})),n}({repo:t,repoOwner:Boolean(s.repoOwner),hashers:n}),i=e=>function(){for(var t=arguments.length,n=new Array(t),s=0;s<t;s++)n[s]=arguments[s];const o=n.filter((e=>te.ipfsPath(e)||te.cid(e)));if(o.length){const e=n[n.length-1];e&&!1!==e.preload&&o.forEach((e=>r(e)))}return e(...n)};return{...o,chmod:o.chmod,cp:i(o.cp),mkdir:o.mkdir,stat:i(o.stat),rm:o.rm,read:i(o.read),touch:o.touch,write:o.write,mv:i(o.mv),flush:o.flush,ls:i((async function*(){for await(const e of o.ls(...arguments))yield{...e,size:e.size||0}}))}}const Wn="ed25519",Hn=2048;class Kn{constructor(e){let{keychain:t}=e;this.gen=function(e){let{keychain:t}=e;return(0,Q.a)((function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{type:Wn,size:Hn};return t.createKey(e,r.type||Wn,r.size||Hn)}))}({keychain:t}),this.list=function(e){let{keychain:t}=e;return(0,Q.a)((()=>t.listKeys()))}({keychain:t}),this.rm=function(e){let{keychain:t}=e;return(0,Q.a)((e=>t.removeKey(e)))}({keychain:t}),this.rename=function(e){let{keychain:t}=e;return(0,Q.a)((async(e,r)=>{const n=await t.renameKey(e,r);return{was:e,now:n.name,id:n.id,overwrite:!1}}))}({keychain:t}),this.export=function(e){let{keychain:t}=e;return(0,Q.a)(((e,r)=>t.exportKey(e,r)))}({keychain:t}),this.import=function(e){let{keychain:t}=e;return(0,Q.a)(((e,r,n)=>t.importKey(e,r,n)))}({keychain:t}),this.info=function(e){let{keychain:t}=e;return(0,Q.a)((e=>t.findKeyByName(e)))}({keychain:t})}}function Gn(e){let{repo:t,preload:r}=e;return(0,Q.a)((async function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};!1!==n.preload&&r(e);const s=await t.blocks.get(e,n);return d.decode(s)}))}function qn(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];for(const n in e){const s=e[n];if("/"===n&&1===Object.keys(e).length)try{t.push({Name:"",Tsize:0,Hash:u.CID.parse(s)});continue}catch(r){}const o=u.CID.asCID(s);o?t.push({Name:"",Tsize:0,Hash:o}):(Array.isArray(s)&&qn(s,t),s&&"object"===typeof s&&qn(s,t))}return t}var Vn=r(92829);function Xn(e){let{repo:t,preload:r}=e;return(0,Q.a)((async function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const s=await t.gcLock.readLock();try{const o=d.encode(e),i=await Vn.sha256.digest(o),a=u.CID.createV1(d.code,i);return await t.blocks.put(a,o,{signal:n.signal}),!1!==n.preload&&r(a),n.pin&&await t.pins.pinRecursively(a,{signal:n.signal}),a}finally{s()}}))}class Yn{constructor(e){let{repo:t,preload:r}=e;this.addLink=function(e){let{repo:t,preload:r}=e;const n=Gn({repo:t,preload:r}),s=Xn({repo:t,preload:r});return(0,Q.a)((async function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const o=await n(e,r);return s({...o,Links:o.Links.concat([t])},r)}))}({repo:t,preload:r}),this.appendData=function(e){let{repo:t,preload:r}=e;const n=Gn({repo:t,preload:r}),s=Xn({repo:t,preload:r});return(0,Q.a)((async function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const o=await n(e,r),i=(0,me.concat)([o.Data||[],t]);return s({...o,Data:i},r)}))}({repo:t,preload:r}),this.rmLink=function(e){let{repo:t,preload:r}=e;const n=Gn({repo:t,preload:r}),s=Xn({repo:t,preload:r});return(0,Q.a)((async function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const o=await n(e,r),i=("string"===typeof t?t:t.Name)||"";return o.Links=o.Links.filter((e=>e.Name!==i)),s(o,r)}))}({repo:t,preload:r}),this.setData=function(e){let{repo:t,preload:r}=e;const n=Gn({repo:t,preload:r}),s=Xn({repo:t,preload:r});return(0,Q.a)((async function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const o=await n(e,r);return s({...o,Data:t},r)}))}({repo:t,preload:r})}}class Jn{constructor(e){let{repo:t,codecs:r,preload:n}=e;this.data=function(e){let{repo:t,preload:r}=e;const n=Gn({repo:t,preload:r});return(0,Q.a)((async function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return(await n(e,t)).Data||new Uint8Array(0)}))}({repo:t,preload:n}),this.get=Gn({repo:t,preload:n}),this.links=function(e){let{repo:t,codecs:r}=e;return(0,Q.a)((async function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const s=await r.getCodec(e.code),o=await t.blocks.get(e,n),i=s.decode(o);switch(e.code){case tn.code:return[];case d.code:return i.Links;case y:case D:return qn(i);default:throw new Error(`Cannot resolve links from codec ${e.code}`)}}))}({repo:t,codecs:r}),this.new=function(e){let{repo:t,preload:r}=e;return(0,Q.a)((async function(){let e,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(n.template){if("unixfs-dir"!==n.template)throw new Error("unknown template");e=new l.fL({type:"directory"}).marshal()}const s=d.encode({Data:e,Links:[]}),o=await Vn.sha256.digest(s),i=u.CID.createV0(o);return await t.blocks.put(i,s,{signal:n.signal}),!1!==n.preload&&r(i),i}))}({repo:t,preload:n}),this.put=Xn({repo:t,preload:n}),this.stat=function(e){let{repo:t,preload:r}=e;const n=Gn({repo:t,preload:r});return(0,Q.a)((async function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const r=await n(e,t),s=d.encode(r).length,o=r.Links.reduce(((e,t)=>e+(t.Tsize||0)),0);return{Hash:e,NumLinks:r.Links.length,BlockSize:s,LinksSize:s-(r.Data||[]).length,DataSize:(r.Data||[]).length,CumulativeSize:s+o}}))}({repo:t,preload:n}),this.patch=new Yn({repo:t,preload:n})}}var Qn=r(61542);const Zn=a("ipfs:repo:gc");function es(e){let{repo:t}=e;return(0,Q.a)((async function(){const e=await t.stat();return{numObjects:BigInt(e.numObjects.toString()),repoSize:BigInt(e.repoSize.toString()),repoPath:e.repoPath,version:`${e.version}`,storageMax:BigInt(e.storageMax.toString())}}))}var ts=r(64931);class rs{constructor(e){let{repo:t,hashers:r}=e;this.gc=function(e){let{repo:t,hashers:r}=e;return(0,Q.a)((async function*(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n=Date.now();let s;try{s=await(0,Qn.x)({repo:t,hashers:r},e),await t.pins.pinRecursively(s),yield*t.gc()}finally{s&&await t.pins.unpin(s)}Zn(`Complete (${Date.now()-n}ms)`)}))}({repo:t,hashers:r}),this.stat=es({repo:t}),this.version=function(e){let{repo:t}=e;return(0,Q.a)((async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};try{await t._checkInitialized(e)}catch(r){if([/Key not found in database \[\/version\]/,/ENOENT/,/repo is not initialized yet/].some((e=>e.test(r.message))))return ts._;throw r}return t.version.get()}))}({repo:t}),this.setApiAddr=e=>t.apiAddr.set(e)}}function ns(e,t){let r;if(r=e.metrics?t.peer?e.metrics.forPeer(re.parse(t.peer)):t.proto?e.metrics.forProtocol(t.proto):e.metrics.global:void 0,!r)return{totalIn:BigInt(0),totalOut:BigInt(0),rateIn:0,rateOut:0};const{movingAverages:n,snapshot:s}=r;return{totalIn:BigInt(s.dataReceived.integerValue().toString()),totalOut:BigInt(s.dataSent.integerValue().toString()),rateIn:n.dataReceived[6e4].movingAverage()/60,rateOut:n.dataSent[6e4].movingAverage()/60}}class ss{constructor(e){let{repo:t,network:r}=e;this.repo=es({repo:t}),this.bw=function(e){let{network:t}=e;return(0,Q.a)((async function*(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{libp2p:r}=await t.use(e);if(!e.poll)return void(yield ns(r,e));const n=e.interval||1e3;let s,o=-1;try{if(o="string"===typeof n?(0,Et.Z)(n)||-1:n,!o||o<0)throw new Error("invalid duration")}catch(i){throw c(i,"ERR_INVALID_POLL_INTERVAL")}try{for(;;)yield ns(r,e),await new Promise((e=>{s=setTimeout(e,o)}))}finally{clearTimeout(s)}}))}({network:r}),this.bitswap=Ht({network:r})}}var os=r(2548),is=r(34695),as=r(17008),cs=r(24222),ls=r(27401),ds=r(46714);const hs={description:"Empty migration.",migrate:()=>{},revert:()=>{},empty:!0},us=[Object.assign({version:1},hs),Object.assign({version:2},hs),Object.assign({version:3},hs),Object.assign({version:4},hs),Object.assign({version:5},hs),Object.assign({version:6},hs),Object.assign({version:7},hs),is.Q,as.Q,cs.Q,ls.Q,ds.Q];var ps=r(35264),fs=r(38099),gs=r(61757);const ys=a("ipfs:repo:migrator");async function ws(e,t,r,n,s){let{ignoreLock:o=!1,onProgress:i,isDryRun:a=!1,migrations:c}=s;if(c=c||us,!e)throw new vs.RequiredParameterError("Path argument is required!");if(!r)throw new vs.RequiredParameterError("repoOptions argument is required!");if(!n)throw new vs.RequiredParameterError("toVersion argument is required!");if(!Number.isInteger(n)||n<=0)throw new vs.InvalidValueError("Version has to be positive integer!");t=(0,gs.pf)(t);const l=await ps.b(t);if(l===n)return void ys("Nothing to migrate.");if(l>n)throw new vs.InvalidValueError(`Current repo's version (${l}) is higher then toVersion (${n}), you probably wanted to revert it?`);let d;ms(c,l,n),a||o||(d=await r.repoLock.lock(e));try{for(const e of c){if(void 0!==n&&e.version>n)break;if(!(e.version<=l)){ys(`Migrating version ${e.version}`);try{if(!a){let r=()=>{};i&&(r=(t,r)=>i(e.version,t.toFixed(2),r)),await e.migrate(t,r)}}catch(h){const r=e.version-1;throw ys(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${r}`),await ps.x(r,t),new Error(`During migration to version ${e.version} exception was raised: ${h.stack||h.message||h}`)}ys(`Migrating to version ${e.version} finished`)}}a||await ps.x(n||function(e){return e=e||us,Array.isArray(e)&&0!==e.length?e[e.length-1].version:0}(c),t),ys("Repo successfully migrated",void 0!==n?`to version ${n}!`:"to latest version!")}finally{a||o||!d||await d.close()}}function ms(e,t,r){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=0;for(const o of e){if(o.version>r)break;if(o.version>t){if(n&&!o.revert)throw new vs.NonReversibleMigrationError(`It is not possible to revert to version ${t} because migration version ${o.version} is not reversible. Cancelling reversion.`);s++}}if(s!==r-t)throw new vs.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${t} to ${r}`)}ps.b;const vs=fs;var bs=r(77073);class _s extends Error{constructor(e){super(e),this.name="LockExistsError",this.code=_s.code}}_s.code="ERR_LOCK_EXISTS";class Es extends Error{constructor(e){super(e),this.name="NotFoundError",this.code=Es.code}}Es.code="ERR_NOT_FOUND";class ks extends Error{constructor(e){super(e),this.name="InvalidRepoVersionError",this.code=ks.code}}ks.code="ERR_INVALID_REPO_VERSION";const Is="ERR_REPO_NOT_INITIALIZED";async function Ss(e,t,r){const n=await t(e);if(n)return n;const s=Ds(r);return!!s&&new Promise(((t,r)=>{const n=s.store("readonly").get(e.toString());n.transaction.onabort=()=>{r(n.transaction.error)},n.transaction.oncomplete=()=>{t(Boolean(n.result))}}))}async function Ps(e,t,r,n){if(await r(e))return t(e);const s=Ds(n);if(!s)throw new Es;return new Promise(((t,r)=>{const n=s.store("readonly").get(e.toString());n.transaction.onabort=()=>{r(n.transaction.error)},n.transaction.oncomplete=()=>{if(n.result)return t(n.result);r(new Es)}}))}function Ds(e){let t=e;for(;t.db||t.child;)if(t=t.db||t.child,"level-js"===t.type||"Level"===t.constructor.name)return t}const Rs=a("ipfs:repo:version"),Cs=new de.Key("version");const As=G.default?G.default:G,Ts=new de.Key("config");var Ns=r(31579);const Os=new ot.s("datastore_spec");const Bs=new de.Key("api");var js=r(31730);function xs(e){const t=u.CID.asCID(e);if(null==t)throw c(new Error("Not a valid cid"),"ERR_INVALID_CID");return t.multihash.code!==N.identity.code?{isIdentity:!1}:{isIdentity:!0,digest:t.multihash.digest}}const Ls=a("ipfs:repo:lock:memory"),Ms="repo.lock",$s={};const Us={lock:async function(e){const t=e+"/"+Ms;if(Ls("locking %s",t),!0===$s[t])throw new _s(`Lock already being held for file: ${t}`);return $s[t]=!0,{async close(){$s[t]&&delete $s[t]}}},locked:async function(e){const t=e+"/"+Ms;return Ls(`checking lock: ${t}`),Boolean($s[t])}},Fs={autoMigrate:!0,onMigrationProgress:()=>{},repoOwner:!0,repoLock:Us},zs={Spec:{type:"mount",mounts:[{mountpoint:"/blocks",type:"measure",prefix:"flatfs.datastore",child:{type:"flatfs",path:"blocks",sync:!0,shardFunc:"/repo/flatfs/shard/v1/next-to-last/2"}},{mountpoint:"/",type:"measure",prefix:"leveldb.datastore",child:{type:"levelds",path:"datastore",compression:"none"}}]}};function Ws(e){const t=v.k0.asCID(e);if(null==t)throw c(new Error("Not a valid cid"),"ERR_INVALID_CID");const r=we.base32.encode(t.multihash.bytes);return new de.Key("/"+r.slice(1).toUpperCase(),!1)}function Hs(e){return ye.decode(we.base32.decode(`b${e.toString().toLowerCase().substring(1)}`))}const Ks=a("ipfs:repo:utils:walk-dag");async function*Gs(e,t,r,n){try{const s=await t.get(e,n),o=await r(e.code),i=Lr({bytes:s,cid:e,codec:o});for(const[,e]of i.links())yield e,yield*Gs(e,t,r,n)}catch(s){throw Ks("Could not walk DAG for CID",e.toString(),s),s}}class qs{constructor(e){let{pinstore:t,blockstore:r,loadCodec:n}=e;this.pinstore=t,this.blockstore=r,this.loadCodec=n,this.log=a("ipfs:repo:pin"),this.directPins=new Set,this.recursivePins=new Set}async pinDirectly(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};await this.blockstore.get(e,t);const r={depth:0};return 0!==e.version&&(r.version=e.version),e.code!==d.code&&(r.codec=e.code),t.metadata&&(r.metadata=t.metadata),this.pinstore.put(Ws(e),h.cv(r))}unpin(e,t){return this.pinstore.delete(Ws(e),t)}async pinRecursively(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};await this.fetchCompleteDag(e,t);const r={depth:1/0};0!==e.version&&(r.version=e.version),e.code!==d.code&&(r.codec=e.code),t.metadata&&(r.metadata=t.metadata),await this.pinstore.put(Ws(e),h.cv(r))}async*directKeys(e){for await(const t of this.pinstore.query({filters:[e=>0===h.Jx(e.value).depth]})){const e=h.Jx(t.value),r=e.version||0,n=null!=e.codec?e.codec:d.code,s=Hs(t.key);yield{cid:u.CID.create(r,n,s),metadata:e.metadata}}}async*recursiveKeys(e){for await(const t of this.pinstore.query({filters:[e=>h.Jx(e.value).depth===1/0]})){const e=h.Jx(t.value),r=e.version||0,n=null!=e.codec?e.codec:d.code,s=Hs(t.key);yield{cid:u.CID.create(r,n,s),metadata:e.metadata}}}async*indirectKeys(e){for await(const{cid:t}of this.recursiveKeys())for await(const r of Gs(t,this.blockstore,this.loadCodec,e)){const e=[ae.recursive];(await this.isPinnedWithType(r,e)).pinned||(yield r)}}async isPinnedWithType(e,t,r){Array.isArray(t)||(t=[t]);const n=t.includes(ae.all),s=t.includes(ae.direct),o=t.includes(ae.recursive),i=t.includes(ae.indirect);if(o||s||n){const r=await cn(this.pinstore.query({prefix:Ws(e).toString(),filters:[e=>{if(n)return!0;const r=h.Jx(e.value);return t.includes(0===r.depth?ae.direct:ae.recursive)}],limit:1}));if(r){const t=h.Jx(r.value);return{cid:e,pinned:!0,reason:0===t.depth?ae.direct:ae.recursive,metadata:t.metadata}}}const a=this;if(n||i){const t=await cn(async function*(e,t){for await(const{cid:r}of t)for await(const t of Gs(r,a.blockstore,a.loadCodec))if(t.equals(e))return void(yield r)}(e,this.recursiveKeys()));if(t)return{cid:e,pinned:!0,reason:ae.indirect,parent:t}}return{cid:e,pinned:!1}}async fetchCompleteDag(e,t){const r=new Set,n=async(e,t)=>{if(r.has(e.toString()))return;r.add(e.toString());const s=await this.blockstore.get(e,t),o=await this.loadCodec(e.code),i=Lr({bytes:s,cid:e,codec:o});await Promise.all([...i.links()].map((e=>{let[,r]=e;return n(r,t)})))};await n(e,t)}static checkPinType(e){if("string"!==typeof e||!Object.keys(ae).includes(e))throw function(e){return c(new Error(`Invalid type '${e}', must be one of {direct, indirect, recursive, all}`),"ERR_INVALID_PIN_TYPE")}(e);return!0}}async function Vs(e,t){const{pinned:r,reason:n}=await t.isPinnedWithType(e,ae.all);if(r)throw c(new Error(`pinned: ${n}`),"ERR_BLOCK_PINNED")}var Xs=r(26494),Ys=r(88411),Js=r(92393);const Qs=a("ipfs:repo:gc"),Zs=(0,he.notFoundError)().code,eo=new de.Key("/local/filesroot");function to(e){let{gcLock:t,pins:r,blockstore:n,root:s,loadCodec:o}=e;return async function*(){const e=Date.now();Qs("Creating set of marked blocks");const i=await t.writeLock();try{const t=await async function(e){let{pins:t,blockstore:r,loadCodec:n,root:s}=e;const o=async function*(){let e;try{e=await s.get(eo)}catch(o){if(o.code===Zs)return void Qs("No blocks in MFS");throw o}const t=u.CID.decode(e);yield t,yield*Gs(t,r,n)}(),i=Js(Qt(t.recursiveKeys(),(e=>{let{cid:t}=e;return t})),t.indirectKeys(),Qt(t.directKeys(),(e=>{let{cid:t}=e;return t})),o),a=new Set;for await(const c of Js(i,o))a.add(we.base32.encode(c.multihash.bytes));return a}({pins:r,blockstore:n,root:s,loadCodec:o}),a=n.queryKeys({});yield*async function*(e,t,r){let{blockstore:n}=e,s=0,o=0;const i=async e=>async function(){s++;try{const s=we.base32.encode(e.multihash.bytes);if(t.has(s))return null;try{await n.delete(e),o++}catch(r){return{err:new Error(`Could not delete block with CID ${e}: ${r.message}`)}}return{cid:e}}catch(r){const t=`Could delete block with CID ${e}`;return Qs(t,r),{err:new Error(t+`: ${r.message}`)}}};yield*(0,er.pipe)(Ys(Qt(r,i),256),(e=>Zt(e,Boolean))),Qs(`Marked set has ${t.size} unique blocks. Blockstore has ${s} blocks. Deleted ${o} blocks.`)}({blockstore:n},t,a),Qs(`Complete (${Date.now()-e}ms)`)}finally{i()}}}const ro=a("ipfs:repo"),no=Number.MAX_SAFE_INTEGER;class so{constructor(e,t,r,n){if("string"!==typeof e)throw new Error("missing repo path");if("function"!==typeof t)throw new Error("missing codec loader");this.options=(0,o.Z)(Fs,n),this.closed=!0,this.path=e,this.root=r.root,this.datastore=r.datastore,this.keys=r.keys;const s=r.blocks,i=r.pins;this.pins=new qs({pinstore:i,blockstore:s,loadCodec:t});const a=(l=this.pins,d=s,{open:()=>d.open(),close:()=>d.close(),query:(e,t)=>d.query(e,t),queryKeys:(e,t)=>d.queryKeys(e,t),get:async(e,t)=>d.get(e,t),async*getMany(e,t){yield*d.getMany(e,t)},async put(e,t,r){await d.put(e,t,r)},async*putMany(e,t){yield*d.putMany(e,t)},has:(e,t)=>d.has(e,t),delete:async(e,t)=>(await Vs(e,l),d.delete(e,t)),deleteMany:(e,t)=>d.deleteMany(Qt(e,(async e=>(await Vs(e,l),e))),t),batch:()=>d.batch()});var l,d;this.blocks=function(e){return{open:()=>e.open(),close:()=>e.close(),query:(t,r)=>e.query(t,r),queryKeys:(t,r)=>e.queryKeys(t,r),async get(t,r){const n=xs(t);return n.isIdentity?Promise.resolve(n.digest):e.get(t,r)},async*getMany(e,t){for await(const r of e)yield this.get(r,t)},async put(t,r,n){const{isIdentity:s}=xs(t);s||await e.put(t,r,n)},async*putMany(t,r){const n=js();(globalThis.process&&globalThis.process.nextTick?globalThis.process.nextTick:globalThis.setImmediate||globalThis.setTimeout)((async()=>{try{await wt(e.putMany(async function*(){for await(const{key:e,value:r}of t)xs(e).isIdentity||(yield{key:e,value:r}),n.push({key:e,value:r})}())),n.end()}catch(r){n.end(r)}})),yield*n},has(t,r){const{isIdentity:n}=xs(t);return n?Promise.resolve(!0):e.has(t,r)},delete(t,r){const{isIdentity:n}=xs(t);return n?Promise.resolve():e.delete(t,r)},deleteMany:(t,r)=>e.deleteMany(Zt(t,(e=>!xs(e).isIdentity)),r),batch(){const t=e.batch();return{put(e,r){const{isIdentity:n}=xs(e);n||t.put(e,r)},delete(e){const{isIdentity:r}=xs(e);r||t.delete(e)},commit:e=>t.commit(e)}}}}(a),this.version=function(e){return{exists:async()=>Ss(Cs,e.has.bind(e),e),async get(){const t=await Ps(Cs,e.get.bind(e),e.has.bind(e),e);return parseInt((0,ue.toString)(t),10)},set:t=>e.put(Cs,(0,z.fromString)(String(t))),async check(e){const t=await this.get();return Rs("comparing version: %s and %s",t,e),t===e||6===t&&7===e||6===e&&7===t}}}(this.root),this.config=function(e){const t=new As({concurrency:1}),r={async getAll(){const t=await Ps(Ts,e.get.bind(e),e.has.bind(e),e);return JSON.parse((0,ue.toString)(t))},async get(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(null==e)throw new Es(`Key ${e} does not exist in config`);const r=await this.getAll(t),n=os(r,e);if(void 0===n)throw new Es(`Key ${e} does not exist in config`);return n},set(e,r){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("string"!==typeof e&&!(e instanceof String))throw c(new Error("Invalid key type: "+typeof e),"ERR_INVALID_KEY");if(void 0===r||r instanceof Uint8Array)throw c(new Error("Invalid value type: "+typeof r),"ERR_INVALID_VALUE");return t.add((()=>n({key:e,value:r},s.signal)))},replace(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!e||e instanceof Uint8Array)throw c(new Error("Invalid value type: "+typeof e),"ERR_INVALID_VALUE");return t.add((()=>n({key:void 0,value:e},r.signal)))},exists:async()=>Ss(Ts,e.has.bind(e),e)};return r;async function n(e,t){if(t&&t.aborted)return;const n=e.key,o=e.value;if(n){const e=await r.getAll();return"object"===typeof e&&null!==e&&Cr(e,n,o),s(e)}return s(o)}function s(t){const r=(0,z.fromString)(JSON.stringify(t,null,2));return e.put(Ts,r)}}(this.root),this.spec=function(e){return{exists:()=>e.has(Os),async get(){const t=await e.get(Os);return JSON.parse((0,ue.toString)(t))},set:async t=>e.put(Os,(0,z.fromString)(JSON.stringify(Ns(t,{deep:!0}))))}}(this.root),this.apiAddr=function(e){return{async get(){const t=await e.get(Bs);return t&&t.toString()},set:t=>e.put(Bs,(0,z.fromString)(t.toString())),delete:()=>e.delete(Bs)}}(this.root),this.gcLock=Xs(e,{singleProcess:!1!==this.options.repoOwner}),this.gc=to({gcLock:this.gcLock,pins:this.pins,blockstore:this.blocks,root:this.root,loadCodec:t})}async init(e){var t;ro("initializing at: %s",this.path),await this._openRoot(),await this.config.replace((t=e,t.Datastore=Object.assign({},zs,os(t,"datastore")),t)),await this.spec.set(function(e){const t={...zs.Spec,...os(e,"Datastore.Spec")};return{type:t.type,mounts:t.mounts.map((e=>({mountpoint:e.mountpoint,type:e.child.type,path:e.child.path,shardFunc:e.child.shardFunc})))}}(e)),await this.version.set(ts._)}async isInitialized(){if(!this.closed)return!0;try{return await this._openRoot(),await this._checkInitialized(),await this.root.close(),!0}catch(e){return!1}}async open(){if(!this.closed)throw c(new Error("repo is already open"),"ERR_REPO_ALREADY_OPEN");ro("opening at: %s",this.path);try{await this._openRoot(),await this._checkInitialized(),this._lockfile=await this._openLock(),ro("acquired repo.lock");if(!await this.version.check(ts._)){if(!await this._isAutoMigrationEnabled())throw new ks("Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.");await this._migrate(ts._,{root:this.root,datastore:this.datastore,pins:this.pins.pinstore,blocks:this.pins.blockstore,keys:this.keys})}ro("creating datastore"),await this.datastore.open(),ro("creating blocks"),await this.blocks.open(),ro("creating keystore"),await this.keys.open(),ro("creating pins"),await this.pins.pinstore.open(),this.closed=!1,ro("all opened")}catch(e){if(this._lockfile)try{await this._closeLock(),this._lockfile=null}catch(t){ro("error removing lock",t)}throw e}}async _openRoot(){try{await this.root.open()}catch(e){if("Already open"!==e.message)throw e}}async _openLock(){const e=await this.options.repoLock.lock(this.path);if("function"!==typeof e.close)throw c(new Error("Locks must have a close method"),"ERR_NO_CLOSE_FUNCTION");return e}_closeLock(){return this._lockfile&&this._lockfile.close()}async _checkInitialized(){let e;ro("init check");try{[e]=await Promise.all([this.config.exists(),this.spec.exists(),this.version.exists()])}catch(t){if("ERR_NOT_FOUND"===t.code)throw c(new Error("repo is not initialized yet"),Is,{path:this.path});throw t}if(!e)throw c(new Error("repo is not initialized yet"),Is,{path:this.path})}async close(){if(this.closed)throw c(new Error("repo is already closed"),"ERR_REPO_ALREADY_CLOSED");ro("closing at: %s",this.path);try{await this.apiAddr.delete()}catch(e){if(e.code!==Is&&!e.message.startsWith("ENOENT"))throw e}await Promise.all([this.root,this.blocks,this.keys,this.datastore,this.pins.pinstore].map((e=>e&&e.close()))),ro("unlocking"),this.closed=!0,await this._closeLock()}exists(){return this.version.exists()}async stat(){if(this.datastore&&this.keys){const[e,t,r,n,s]=await Promise.all([this._storageMaxStat(),this._blockStat(),this.version.get(),oo(this.datastore),oo(this.keys)]),o=t.size+n+s;return{repoPath:this.path,storageMax:e,version:r,numObjects:t.count,repoSize:o}}throw c(new Error("repo is not initialized yet"),Is,{path:this.path})}async _isAutoMigrationEnabled(){if(void 0!==this.options.autoMigrate)return this.options.autoMigrate;let e;try{e=await this.config.get("repoAutoMigrate")}catch(t){if(t.code!==Es.code)throw t;e=!0}return e}async _migrate(e,t){return await this.version.get()>e?(ro(`reverting to version ${e}`),async function(e,t,r,n,s){let{ignoreLock:o=!1,onProgress:i,isDryRun:a=!1,migrations:c}=s;if(c=c||us,!e)throw new vs.RequiredParameterError("Path argument is required!");if(!r)throw new vs.RequiredParameterError("repoOptions argument is required!");if(!n)throw new vs.RequiredParameterError("When reverting migrations, you have to specify to which version to revert!");if(!Number.isInteger(n)||n<=0)throw new vs.InvalidValueError("Version has to be positive integer!");t=(0,gs.pf)(t);const l=await ps.b(t);if(l===n)return void ys("Nothing to revert.");if(l<n)throw new vs.InvalidValueError(`Current repo's version (${l}) is lower then toVersion (${n}), you probably wanted to migrate it?`);let d;ms(c,n,l,!0),a||o||(d=await r.repoLock.lock(e)),ys(`Reverting from version ${l} to ${n}`);try{const e=c.slice().reverse();for(const r of e){if(r.version<=n)break;if(!(r.version>l)){ys(`Reverting migration version ${r.version}`);try{if(!a){let e=()=>{};i&&(e=(e,t)=>i(r.version,e.toFixed(2),t)),await r.revert(t,e)}}catch(h){const e=r.version;throw ys(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${e}`),await ps.x(e,t),h.message=`During reversion to version ${r.version} exception was raised: ${h.message}`,h}ys(`Reverting to version ${r.version} finished`)}}a||await ps.x(n,t),ys(`All migrations successfully reverted to version ${n}!`)}finally{a||o||!d||await d.close()}}(this.path,t,this.options,e,{ignoreLock:!0,onProgress:this.options.onMigrationProgress})):(ro(`migrating to version ${e}`),ws(this.path,t,this.options,e,{ignoreLock:!0,onProgress:this.options.onMigrationProgress}))}async _storageMaxStat(){try{const e=await this.config.get("Datastore.StorageMax");return BigInt(bs(e))}catch(e){return BigInt(no)}}async _blockStat(){let e=BigInt(0),t=BigInt(0);if(this.blocks)for await(const{key:r,value:n}of this.blocks.query({}))e+=BigInt(1),t+=BigInt(n.byteLength),t+=BigInt(r.bytes.byteLength);return{count:e,size:t}}}async function oo(e){let t=BigInt(0);for await(const r of e.query({}))t+=BigInt(r.value.byteLength),t+=BigInt(r.key.uint8Array().byteLength);return t}var io=r(62550),ao=r(91703),co=r(77420);class lo extends it.BaseDatastore{constructor(e,t){super(),this.path=e,this.opts=t,t&&t.db?(this.database=t.db,delete t.db):this.database=co}_initDb(){return new Promise(((e,t)=>{this.db=this.database(this.path,{...this.opts,valueEncoding:"binary",compression:!1},(r=>{if(r)return t(r);e(this.db)}))}))}async open(){try{this.db?await this.db.open():this.db=await this._initDb()}catch(e){throw it.Errors.dbOpenFailedError(e)}}async put(e,t){try{await this.db.put(e.toString(),t)}catch(r){throw it.Errors.dbWriteFailedError(r)}}async get(e){let t;try{t=await this.db.get(e.toString())}catch(r){if(r.notFound)throw it.Errors.notFoundError(r);throw it.Errors.dbWriteFailedError(r)}return t}async has(e){try{await this.db.get(e.toString())}catch(t){if(t.notFound)return!1;throw t}return!0}async delete(e){try{await this.db.del(e.toString())}catch(t){throw it.Errors.dbDeleteFailedError(t)}}close(){return this.db&&this.db.close()}batch(){const e=[];return{put:(t,r)=>{e.push({type:"put",key:t.toString(),value:r})},delete:t=>{e.push({type:"del",key:t.toString()})},commit:()=>this.db.batch(e)}}query(e){let t=this._query({values:!0,prefix:e.prefix});Array.isArray(e.filters)&&(t=e.filters.reduce(((e,t)=>Zt(e,t)),t)),Array.isArray(e.orders)&&(t=e.orders.reduce(((e,t)=>ao(e,t)),t));const{offset:r,limit:n}=e;if(r){let e=0;t=Zt(t,(()=>e++>=r))}return n&&(t=io(t,n)),t}queryKeys(e){let t=Qt(this._query({values:!1,prefix:e.prefix}),(e=>{let{key:t}=e;return t}));Array.isArray(e.filters)&&(t=e.filters.reduce(((e,t)=>Zt(e,t)),t)),Array.isArray(e.orders)&&(t=e.orders.reduce(((e,t)=>ao(e,t)),t));const{offset:r,limit:n}=e;if(r){let e=0;t=Zt(t,(()=>e++>=r))}return n&&(t=io(t,n)),t}_query(e){const t={keys:!0,keyAsBuffer:!0,values:e.values};if(null!=e.prefix){const r=e.prefix.toString();t.gte=r,t.lt=r+"\xff"}return r=this.db.iterator(t),{[Symbol.asyncIterator]:()=>({next:()=>new Promise(((e,t)=>{r.next(((n,s,o)=>n?t(n):null==s?r.end((r=>{if(r)return t(r);e({done:!0,value:void 0})})):void e({done:!1,value:{key:new ot.s(s,!1),value:o}})))})),return:()=>new Promise(((e,t)=>{r.end((r=>{if(r)return t(r);e({done:!0,value:void 0})}))}))})};var r}}var ho=r(8511);function uo(e){const t=u.CID.asCID(e);if(!t)throw c(new Error("Not a valid cid"),"ERR_INVALID_CID");return new de.Key("/"+we.base32.encode(t.multihash.bytes).slice(1).toUpperCase(),!1)}function po(e){return u.CID.createV1(tn.code,ye.decode(we.base32.decode("b"+e.toString().slice(1).toLowerCase())))}function fo(e){const t=e.substring(0,1);if("/"===t)return fo(e.substring(1));let r,n;r="b"===t.toLowerCase()?e=>we.base32.decode(e.toLowerCase()).subarray(2):"c"===t.toLowerCase()?e=>we.base32pad.decode(e.toLowerCase()).subarray(2):"z"===t?e=>st.base58btc.decode(e).subarray(2):"Q"===t?e=>st.base58btc.decode("z"+e):e=>we.base32.decode("b"+e.toLowerCase()).subarray(2);for(let i=1;i<e.length;i++)try{n=r(e.substring(0,i))}catch(o){if("Unexpected end of data"!==o.message)throw o}let s="/C";return n&&(s=`/${we.base32.encode(n).slice(1,-1).toUpperCase()||"C"}`),s}class go extends ho.E{constructor(e){super(),this.child=e}open(){return this.child.open()}close(){return this.child.close()}async*query(e,t){for await(const{key:r,value:n}of this.child.query(function(e){return{...e,prefix:e.prefix?fo(e.prefix):void 0,filters:e.filters?e.filters.map((e=>t=>e({key:po(t.key),value:t.value}))):void 0,orders:e.orders?e.orders.map((e=>(t,r)=>e({key:po(t.key),value:t.value},{key:po(r.key),value:r.value}))):void 0}}(e),t))yield{key:po(r),value:n}}async*queryKeys(e,t){for await(const r of this.child.queryKeys(function(e){return{...e,prefix:e.prefix?fo(e.prefix):void 0,filters:e.filters?e.filters.map((e=>t=>e(po(t)))):void 0,orders:e.orders?e.orders.map((e=>(t,r)=>e(po(t),po(r)))):void 0}}(e),t))yield po(r)}async get(e,t){return this.child.get(uo(e),t)}async*getMany(e,t){for await(const r of e)yield this.get(r,t)}async put(e,t,r){await this.child.put(uo(e),t,r)}async*putMany(e,t){const r=js();(globalThis.process&&globalThis.process.nextTick?globalThis.process.nextTick:globalThis.setImmediate||globalThis.setTimeout)((async()=>{try{const n=this.child;await wt(this.child.putMany(async function*(){for await(const s of e){const e=uo(s.key);await n.has(e,t)||(yield{key:e,value:s.value}),r.push(s)}}())),r.end()}catch(n){r.end(n)}})),yield*r}has(e,t){return this.child.has(uo(e),t)}delete(e,t){return this.child.delete(uo(e),t)}deleteMany(e,t){const r=js();return wt(this.child.deleteMany(async function*(){for await(const t of e)yield uo(t),r.push(t);r.end()}(),t)).catch((e=>{r.end(e)})),r}}function yo(e,t,r){const n=r.path||"ipfs";return function(e,t,r,n){return new so(e,t,r,n)}(n,(e=>t.getCodec(e)),{root:new lo(n,{prefix:"",version:2}),blocks:new go(new lo(`${n}/blocks`,{prefix:"",version:2})),datastore:new lo(`${n}/datastore`,{prefix:"",version:2}),keys:new lo(`${n}/keys`,{prefix:"",version:2}),pins:new lo(`${n}/pins`,{prefix:"",version:2})},{autoMigrate:r.autoMigrate,onMigrationProgress:r.onMigrationProgress||e,repoLock:Us})}var wo=r(97153);const mo={gossipsub:wo};var vo=r(55585),bo=r(8711),_o=r(48140),Eo=r(80425),ko=r(73790),Io=r(70732),So=r(39541);const Po=(0,Io.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await(await e.post("bitswap/wantlist",{signal:t.signal,searchParams:(0,So.X)(t),headers:t.headers})).json();return(r.Keys||[]).map((e=>u.CID.parse(e["/"])))})),Do=(0,Io.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await(await e.post("bitswap/wantlist",{signal:r.signal,searchParams:(0,So.X)({...r,peer:t.toString()}),headers:r.headers})).json();return(n.Keys||[]).map((e=>u.CID.parse(e["/"])))})),Ro=(0,Io.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("bitswap/stat",{searchParams:(0,So.X)(t),signal:t.signal,headers:t.headers});return Co(await r.json())}));function Co(e){return{provideBufLen:e.ProvideBufLen,wantlist:(e.Wantlist||[]).map((e=>u.CID.parse(e["/"]))),peers:e.Peers||[],blocksReceived:BigInt(e.BlocksReceived),dataReceived:BigInt(e.DataReceived),blocksSent:BigInt(e.BlocksSent),dataSent:BigInt(e.DataSent),dupBlksReceived:BigInt(e.DupBlksReceived),dupDataReceived:BigInt(e.DupDataReceived)}}const Ao=(0,Io.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("bitswap/unwant",{signal:r.signal,searchParams:(0,So.X)({arg:t.toString(),...r}),headers:r.headers});return n.json()}));function To(e){return{wantlist:Po(e),wantlistForPeer:Do(e),unwant:Ao(e),stat:Ro(e)}}const No=(0,Io.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("block/get",{signal:r.signal,searchParams:(0,So.X)({arg:t.toString(),...r}),headers:r.headers});return new Uint8Array(await n.arrayBuffer())}));var Oo=r(6555),Bo=r(71696);async function jo(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const n=[],s=new FormData;let o=0,i=0;for await(const{content:a,path:c,mode:l,mtime:d}of(0,Oo.f)(e)){let e="";o>0&&(e=`-${o}`);let t=(a?"file":"dir")+e;const r=[];if(null!==l&&void 0!==l&&r.push(`mode=${(0,Bo.Q)(l)}`),null!=d){const{secs:e,nsecs:t}=d;r.push(`mtime=${e}`),null!=t&&r.push(`mtime-nsecs=${t}`)}if(r.length&&(t=`${t}?${r.join("&")}`),a){s.set(t,a,null!=c?encodeURIComponent(c):void 0);const e=i+a.size;n.push({name:c,start:i,end:e}),i=e}else{if(null==c)throw new Error("path or content or both must be set");s.set(t,new File([""],encodeURIComponent(c),{type:"application/x-directory"}))}o++}return{total:i,parts:n,headers:r,body:s}}function xo(e){return e.filter(Boolean)}function Lo(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return(0,jt.anySignal)(xo(t))}const Mo=(0,Io.j)((e=>async function t(r){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const s=new AbortController,o=Lo(s.signal,n.signal);let i;try{const t=await e.post("block/put",{signal:o,searchParams:(0,So.X)(n),...await jo([r],s,n.headers)});i=await t.json()}catch(a){if("dag-pb"===n.format)return t(r,{...n,format:"protobuf"});if("dag-cbor"===n.format)return t(r,{...n,format:"cbor"});throw a}return u.CID.parse(i.Key)})),$o=(0,Io.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};Array.isArray(t)||(t=[t]);const n=await e.post("block/rm",{signal:r.signal,searchParams:(0,So.X)({arg:t.map((e=>e.toString())),"stream-channels":!0,...r}),headers:r.headers});for await(const e of n.ndjson())yield Uo(e)}));function Uo(e){const t={cid:u.CID.parse(e.Hash)};return e.Error&&(t.error=new Error(e.Error)),t}const Fo=(0,Io.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("block/stat",{signal:r.signal,searchParams:(0,So.X)({arg:t.toString(),...r}),headers:r.headers}),s=await n.json();return{cid:u.CID.parse(s.Key),size:s.Size}}));function zo(e){return{get:No(e),put:Mo(e),rm:$o(e),stat:Fo(e)}}const Wo=(0,Io.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("bootstrap/add",{signal:r.signal,searchParams:(0,So.X)({arg:t,...r}),headers:r.headers}),{Peers:s}=await n.json();return{Peers:s.map((e=>new Vt.Multiaddr(e)))}})),Ho=(0,Io.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("bootstrap/rm",{signal:t.signal,searchParams:(0,So.X)({...t,all:!0}),headers:t.headers}),{Peers:n}=await r.json();return{Peers:n.map((e=>new Vt.Multiaddr(e)))}})),Ko=(0,Io.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("bootstrap/list",{signal:t.signal,searchParams:(0,So.X)(t),headers:t.headers}),{Peers:n}=await r.json();return{Peers:n.map((e=>new Vt.Multiaddr(e)))}})),Go=(0,Io.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("bootstrap/add",{signal:t.signal,searchParams:(0,So.X)({...t,default:!0}),headers:t.headers}),{Peers:n}=await r.json();return{Peers:n.map((e=>new Vt.Multiaddr(e)))}})),qo=(0,Io.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("bootstrap/rm",{signal:r.signal,searchParams:(0,So.X)({arg:t,...r}),headers:r.headers}),{Peers:s}=await n.json();return{Peers:s.map((e=>new Vt.Multiaddr(e)))}}));function Vo(e){return{add:Wo(e),clear:Ho(e),list:Ko(e),reset:Go(e),rm:qo(e)}}const Xo=(0,Io.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("config/profile/apply",{signal:r.signal,searchParams:(0,So.X)({arg:t,...r}),headers:r.headers}),s=await n.json();return{original:s.OldCfg,updated:s.NewCfg}}));var Yo=r(92670);const Jo=(0,Io.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("config/profile/list",{signal:t.signal,searchParams:(0,So.X)(t),headers:t.headers}),n=await r.json();return n.map((e=>(0,Yo.C)(e)))}));function Qo(e){return{apply:Xo(e),list:Jo(e)}}const Zo=(0,Io.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!t)throw new Error("key argument is required");const n=await e.post("config",{signal:r.signal,searchParams:(0,So.X)({arg:t,...r}),headers:r.headers}),s=await n.json();return s.Value})),ei=(0,Io.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("config/show",{signal:t.signal,searchParams:(0,So.X)({...t}),headers:t.headers}),n=await r.json();return n})),ti=(0,Io.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=new AbortController,s=Lo(n.signal,r.signal),o=await e.post("config/replace",{signal:s,searchParams:(0,So.X)(r),...await jo([(0,z.fromString)(JSON.stringify(t))],n,r.headers)});await o.text()})),ri=(0,Io.j)((e=>async function(t,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("string"!==typeof t)throw new Error("Invalid key type");const s={...n,...ni(t,r)},o=await e.post("config",{signal:n.signal,searchParams:(0,So.X)(s),headers:n.headers});await o.text()})),ni=(e,t)=>{switch(typeof t){case"boolean":return{arg:[e,t.toString()],bool:!0};case"string":return{arg:[e,t]};default:return{arg:[e,JSON.stringify(t)],json:!0}}};function si(e){return{getAll:ei(e),get:Zo(e),set:ri(e),replace:ti(e),profiles:Qo(e)}}const oi=(0,Io.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("dag/export",{signal:r.signal,searchParams:(0,So.X)({arg:t.toString()}),headers:r.headers});yield*n.iterator()}));async function*ii(e,t,r,n,s){const o=async e=>{const t=await r.getCodec(e.code),o=await n(e,s);return t.decode(o)},i=t.split("/").filter(Boolean);let a=await o(e),l=e;for(;i.length;){const e=i.shift();if(!e)throw c(new Error(`Could not resolve path "${t}"`),"ERR_INVALID_PATH");if(!Object.prototype.hasOwnProperty.call(a,e))throw c(new Error(`no link named "${e}" under ${l}`),"ERR_NO_LINK");a=a[e],yield{value:a,remainderPath:i.join("/")};const r=u.CID.asCID(a);r&&(l=r,a=await o(a))}yield{value:a,remainderPath:""}}const ai=(e,t)=>{const r=(0,Io.j)(((t,r)=>{const n=No(r);return async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(r.path){const s=r.localResolve?await cn(ii(t,r.path,e,n,r)):await se(ii(t,r.path,e,n,r));if(!s)throw c(new Error("Not found"),"ERR_NOT_FOUND");return s}const s=await e.getCodec(t.code),o=await n(t,r),i=s.decode(o);return{value:i,remainderPath:""}}}));return r(t)},ci=(0,Io.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=new AbortController,s=Lo(n.signal,r.signal),{headers:o,body:i}=await jo(t,n,r.headers),a=await e.post("dag/import",{signal:s,headers:o,body:i,searchParams:(0,So.X)({"pin-roots":r.pinRoots})});for await(const{Root:e}of a.ndjson())if(void 0!==e){const{Cid:{"/":t},PinErrorMsg:r}=e;yield{root:{cid:u.CID.parse(t),pinErrorMsg:r}}}})),li=(e,t)=>{const r=(0,Io.j)((t=>async function(r){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const s={storeCodec:"dag-cbor",hashAlg:"sha2-256",...n};let o;if(s.inputCodec){if(!(r instanceof Uint8Array))throw new Error("Can only inputCodec on raw bytes that can be decoded");o=r}else{o=(await e.getCodec(s.storeCodec)).encode(r),s.inputCodec=s.storeCodec}const i=new AbortController,a=Lo(i.signal,s.signal),c=await t.post("dag/put",{timeout:s.timeout,signal:a,searchParams:(0,So.X)(s),...await jo([o],i,s.headers)}),l=await c.json();return u.CID.parse(l.Cid["/"])}));return r(t)},di=(0,Io.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("dag/resolve",{signal:r.signal,searchParams:(0,So.X)({arg:`${t}${r.path?`/${r.path}`.replace(/\/[/]+/g,"/"):""}`,...r}),headers:r.headers}),s=await n.json();return{cid:u.CID.parse(s.Cid["/"]),remainderPath:s.RemPath}}));function hi(e,t){return{export:oi(t),get:ai(e,t),import:ci(t),put:li(e,t),resolve:di(t)}}var ui=r(43592);const pi=(0,Io.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("dht/findpeer",{signal:r.signal,searchParams:(0,So.X)({arg:t,...r}),headers:r.headers});for await(const e of n.ndjson())yield(0,ui.A)(e)})),fi=(0,Io.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("dht/findprovs",{signal:r.signal,searchParams:(0,So.X)({arg:t.toString(),...r}),headers:r.headers});for await(const e of n.ndjson())yield(0,ui.A)(e)})),gi=(0,Io.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("dht/get",{signal:r.signal,searchParams:(0,So.X)({arg:t instanceof Uint8Array?(0,ue.toString)(t):t.toString(),...r}),headers:r.headers});for await(const e of n.ndjson())yield(0,ui.A)(e)})),yi=(0,Io.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{recursive:!1};const n=Array.isArray(t)?t:[t],s=await e.post("dht/provide",{signal:r.signal,searchParams:(0,So.X)({arg:n.map((e=>e.toString())),...r}),headers:r.headers});for await(const e of s.ndjson())yield(0,ui.A)(e)})),wi=(0,Io.j)((e=>async function*(t,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=new AbortController,o=Lo(s.signal,n.signal),i=await e.post("dht/put",{signal:o,searchParams:(0,So.X)({arg:t instanceof Uint8Array?(0,ue.toString)(t):t.toString(),...n}),...await jo([r],s,n.headers)});for await(const e of i.ndjson())yield(0,ui.A)(e)})),mi=(0,Io.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("dht/query",{signal:r.signal,searchParams:(0,So.X)({arg:t.toString(),...r}),headers:r.headers});for await(const e of n.ndjson())yield(0,ui.A)(e)}));function vi(e){return{findPeer:pi(e),findProvs:fi(e),get:gi(e),provide:yi(e),put:wi(e),query:mi(e)}}const bi=(0,Io.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("diag/cmds",{signal:t.signal,searchParams:(0,So.X)(t),headers:t.headers});return r.json()})),_i=(0,Io.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("diag/net",{signal:t.signal,searchParams:(0,So.X)(t),headers:t.headers});return r.json()})),Ei=(0,Io.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("diag/sys",{signal:t.signal,searchParams:(0,So.X)(t),headers:t.headers});return r.json()}));function ki(e){return{cmds:bi(e),net:_i(e),sys:Ei(e)}}const Ii=(0,Io.j)((e=>async function(t,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=await e.post("files/chmod",{signal:n.signal,searchParams:(0,So.X)({arg:t,mode:r,...n}),headers:n.headers});await s.text()})),Si=(0,Io.j)((e=>async function(t,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=Array.isArray(t)?t:[t],o=await e.post("files/cp",{signal:n.signal,searchParams:(0,So.X)({arg:s.concat(r).map((e=>u.CID.asCID(e)?`/ipfs/${e}`:e)),...n}),headers:n.headers});await o.text()})),Pi=(0,Io.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!t||"string"!==typeof t)throw new Error("ipfs.files.flush requires a path");const n=await e.post("files/flush",{signal:r.signal,searchParams:(0,So.X)({arg:t,...r}),headers:r.headers}),s=await n.json();return u.CID.parse(s.Cid)}));var Di=r(1611);const Ri=(0,Io.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!t)throw new Error("ipfs.files.ls requires a path");const n=await e.post("files/ls",{signal:r.signal,searchParams:(0,So.X)({arg:u.CID.asCID(t)?`/ipfs/${t}`:t,long:!0,...r,stream:!0}),headers:r.headers});for await(const e of n.ndjson())if("Entries"in e)for(const t of e.Entries||[])yield Ci((0,Di.c)(t));else yield Ci((0,Di.c)(e))}));function Ci(e){return e.hash&&(e.cid=u.CID.parse(e.hash)),delete e.hash,e.type=1===e.type?"directory":"file",e}const Ai=(0,Io.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("files/mkdir",{signal:r.signal,searchParams:(0,So.X)({arg:t,...r}),headers:r.headers});await n.text()})),Ti=(0,Io.j)((e=>async function(t,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Array.isArray(t)||(t=[t]);const s=await e.post("files/mv",{signal:n.signal,searchParams:(0,So.X)({arg:t.concat(r),...n}),headers:n.headers});await s.text()}));var Ni=r(84001);const Oi=(0,Io.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("files/read",{signal:r.signal,searchParams:(0,So.X)({arg:t,count:r.length,...r}),headers:r.headers});yield*Ni(n.body)})),Bi=(0,Io.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("files/rm",{signal:r.signal,searchParams:(0,So.X)({arg:t,...r}),headers:r.headers}),s=await n.text();if(""!==s){const e=new q.HTTPError(n);throw e.message=s,e}})),ji=(0,Io.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("files/stat",{signal:r.signal,searchParams:(0,So.X)({arg:t,...r}),headers:r.headers}),s=await n.json();return s.WithLocality=s.WithLocality||!1,xi((0,Di.c)(s))}));function xi(e){return e.cid=u.CID.parse(e.hash),delete e.hash,e}const Li=(0,Io.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("files/touch",{signal:r.signal,searchParams:(0,So.X)({arg:t,...r}),headers:r.headers});await n.text()}));var Mi=r(15059),$i=r(13068);const Ui=(0,Io.j)((e=>async function(t,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=new AbortController,o=Lo(s.signal,n.signal),i=await e.post("files/write",{signal:o,searchParams:(0,So.X)({arg:t,streamChannels:!0,count:n.length,...n}),...await jo([{content:r,path:"arg",mode:(0,Mi.Q)(n.mode),mtime:(0,$i.X)(n.mtime)}],s,n.headers)});await i.text()}));function Fi(e){return{chmod:Ii(e),cp:Si(e),flush:Pi(e),ls:Ri(e),mkdir:Ai(e),mv:Ti(e),read:Oi(e),rm:Bi(e),stat:ji(e),touch:Li(e),write:Ui(e)}}const zi=(0,Io.j)((e=>async function(e,t){throw c(new Error("Not implemented"),"ERR_NOT_IMPLEMENTED")})),Wi=(0,Io.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{type:"rsa",size:2048};const n=await e.post("key/gen",{signal:r.signal,searchParams:(0,So.X)({arg:t,...r}),headers:r.headers}),s=await n.json();return(0,Yo.C)(s)})),Hi=(0,Io.j)((e=>async function(t,r,n){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const o=await e.post("key/import",{signal:s.signal,searchParams:(0,So.X)({arg:t,pem:r,password:n,...s}),headers:s.headers}),i=await o.json();return(0,Yo.C)(i)})),Ki=(0,Io.j)((e=>async function(e){throw c(new Error("Not implemented"),"ERR_NOT_IMPLEMENTED")})),Gi=(0,Io.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("key/list",{signal:t.signal,searchParams:(0,So.X)(t),headers:t.headers}),n=await r.json();return(n.Keys||[]).map((e=>(0,Yo.C)(e)))})),qi=(0,Io.j)((e=>async function(t,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=await e.post("key/rename",{signal:n.signal,searchParams:(0,So.X)({arg:[t,r],...n}),headers:n.headers});return(0,Yo.C)(await s.json())})),Vi=(0,Io.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("key/rm",{signal:r.signal,searchParams:(0,So.X)({arg:t,...r}),headers:r.headers}),s=await n.json();return(0,Yo.C)(s.Keys[0])}));function Xi(e){return{export:zi(e),gen:Wi(e),import:Hi(e),info:Ki(e),list:Gi(e),rename:qi(e),rm:Vi(e)}}const Yi=(0,Io.j)((e=>async function(t,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=await e.post("log/level",{signal:n.signal,searchParams:(0,So.X)({arg:[t,r],...n}),headers:n.headers});return(0,Yo.C)(await s.json())})),Ji=(0,Io.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("log/ls",{signal:t.signal,searchParams:(0,So.X)(t),headers:t.headers}),n=await r.json();return n.Strings})),Qi=(0,Io.j)((e=>async function*(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("log/tail",{signal:t.signal,searchParams:(0,So.X)(t),headers:t.headers});yield*r.ndjson()}));function Zi(e){return{level:Yi(e),ls:Ji(e),tail:Qi(e)}}const ea=(0,Io.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("name/publish",{signal:r.signal,searchParams:(0,So.X)({arg:`${t}`,...r}),headers:r.headers});return(0,Yo.C)(await n.json())})),ta=(0,Io.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("name/resolve",{signal:r.signal,searchParams:(0,So.X)({arg:t,stream:!0,...r}),headers:r.headers});for await(const e of n.ndjson())yield e.Path})),ra=(0,Io.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("name/pubsub/cancel",{signal:r.signal,searchParams:(0,So.X)({arg:t,...r}),headers:r.headers});return(0,Yo.C)(await n.json())})),na=(0,Io.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("name/pubsub/state",{signal:t.signal,searchParams:(0,So.X)(t),headers:t.headers});return(0,Yo.C)(await r.json())})),sa=(0,Io.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("name/pubsub/subs",{signal:t.signal,searchParams:(0,So.X)(t),headers:t.headers}),n=await r.json();return n.Strings||[]}));function oa(e){return{cancel:ra(e),state:na(e),subs:sa(e)}}function ia(e){return{publish:ea(e),resolve:ta(e),pubsub:oa(e)}}const aa=(0,Io.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("object/data",{signal:r.signal,searchParams:(0,So.X)({arg:`${t instanceof Uint8Array?u.CID.decode(t):t}`,...r}),headers:r.headers}),s=await n.arrayBuffer();return new Uint8Array(s,0,s.byteLength)})),ca=(0,Io.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("object/get",{signal:r.signal,searchParams:(0,So.X)({arg:`${t instanceof Uint8Array?u.CID.decode(t):t}`,dataEncoding:"base64",...r}),headers:r.headers}),s=await n.json();return{Data:(0,z.fromString)(s.Data,"base64pad"),Links:(s.Links||[]).map((e=>({Name:e.Name,Hash:u.CID.parse(e.Hash),Tsize:e.Size})))}})),la=(0,Io.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("object/links",{signal:r.signal,searchParams:(0,So.X)({arg:`${t instanceof Uint8Array?u.CID.decode(t):t}`,...r}),headers:r.headers}),s=await n.json();return(s.Links||[]).map((e=>({Name:e.Name,Tsize:e.Size,Hash:u.CID.parse(e.Hash)})))})),da=(0,Io.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("object/new",{signal:t.signal,searchParams:(0,So.X)({arg:t.template,...t}),headers:t.headers}),{Hash:n}=await r.json();return u.CID.parse(n)})),ha=(e,t)=>{const r=(0,Io.j)((r=>{const n=li(e,t);return async function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return n(e,{...t,storeCodec:"dag-pb",hashAlg:"sha2-256",version:1})}}));return r(t)},ua=(0,Io.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("object/stat",{signal:r.signal,searchParams:(0,So.X)({arg:`${t}`,...r}),headers:r.headers}),s=await n.json();return{...s,Hash:u.CID.parse(s.Hash)}})),pa=(0,Io.j)((e=>async function(t,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=await e.post("object/patch/add-link",{signal:n.signal,searchParams:(0,So.X)({arg:[`${t}`,r.Name||r.name||"",(r.Hash||r.cid||"").toString()||null],...n}),headers:n.headers}),{Hash:o}=await s.json();return u.CID.parse(o)})),fa=(0,Io.j)((e=>async function(t,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=new AbortController,o=Lo(s.signal,n.signal),i=await e.post("object/patch/append-data",{signal:o,searchParams:(0,So.X)({arg:`${t}`,...n}),...await jo([r],s,n.headers)}),{Hash:a}=await i.json();return u.CID.parse(a)})),ga=(0,Io.j)((e=>async function(t,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=await e.post("object/patch/rm-link",{signal:n.signal,searchParams:(0,So.X)({arg:[`${t}`,r.Name||r.name||null],...n}),headers:n.headers}),{Hash:o}=await s.json();return u.CID.parse(o)})),ya=(0,Io.j)((e=>async function(t,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=new AbortController,o=Lo(s.signal,n.signal),i=await e.post("object/patch/set-data",{signal:o,searchParams:(0,So.X)({arg:[`${t}`],...n}),...await jo([r],s,n.headers)}),{Hash:a}=await i.json();return u.CID.parse(a)}));function wa(e){return{addLink:pa(e),appendData:fa(e),rmLink:ga(e),setData:ya(e)}}function ma(e,t){return{data:aa(t),get:ca(t),links:la(t),new:da(t),put:ha(e,t),stat:ua(t),patch:wa(t)}}const va=(0,Io.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};for await(const{path:n,recursive:s,metadata:o}of oe(t)){const t=await e.post("pin/add",{signal:r.signal,searchParams:(0,So.X)({...r,arg:n,recursive:s,metadata:o?JSON.stringify(o):void 0,stream:!0}),headers:r.headers});for await(const e of t.ndjson())if(e.Pins)for(const t of e.Pins)yield u.CID.parse(t);else yield u.CID.parse(e)}}));function ba(e){const t=va(e);return(0,Io.j)((()=>async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return se(t([{path:e,...r}],r))}))(e)}function _a(e,t,r){const n={type:e,cid:u.CID.parse(t)};return r&&(n.metadata=r),n}const Ea=(0,Io.j)((e=>async function*(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=[];t.paths&&(r=Array.isArray(t.paths)?t.paths:[t.paths]);const n=await e.post("pin/ls",{signal:t.signal,searchParams:(0,So.X)({...t,arg:r.map((e=>`${e}`)),stream:!0}),headers:t.headers});for await(const e of n.ndjson()){if(e.Keys){for(const t of Object.keys(e.Keys))yield _a(e.Keys[t].Type,t,e.Keys[t].Metadata);return}yield _a(e.Type,e.Cid,e.Metadata)}})),ka=(0,Io.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};for await(const{path:n,recursive:s}of oe(t)){const t=new URLSearchParams(r.searchParams);t.append("arg",`${n}`),null!=s&&t.set("recursive",String(s));const o=await e.post("pin/rm",{signal:r.signal,headers:r.headers,searchParams:(0,So.X)({...r,arg:`${n}`,recursive:s})});for await(const e of o.ndjson())e.Pins?yield*e.Pins.map((e=>u.CID.parse(e))):yield u.CID.parse(e)}})),Ia=e=>{const t=ka(e);return(0,Io.j)((()=>async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return se(t([{path:e,...r}],r))}))(e)};var Sa=r(44190);const Pa=e=>{let{Name:t,Status:r,Cid:n}=e;return{cid:u.CID.parse(n),name:t,status:r}},Da=e=>{if("string"===typeof e&&""!==e)return e;throw new TypeError("service name must be passed")},Ra=e=>{if(u.CID.asCID(e))return e.toString();throw new TypeError("CID instance expected instead of "+typeof e)},Ca=e=>{let{service:t,cid:r,name:n,status:s,all:o}=e;const i=(0,So.X)({service:Da(t),name:n,force:!!o||void 0});if(r)for(const a of r)i.append("cid",Ra(a));if(s)for(const a of s)i.append("status",a);return i},Aa=e=>{let{cid:t,service:r,background:n,name:s,origins:o}=e;const i=(0,So.X)({arg:Ra(t),service:Da(r),name:s,background:!!n||void 0});if(o)for(const a of o)i.append("origin",a.toString());return i};function Ta(e){return async function(t,r){let{timeout:n,signal:s,headers:o,...i}=r;const a=await e.post("pin/remote/add",{timeout:n,signal:s,headers:o,searchParams:Aa({cid:t,...i})});return Pa(await a.json())}}function Na(e){return async function*(t){let{timeout:r,signal:n,headers:s,...o}=t;const i=await e.post("pin/remote/ls",{timeout:r,signal:n,headers:s,searchParams:Ca(o)});for await(const e of i.ndjson())yield Pa(e)}}function Oa(e){return async function(t){let{timeout:r,signal:n,headers:s,...o}=t;await e.post("pin/remote/rm",{timeout:r,signal:n,headers:s,searchParams:Ca({...o,all:!1})})}}function Ba(e){return async function(t){let{timeout:r,signal:n,headers:s,...o}=t;await e.post("pin/remote/rm",{timeout:r,signal:n,headers:s,searchParams:Ca({...o,all:!0})})}}var ja=r(99299);function xa(e){return async function(t,r){const{endpoint:n,key:s,headers:o,timeout:i,signal:a}=r;await e.post("pin/remote/service/add",{timeout:i,signal:a,searchParams:(0,So.X)({arg:[t,(0,ja.hm)(n),s]}),headers:o})}}function La(e){return async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{stat:r,headers:n,timeout:s,signal:o}=t,i=await e.post("pin/remote/service/ls",{timeout:s,signal:o,headers:n,searchParams:!0===r?(0,So.X)({stat:r}):void 0}),{RemoteServices:a}=await i.json();return a.map(ja.iI)}}function Ma(e){return async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};await e.post("pin/remote/service/rm",{signal:r.signal,headers:r.headers,searchParams:(0,So.X)({arg:t})})}}function $a(e){const t=new Sa.KU(e);return{add:xa(t),ls:La(t),rm:Ma(t)}}function Ua(e){const t=new Sa.KU(e);return{add:Ta(t),ls:Na(t),rm:Oa(t),rmAll:Ba(t),service:$a(e)}}function Fa(e){return{addAll:va(e),add:ba(e),ls:Ea(e),rmAll:ka(e),rm:Ia(e),remote:Ua(e)}}const za=e=>Array.isArray(e)?e.map(Wa):e,Wa=e=>(0,ue.toString)(Ha(e)),Ha=e=>b.base64url.decode(e),Ka=e=>b.base64url.encode((0,z.fromString)(e)),Ga=(0,Io.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{Strings:r}=await(await e.post("pubsub/ls",{signal:t.signal,searchParams:(0,So.X)(t),headers:t.headers})).json();return za(r)||[]})),qa=(0,Io.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("pubsub/peers",{signal:r.signal,searchParams:(0,So.X)({arg:Ka(t),...r}),headers:r.headers}),{Strings:s}=await n.json();return s||[]})),Va=(0,Io.j)((e=>async function(t,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=(0,So.X)({arg:Ka(t),...n}),o=new AbortController,i=Lo(o.signal,n.signal),a=await e.post("pubsub/pub",{signal:i,searchParams:s,...await jo([r],o,n.headers)});await a.text()})),Xa=a("ipfs-http-client:pubsub:subscribe");async function Ya(e,t){let{onMessage:r,onEnd:n,onError:s}=t;s=s||Xa;try{for await(const t of e.ndjson())try{if(!t.from)continue;r({from:t.from,data:Ha(t.data),seqno:Ha(t.seqno),topicIDs:za(t.topicIDs)})}catch(o){o.message=`Failed to parse pubsub message: ${o.message}`,s(o,!1,t)}}catch(o){Ja(o)||s(o,!0)}finally{n()}}const Ja=e=>{switch(e.type){case"aborted":case"abort":return!0;default:return"AbortError"===e.name}};var Qa=r(12613),Za=r(21194);function ec(e){const t=new Za.f;return{ls:Ga(e),peers:qa(e),publish:Va(e),subscribe:(r=e,n=t,(0,Io.j)((e=>async function(t,r){let s,o,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};i.signal=n.subscribe(t,r,i.signal);const a=new Promise(((e,t)=>{s=e,o=t})),c=setTimeout((()=>s()),1e3);return e.post("pubsub/sub",{signal:i.signal,searchParams:(0,So.X)({arg:Ka(t),...i}),headers:i.headers}).catch((e=>{n.unsubscribe(t,r),o(e)})).then((e=>{clearTimeout(c),e&&(Ya(e,{onMessage:r,onEnd:()=>n.unsubscribe(t,r),onError:i.onError}),s())})),a}))(r)),unsubscribe:(0,Qa.W)(e,t)};var r,n}var tc=r(7519);const rc=(0,Io.j)(((e,t)=>Object.assign((async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=Array.isArray(t)?t:[t],s=await e.post("refs",{signal:r.signal,searchParams:(0,So.X)({arg:n.map((e=>`${e instanceof Uint8Array?u.CID.decode(e):e}`)),...r}),headers:r.headers,transform:Yo.C});yield*s.ndjson()}),{local:(0,tc.p)(t)}))),nc=(0,Io.j)((e=>async function*(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("repo/gc",{signal:t.signal,searchParams:(0,So.X)(t),headers:t.headers,transform:e=>({err:e.Error?new Error(e.Error):null,cid:(e.Key||{})["/"]?u.CID.parse(e.Key["/"]):null})});yield*r.ndjson()})),sc=(0,Io.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("repo/stat",{signal:t.signal,searchParams:(0,So.X)(t),headers:t.headers}),n=await r.json();return{numObjects:BigInt(n.NumObjects),repoSize:BigInt(n.RepoSize),repoPath:n.RepoPath,version:n.Version,storageMax:BigInt(n.StorageMax)}})),oc=(0,Io.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await(await e.post("repo/version",{signal:t.signal,searchParams:(0,So.X)(t),headers:t.headers})).json();return r.Version}));function ic(e){return{gc:nc(e),stat:sc(e),version:oc(e)}}const ac=(0,Io.j)((e=>async function*(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("stats/bw",{signal:t.signal,searchParams:(0,So.X)(t),headers:t.headers,transform:e=>({totalIn:BigInt(e.TotalIn),totalOut:BigInt(e.TotalOut),rateIn:parseFloat(e.RateIn),rateOut:parseFloat(e.RateOut)})});yield*r.ndjson()}));function cc(e){return{bitswap:Ro(e),repo:sc(e),bw:ac(e)}}const lc=(0,Io.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("swarm/addrs",{signal:t.signal,searchParams:(0,So.X)(t),headers:t.headers}),{Addrs:n}=await r.json();return Object.keys(n).map((e=>({id:e,addrs:(n[e]||[]).map((e=>new Vt.Multiaddr(e)))})))})),dc=(0,Io.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("swarm/connect",{signal:r.signal,searchParams:(0,So.X)({arg:t,...r}),headers:r.headers}),{Strings:s}=await n.json();return s||[]})),hc=(0,Io.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("swarm/disconnect",{signal:r.signal,searchParams:(0,So.X)({arg:t,...r}),headers:r.headers}),{Strings:s}=await n.json();return s||[]})),uc=(0,Io.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("swarm/addrs/local",{signal:t.signal,searchParams:(0,So.X)(t),headers:t.headers}),{Strings:n}=await r.json();return(n||[]).map((e=>new Vt.Multiaddr(e)))})),pc=(0,Io.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("swarm/peers",{signal:t.signal,searchParams:(0,So.X)(t),headers:t.headers}),{Peers:n}=await r.json();return(n||[]).map((e=>({addr:new Vt.Multiaddr(e.Addr),peer:e.Peer,muxer:e.Muxer,latency:e.Latency,streams:e.Streams,direction:null==e.Direction?void 0:0===e.Direction?"inbound":"outbound"})))}));function fc(e){return{addrs:lc(e),connect:dc(e),disconnect:hc(e),localAddrs:uc(e),peers:pc(e)}}const gc=(0,Io.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=new AbortController,s=Lo(n.signal,r.signal),{headers:o,body:i,total:a,parts:c}=await jo(t,n,r.headers),[l,d]="function"===typeof r.progress?yc(a,c,r.progress):[void 0,void 0],h=await e.post("add",{searchParams:(0,So.X)({"stream-channels":!0,...r,progress:Boolean(l)}),onUploadProgress:d,signal:s,headers:o,body:i});for await(let e of h.ndjson())e=(0,Yo.C)(e),void 0!==e.hash?yield mc(e):l&&l(e.bytes||0,e.name)})),yc=(e,t,r)=>t?[void 0,wc(e,t,r)]:[r,void 0],wc=(e,t,r)=>{let n=0;const s=t.length;return o=>{let{loaded:i,total:a}=o;const c=Math.floor(i/a*e);for(;n<s;){const{start:e,end:s,name:o}=t[n];if(c<s){r(c-e,o);break}r(s-e,o),n+=1}}};function mc(e){let{name:t,hash:r,size:n,mode:s,mtime:o,mtimeNsecs:i}=e;const a={path:t,cid:u.CID.parse(r),size:parseInt(n)};return null!=s&&(a.mode=parseInt(s,8)),null!=o&&(a.mtime={secs:o,nsecs:i||0}),a}function vc(e){const t=gc(e);return(0,Io.j)((()=>async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return await se(t(ur(e),r))}))(e)}const bc=(0,Io.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("cat",{signal:r.signal,searchParams:(0,So.X)({arg:t.toString(),...r}),headers:r.headers});yield*n.iterator()})),_c=(0,Io.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("commands",{signal:t.signal,searchParams:(0,So.X)(t),headers:t.headers});return r.json()})),Ec=(0,Io.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("dns",{signal:r.signal,searchParams:(0,So.X)({arg:t,...r}),headers:r.headers}),s=await n.json();return s.Path})),kc=(0,Io.j)((e=>()=>{const t=new URL(e.opts.base||"");return{host:t.hostname,port:t.port,protocol:t.protocol,pathname:t.pathname,"api-path":t.pathname}})),Ic=(0,Io.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n={arg:`${t instanceof Uint8Array?u.CID.decode(t):t}`,...r};n.compressionLevel&&(n["compression-level"]=n.compressionLevel,delete n.compressionLevel);const s=await e.post("get",{signal:r.signal,searchParams:(0,So.X)(n),headers:r.headers});yield*s.iterator()})),Sc=(0,Io.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("id",{signal:t.signal,searchParams:(0,So.X)({arg:t.peerId?t.peerId.toString():void 0,...t}),headers:t.headers}),n=await r.json(),s={...(0,Yo.C)(n)};return s.addresses&&(s.addresses=s.addresses.map((e=>new Vt.Multiaddr(e)))),s})),Pc=e=>{const t=Sc(e);return async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await t(e);return Boolean(r&&r.addresses&&r.addresses.length)}},Dc=(0,Io.j)(((e,t)=>async function*(r){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const s=`${r instanceof Uint8Array?u.CID.decode(r):r}`;async function o(e){let r=e.Hash;if(r.includes("/")){const e=r.startsWith("/ipfs/")?r:`/ipfs/${r}`;r=(await ji(t)(e)).cid}else r=u.CID.parse(r);const n={name:e.Name,path:s+(e.Name?`/${e.Name}`:""),size:e.Size,cid:r,type:Rc(e)};return e.Mode&&(n.mode=parseInt(e.Mode,8)),void 0!==e.Mtime&&null!==e.Mtime&&(n.mtime={secs:e.Mtime},void 0!==e.MtimeNsecs&&null!==e.MtimeNsecs&&(n.mtime.nsecs=e.MtimeNsecs)),n}const i=await e.post("ls",{signal:n.signal,searchParams:(0,So.X)({arg:s,...n}),headers:n.headers});for await(let e of i.ndjson()){if(e=e.Objects,!e)throw new Error("expected .Objects in results");if(e=e[0],!e)throw new Error("expected one array in results.Objects");const t=e.Links;if(!Array.isArray(t))throw new Error("expected one array in results.Objects[0].Links");if(!t.length)return void(yield o(e));yield*t.map(o)}}));function Rc(e){switch(e.Type){case 1:case 5:return"dir";default:return"file"}}const Cc=(0,Io.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("dns",{signal:t.signal,searchParams:(0,So.X)(t),headers:t.headers});return(0,Yo.C)(await r.json())})),Ac=(0,Io.j)((e=>async function*(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("ping",{signal:r.signal,searchParams:(0,So.X)({arg:`${t}`,...r}),headers:r.headers,transform:Yo.C});yield*n.ndjson()})),Tc=(0,Io.j)((e=>async function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await e.post("resolve",{signal:r.signal,searchParams:(0,So.X)({arg:t,...r}),headers:r.headers}),{Path:s}=await n.json();return s})),Nc=(0,Io.j)((e=>async function(){throw c(new Error("Not implemented"),"ERR_NOT_IMPLEMENTED")})),Oc=(0,Io.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("shutdown",{signal:t.signal,searchParams:(0,So.X)(t),headers:t.headers});await r.text()})),Bc=(0,Io.j)((e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=await e.post("version",{signal:t.signal,searchParams:(0,So.X)(t),headers:t.headers});return{...(0,Yo.C)(await r.json()),"ipfs-http-client":"1.0.0"}}));r(42611),r(88910);var jc=r(62162),xc=r(84856),Lc=r(48402),Mc=r(65967),$c=r(49616);const Uc={func:(e,t)=>ze.validate(t,e)};function Fc(e,t){return ze.select(t[0],t[1])}var zc=r(95067),Wc=r(60403);const Hc=o.Z.bind({ignoreUndefined:!0});function Kc(e){let{options:t={},peerId:r,multiaddrs:o=[],repo:i,keychainConfig:a={},config:l={}}=e;const{datastore:h,keys:u}=i,p=function(e){let{options:t,config:r,datastore:o,keys:i,keychainConfig:a,peerId:l,multiaddrs:h}=e;const u={datastore:o,peerId:l,modules:{}},p={modules:{pubsub:(()=>{const e=nt(r,"Pubsub.Router")||"gossipsub";if(!mo[e])throw c(new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${e} router.`),"ERR_NOT_SUPPORTED");return mo[e]})(),contentRouting:[],peerRouting:[]},config:{peerDiscovery:{mdns:{enabled:nt(t,"config.Discovery.MDNS.Enabled",nt(r,"Discovery.MDNS.Enabled",!0))},webRTCStar:{enabled:nt(t,"config.Discovery.webRTCStar.Enabled",nt(r,"Discovery.webRTCStar.Enabled",!0))},bootstrap:{list:nt(t,"config.Bootstrap",nt(r,"Bootstrap",[]))}},relay:{enabled:nt(t,"relay.enabled",nt(r,"relay.enabled",!0)),hop:{enabled:nt(t,"relay.hop.enabled",nt(r,"relay.hop.enabled",!1)),active:nt(t,"relay.hop.active",nt(r,"relay.hop.active",!1))}},dht:{enabled:"none"!==nt(r,"Routing.Type","dhtclient"),clientMode:"dhtserver"!==nt(r,"Routing.Type","dht"),kBucketSize:nt(t,"dht.kBucketSize",20),validators:{ipns:ze}},pubsub:{enabled:nt(t,"config.Pubsub.Enabled",nt(r,"Pubsub.Enabled",!0))},nat:{enabled:!nt(r,"Swarm.DisableNatPortMap",!1)}},addresses:{listen:h.map((e=>e.toString())),announce:nt(t,"addresses.announce",nt(r,"Addresses.Announce",[])),noAnnounce:nt(t,"addresses.noAnnounce",nt(r,"Addresses.NoAnnounce",[]))},connectionManager:nt(t,"connectionManager",{maxConnections:nt(t,"config.Swarm.ConnMgr.HighWater",nt(r,"Swarm.ConnMgr.HighWater")),minConnections:nt(t,"config.Swarm.ConnMgr.LowWater",nt(r,"Swarm.ConnMgr.LowWater"))}),keychain:{datastore:i,...a},host:{agentVersion:`js-ipfs/${Pr.Pr}`}};let f=nt(t,"libp2p",void 0);"function"===typeof f&&(f=void 0);const g=Hc(u,{dialer:{maxParallelDials:150,maxDialsPerPeer:4,dialTimeout:1e4},modules:{transport:[jc,xc],streamMuxer:[Lc],connEncryption:[Mc.NOISE],peerDiscovery:[],dht:$c,pubsub:wo},config:{peerDiscovery:{autoDial:!0,bootstrap:{enabled:!0},webRTCStar:{enabled:!0}},dht:{kBucketSize:20,enabled:!0,clientMode:!0,validators:{ipns:Uc},selectors:{ipns:Fc}},pubsub:{enabled:!0,emitSelf:!0},nat:{enabled:!1}},metrics:{enabled:!0},peerStore:{persistence:!0}},p,f);nt(g,"config.peerDiscovery.bootstrap.list",[]).length>0&&g.modules.peerDiscovery.push(zc);const y=nt(t,"config.Addresses.Delegates",nt(r,"Addresses.Delegates",[]));if(y.length>0){const e=y[Math.floor(Math.random()*y.length)],t=new Vt.Multiaddr(e).toOptions(),r=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const t={name:N.identity.name,code:N.identity.code,encode:e=>e,decode:e=>e},r=Object.values(O.gh);(e.ipld&&e.ipld.bases?e.ipld.bases:[]).forEach((e=>r.push(e)));const o=new _o.x({bases:r,loadBase:e.ipld&&e.ipld.loadBase}),i=Object.values(O.QB);[d,n,s,T,t].concat(e.ipld&&e.ipld.codecs||[]).forEach((e=>i.push(e)));const a=new Eo.w({codecs:i,loadCodec:e.ipld&&e.ipld.loadCodec}),c=Object.values(O.kq);(e.ipld&&e.ipld.hashers?e.ipld.hashers:[]).forEach((e=>c.push(e)));const l=new ko.d({hashers:c,loadHasher:e.ipld&&e.ipld.loadHasher});return{add:vc(e),addAll:gc(e),bitswap:To(e),block:zo(e),bootstrap:Vo(e),cat:bc(e),commands:_c(e),config:si(e),dag:hi(a,e),dht:vi(e),diag:ki(e),dns:Ec(e),files:Fi(e),get:Ic(e),getEndpointConfig:kc(e),id:Sc(e),isOnline:Pc(e),key:Xi(e),log:Zi(e),ls:Dc(e),mount:Cc(e),name:ia(e),object:ma(a,e),pin:Fa(e),ping:Ac(e),pubsub:ec(e),refs:rc(e),repo:ic(e),resolve:Tc(e),start:Nc(e),stats:cc(e),stop:Oc(e),swarm:fc(e),version:Bc(e),bases:o,codecs:a,hashers:l}}({host:t.host,protocol:443===parseInt(t.port)?"https":"http",port:t.port});p.modules.contentRouting=p.modules.contentRouting||[],p.modules.contentRouting.push(new bo(l,r)),p.modules.peerRouting=p.modules.peerRouting||[],p.modules.peerRouting.push(new vo(r))}return g}({options:t,config:l,datastore:h,keys:u,keychainConfig:a,peerId:r,multiaddrs:o});return"function"===typeof t.libp2p?t.libp2p({libp2pOptions:p,options:t,config:l,datastore:h,peerId:r}):Wc.create(p)}const Gc=o.Z.bind({ignoreUndefined:!0}),qc=a("ipfs:components:peer:storage");class Vc{constructor(e,t,r,n,s){this.print=n,this.peerId=e,this.keychain=t,this.repo=r,this.print=n,this.isNew=s}static async start(e,t,r){const{repoAutoMigrate:n,repo:s,onMigrationProgress:o}=r,i="string"===typeof s||null==s?yo(e,t,{path:s,autoMigrate:n,onMigrationProgress:o}):s,{peerId:a,keychain:c,isNew:l}=await Xc(e,i,r);return new Vc(a,c,i,e,l)}}const Xc=async(e,t,r)=>{if(!t.closed)return{...await el(t,r),isNew:!1};try{return await t.open(),{...await el(t,r),isNew:!1}}catch(n){if(n.code!==Is)throw n;if(r.init&&!1===r.init.allowNew)throw new F("Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it");return{...await Yc(e,t,r),isNew:!0}}},Yc=async(e,t,r)=>{const n=r.init||{},s=await t.exists();if(qc("repo exists?",s),!0===s)throw new Error("repo already exists");const o=n.privateKey?await Jc(n.privateKey):await Qc(e,n),i=Zc(o);qc("peer identity: %s",i.PeerID);const a={...Gc(rl((0,Xt.Z)(),n.profiles),r.config),Identity:i};await t.init(a),await t.open(),qc("repo opened");const c={pass:r.pass};try{c.dek=await t.config.get("Keychain.DEK")}catch(d){if("ERR_NOT_FOUND"!==d.code)throw d}const l=await Kc({options:void 0,multiaddrs:void 0,peerId:o,repo:t,config:a,keychainConfig:c});return l.keychain&&l.keychain.opts&&(await l.loadKeychain(),await t.config.set("Keychain",{DEK:l.keychain.opts.dek})),{peerId:o,keychain:l.keychain}},Jc=e=>(qc("using user-supplied private-key"),"object"===typeof e?e:re.createFromPrivKey((0,z.fromString)(e,"base64pad"))),Qc=(e,t)=>{let{algorithm:r="Ed25519",bits:n=2048}=t;return e("generating %s keypair...",r),re.create({keyType:r,bits:n})},Zc=e=>({PeerID:e.toB58String(),PrivKey:(0,ue.toString)(e.privKey.bytes,"base64pad")}),el=async(e,t)=>{const r=t.config,n=t.init&&t.init.profiles||[],s=t.pass,o=await e.config.getAll(),i=tl(rl(o,n),r);if(o!==i&&await e.config.replace(i),!i.Identity||!i.Identity.PrivKey)throw new j("No private key was found in the config, please intialize the repo");const a=await re.createFromPrivKey(i.Identity.PrivKey),c=await Kc({options:void 0,multiaddrs:void 0,peerId:a,repo:e,config:i,keychainConfig:{pass:s,...i.Keychain}});return c.keychain&&await c.loadKeychain(),{peerId:a,keychain:c.keychain}},tl=(e,t)=>t?Gc(e,t):e,rl=(e,t)=>(t||[]).reduce(((e,t)=>{const r=Ar[t];if(!r)throw new Error(`Could not find profile with name '${t}'`);return qc("applying profile %s",t),r.transform(e)}),e);var nl=r(5717),sl=r(3390),ol=r(81564);const il=(e,t)=>{const r=["bitswap"];return t&&r.push(t),e&&r.push(`${e.toB58String().slice(0,8)}`),Object.assign(a(r.join(":")),{error:a(r.concat(["error"]).join(":"))})},al=(e,t)=>{if(e.size!==t.size)return!1;for(const[r,n]of e){const e=t.get(r);if(void 0===e)return!1;if(n instanceof Uint8Array&&e instanceof Uint8Array&&!(0,pe.equals)(n,e))return!1;if(n instanceof ol.b&&e instanceof ol.b&&!n.equals(e))return!1}return!0};var cl=r(48009);class ll{constructor(e){this.full=e,this.wantlist=new Map,this.blocks=new Map,this.blockPresences=new Map,this.pendingBytes=0}get empty(){return 0===this.blocks.size&&0===this.wantlist.size&&0===this.blockPresences.size}addEntry(e,t,r,n,s){null==r&&(r=ll.WantType.Block);const o=e.toString(st.base58btc),i=this.wantlist.get(o);i?(i.wantType===r&&(i.priority=t),n&&(i.cancel=Boolean(n)),s&&(i.sendDontHave=Boolean(s)),r===ll.WantType.Block&&i.wantType===ll.WantType.Have&&(i.wantType=r)):this.wantlist.set(o,new ol.b(e,t,r,n,s))}addBlock(e,t){const r=e.toString(st.base58btc);this.blocks.set(r,t)}addHave(e){const t=e.toString(st.base58btc);this.blockPresences.has(t)||this.blockPresences.set(t,ll.BlockPresenceType.Have)}addDontHave(e){const t=e.toString(st.base58btc);this.blockPresences.has(t)||this.blockPresences.set(t,ll.BlockPresenceType.DontHave)}cancel(e){const t=e.toString(st.base58btc);this.wantlist.delete(t),this.addEntry(e,0,ll.WantType.Block,!0,!1)}setPendingBytes(e){this.pendingBytes=e}serializeToBitswap100(){const e={wantlist:{entries:Array.from(this.wantlist.values()).map((e=>({block:e.cid.bytes,priority:Number(e.priority),cancel:Boolean(e.cancel)}))),full:!!this.full||void 0},blocks:Array.from(this.blocks.values())};return cl.v.encode(e).finish()}serializeToBitswap110(){const e={wantlist:{entries:Array.from(this.wantlist.values()).map((e=>({block:e.cid.bytes,priority:Number(e.priority),wantType:e.wantType,cancel:Boolean(e.cancel),sendDontHave:Boolean(e.sendDontHave)}))),full:!!this.full||void 0},blockPresences:[],payload:[],pendingBytes:this.pendingBytes};for(const[t,r]of this.blocks.entries()){const n=u.CID.parse(t),s=n.version,o=n.code,i=n.multihash.code,a=n.multihash.digest.length,c=(0,sl.Z)([s,o,i,a]);e.payload.push(new cl.v.Block({prefix:c,data:r}))}for(const[t,r]of this.blockPresences)e.blockPresences.push(new cl.v.BlockPresence({cid:u.CID.parse(t).bytes,type:r}));return this.pendingBytes>0&&(e.pendingBytes=this.pendingBytes),cl.v.encode(e).finish()}equals(e){return!!(this.full===e.full&&this.pendingBytes===e.pendingBytes&&al(this.wantlist,e.wantlist)&&al(this.blocks,e.blocks)&&al(this.blockPresences,e.blockPresences))}get[Symbol.toStringTag](){const e=Array.from(this.wantlist.keys()),t=Array.from(this.blocks.keys());return`BitswapMessage <full: ${this.full}, list: ${e}, blocks: ${t}>`}}ll.deserialize=async(e,t)=>{const r=cl.v.decode(e),n=r.wantlist&&r.wantlist.full||!1,s=new ll(n);return r.wantlist&&r.wantlist.entries&&r.wantlist.entries.forEach((e=>{if(!e.block)return;const t=u.CID.decode(e.block);s.addEntry(t,e.priority||0,e.wantType,Boolean(e.cancel),Boolean(e.sendDontHave))})),r.blockPresences&&r.blockPresences.forEach((e=>{if(!e.cid)return;const t=u.CID.decode(e.cid);e.type===ll.BlockPresenceType.Have?s.addHave(t):s.addDontHave(t)})),r.blocks.length>0?(await Promise.all(r.blocks.map((async e=>{const t=await Vn.sha256.digest(e),r=u.CID.createV0(t);s.addBlock(r,e)}))),s):r.payload.length>0?(await Promise.all(r.payload.map((async e=>{if(!e.prefix||!e.data)return;const r=nl(e.prefix),n=r[0],o=r[1],i=r[2],a=i===Vn.sha256.code?Vn.sha256:t&&await t.getHasher(i);if(!a)throw c(new Error("Unknown hash algorithm"),"ERR_UNKNOWN_HASH_ALG");const l=await a.digest(e.data),d=u.CID.create(n,o,l);s.addBlock(d,e.data)}))),s.setPendingBytes(r.pendingBytes),s):s},ll.blockPresenceSize=e=>e.bytes.length+1,ll.Entry=ol.b,ll.WantType={Block:cl.v.Wantlist.WantType.Block,Have:cl.v.Wantlist.WantType.Have},ll.BlockPresenceType={Have:cl.v.BlockPresenceType.Have,DontHave:cl.v.BlockPresenceType.DontHave};var dl=r(49301);const hl=Math.pow(2,31)-1;var ul=r(88898);class pl{constructor(e,t,r){this.peerId=t,this.network=r,this.refcnt=1,this._entries=[],this._log=il(e,"msgqueue"),this.sendEntries=ul(this._sendEntries.bind(this),1)}addMessage(e){e.empty||this.send(e)}addEntries(e){this._entries=this._entries.concat(e),this.sendEntries()}_sendEntries(){if(!this._entries.length)return;const e=new ll(!1);this._entries.forEach((t=>{t.cancel?e.cancel(t.cid):e.addEntry(t.cid,t.priority)})),this._entries=[],this.addMessage(e)}async send(e){try{await this.network.connectTo(this.peerId)}catch(t){return void this._log.error("cant connect to peer %s: %s",this.peerId.toB58String(),t.message)}this._log("sending message to peer %s",this.peerId.toB58String()),this.network.sendMessage(this.peerId,e).catch((e=>{this._log.error("send error: %s",e.message)}))}}var fl=r(71038);class gl{constructor(e,t,r,n){this.peers=fl({system:"ipfs",component:"bitswap",metric:"want-manager-peers",metrics:n.metrics}),this.wantlist=new dl.m(r,n),this.network=t,this._stats=r,this._peerId=e,this._log=il(e,"want")}_addEntries(e,t,r){const n=e.map(((e,r)=>new ll.Entry(e,hl-r,ll.WantType.Block,t)));n.forEach((e=>{e.cancel?r?this.wantlist.removeForce(e.cid.toString(st.base58btc)):this.wantlist.remove(e.cid):(this._log("adding to wl"),this.wantlist.add(e.cid,e.priority))}));for(const s of this.peers.values())s.addEntries(n)}_startPeerHandler(e){let t=this.peers.get(e.toB58String());if(t)return void t.refcnt++;t=new pl(this._peerId,e,this.network);const r=new ll(!0);for(const n of this.wantlist.entries())r.addEntry(n[1].cid,n[1].priority);return t.addMessage(r),this.peers.set(e.toB58String(),t),t}_stopPeerHandler(e){const t=this.peers.get(e.toB58String());t&&(t.refcnt--,t.refcnt>0||this.peers.delete(e.toB58String()))}wantBlocks(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this._addEntries(e,!1),t&&t.signal&&t.signal.addEventListener("abort",(()=>{this.cancelWants(e)}))}unwantBlocks(e){this._log("unwant blocks: %s",e.length),this._addEntries(e,!0,!0)}cancelWants(e){this._log("cancel wants: %s",e.length),this._addEntries(e,!0)}connectedPeers(){return Array.from(this.peers.keys())}connected(e){this._startPeerHandler(e)}disconnected(e){this._stopPeerHandler(e)}start(){}stop(){this.peers.forEach((e=>this.disconnected(e.peerId)))}}var yl=r(7213),wl=r(90983);const ml="/ipfs/bitswap/1.0.0",vl="/ipfs/bitswap/1.1.0",bl="/ipfs/bitswap/1.2.0";class _l{constructor(e,t,r){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};this._log=il(e.peerId,"network"),this._libp2p=e,this._bitswap=t,this._protocols=[ml],n.b100Only||(this._protocols.unshift(vl),this._protocols.unshift(bl)),this._stats=r,this._running=!1,this._onPeerConnect=this._onPeerConnect.bind(this),this._onPeerDisconnect=this._onPeerDisconnect.bind(this),this._onConnection=this._onConnection.bind(this),this._hashLoader=n.hashLoader}async start(){this._running=!0,await this._libp2p.handle(this._protocols,this._onConnection);const e=new wl({multicodecs:this._protocols,handlers:{onConnect:this._onPeerConnect,onDisconnect:this._onPeerDisconnect}});this._registrarId=await this._libp2p.registrar.register(e);for await(const t of this._libp2p.peerStore.getPeers()){const e=this._libp2p.connectionManager.get(t.id);e&&this._onPeerConnect(e.remotePeer)}}async stop(){this._running=!1,await this._libp2p.unhandle(this._protocols),null!=this._registrarId&&this._libp2p.registrar.unregister(this._registrarId)}async _onConnection(e){let{protocol:t,stream:r,connection:n}=e;if(this._running){this._log("incoming new bitswap %s connection from %s",t,n.remotePeer.toB58String());try{await(0,er.pipe)(r,yl.decode(),(async e=>{for await(const r of e)try{const e=await ll.deserialize(r.slice(),this._hashLoader);await this._bitswap._receiveMessage(n.remotePeer,e)}catch(t){this._bitswap._receiveError(t);break}}))}catch(s){this._log(s)}}}_onPeerConnect(e){this._bitswap._onPeerConnected(e)}_onPeerDisconnect(e){this._bitswap._onPeerDisconnected(e)}findProviders(e,t){return this._libp2p.contentRouting.findProviders(e,{timeout:1e4,maxNumProviders:t})}async findAndConnect(e,t){const r=[];for await(const n of this.findProviders(e,3,t))this._log(`connecting to provider ${n.id}`),r.push(this.connectTo(n.id,t).catch((e=>{this._log.error(e)})));await Promise.all(r)}async provide(e,t){await this._libp2p.contentRouting.provide(e,t)}async sendMessage(e,t){if(!this._running)throw new Error("network isn't running");const r=e.toB58String();this._log("sendMessage to %s",r,t);const n=await this._libp2p.dial(e),{stream:s,protocol:o}=await n.newStream([bl,vl,ml]);let i;switch(o){case ml:i=t.serializeToBitswap100();break;case vl:case bl:i=t.serializeToBitswap110();break;default:throw new Error("Unknown protocol: "+o)}!async function(e,t,r){try{await(0,er.pipe)([t],yl.encode(),e)}catch(n){r(n)}}(s,i,this._log),this._updateSentStats(e,t.blocks)}async connectTo(e,t){if(!this._running)throw new Error("network isn't running");return this._libp2p.dial(e,t)}_updateSentStats(e,t){const r=e.toB58String();if(this._stats){for(const e of t.values())this._stats.push(r,"dataSent",e.length);this._stats.push(r,"blocksSent",t.size)}}}class El{constructor(e){this.partner=e,this.wantlist=new dl.m,this.exchangeCount=0,this.sentToPeer=new Map,this.accounting={bytesSent:0,bytesRecv:0}}sentBytes(e){this.exchangeCount++,this.lastExchange=(new Date).getTime(),this.accounting.bytesSent+=e}receivedBytes(e){this.exchangeCount++,this.lastExchange=(new Date).getTime(),this.accounting.bytesRecv+=e}wants(e,t,r){this.wantlist.add(e,t,r)}cancelWant(e){this.wantlist.remove(e)}wantlistContains(e){return this.wantlist.get(e)}debtRatio(){return this.accounting.bytesSent/(this.accounting.bytesRecv+1)}}class kl extends Map{constructor(e,t){super(),this._cmp=t||this._defaultSort,this._keys=[];for(const[r,n]of e||[])this.set(r,n)}update(e){if(e<0||e>=this._keys.length)return;const t=this._keys[e];this._keys.splice(e,1);const r=this._find(t);this._keys.splice(r,0,t)}set(e,t){if(this.has(e)){const t=this.indexOf(e);this._keys.splice(t,1)}super.set(e,t);const r=this._find(e);return this._keys.splice(r,0,e),this}clear(){super.clear(),this._keys=[]}delete(e){if(!this.has(e))return!1;const t=this.indexOf(e);return this._keys.splice(t,1),super.delete(e)}indexOf(e){if(!this.has(e))return-1;const t=this._find(e);if(this._keys[t]===e)return t;for(let r=1;r<this._keys.length;r++){if(this._keys[t+r]===e)return t+r;if(this._keys[t-r]===e)return t-r}return-1}_find(e){let t=0,r=this._keys.length;for(;t<r;){const n=t+r>>>1,s=this._kCmp(this._keys[n],e);if(s<0)t=n+1;else{if(!(s>0))return n;r=n}}return t}*keys(){for(const e of this._keys)yield e}*values(){for(const e of this._keys)yield this.get(e)}*entries(){for(const e of this._keys)yield[e,this.get(e)]}*[Symbol.iterator](){yield*this.entries()}forEach(e,t){if(e)for(const r of this._keys)e.apply(t,[[r,this.get(r)]])}_defaultSort(e,t){return e[0]<t[0]?-1:t[0]<e[0]?1:0}_kCmp(e,t){return this._cmp([e,this.get(e)],[t,this.get(t)])}}const Il={hasNewInfo:()=>!1,merge(){}};class Sl{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Il;this._taskMerger=e,this._byPeer=new kl([],Pl.compare)}pushTasks(e,t){let r=this._byPeer.get(e.toB58String());r||(r=new Pl(e,this._taskMerger)),r.pushTasks(t),this._byPeer.set(e.toB58String(),r)}popTasks(e){const t=this._head();if(void 0===t)return{tasks:[],pendingSize:0};const{tasks:r,pendingSize:n}=t.popTasks(e);if(0===r.length)return{tasks:r,pendingSize:n};const s=t.peerId;return t.isIdle()?this._byPeer.delete(s.toB58String()):this._byPeer.update(0),{peerId:s,tasks:r,pendingSize:n}}_head(){if(0!==this._byPeer.size)for(const[,e]of this._byPeer)return e}remove(e,t){const r=this._byPeer.get(t.toB58String());r&&r.remove(e)}tasksDone(e,t){const r=this._byPeer.get(e.toB58String());if(!r)return;const n=this._byPeer.indexOf(e.toB58String());for(const s of t)r.taskDone(s);this._byPeer.update(n)}}class Pl{constructor(e,t){this.peerId=e,this._taskMerger=t,this._activeTotalSize=0,this._pending=new Dl,this._active=new Set}pushTasks(e){for(const t of e)this._pushTask(t)}_pushTask(e){if(!this._taskHasMoreInfoThanActiveTasks(e))return;const t=this._pending.get(e.topic);if(t)return e.priority>t.priority&&this._pending.updatePriority(e.topic,e.priority),void this._taskMerger.merge(e,t);this._pending.add(e)}_taskHasMoreInfoThanActiveTasks(e){const t=[];for(const r of this._active)r.topic===e.topic&&t.push(r);return 0===t.length||this._taskMerger.hasNewInfo(e,t)}popTasks(e){let t=0;const r=[],n=this._pending.tasks();for(let s=0;s<n.length&&t<e;s++){const e=n[s];r.push(e),t+=e.size,this._pending.delete(e.topic),this._activeTotalSize+=e.size,this._active.add(e)}return{tasks:r,pendingSize:this._pending.totalSize}}taskDone(e){this._active.has(e)&&(this._activeTotalSize-=e.size,this._active.delete(e))}remove(e){this._pending.delete(e)}isIdle(){return 0===this._pending.length&&0===this._active.size}static compare(e,t){return 0===e[1]._pending.length?1:0===t[1]._pending.length?-1:e[1]._activeTotalSize===t[1]._activeTotalSize?t[1]._pending.length-e[1]._pending.length:e[1]._activeTotalSize-t[1]._activeTotalSize}}class Dl{constructor(){this._tasks=new kl([],this._compare)}get length(){return this._tasks.size}get totalSize(){return[...this._tasks.values()].reduce(((e,t)=>e+t.task.size),0)}get(e){return(this._tasks.get(e)||{}).task}add(e){this._tasks.set(e.topic,{created:Date.now(),task:e})}delete(e){this._tasks.delete(e)}tasks(){return[...this._tasks.values()].map((e=>e.task))}updatePriority(e,t){const r=this._tasks.get(e);if(!r)return;const n=this._tasks.indexOf(e);r.task.priority=t,this._tasks.update(n)}_compare(e,t){return e[1].task.priority===t[1].task.priority?e[1].created-t[1].created:t[1].task.priority-e[1].task.priority}}const Rl={hasNewInfo(e,t){let r=!1,n=!1;for(const s of t)s.data.haveBlock&&(r=!0),s.data.isWantBlock&&(n=!0);return!(n||!e.data.isWantBlock)||!(r||!e.data.haveBlock)},merge(e,t){const r=e.data,n=t.data;!n.haveBlock&&r.haveBlock&&(n.haveBlock=r.haveBlock,n.blockSize=r.blockSize),!n.isWantBlock&&r.isWantBlock&&(n.isWantBlock=!0,n.haveBlock&&!r.haveBlock||(n.haveBlock=r.haveBlock,t.size=e.size)),n.isWantBlock&&n.haveBlock&&(t.size=n.blockSize)}},Cl=ll.WantType;class Al{constructor(e,t,r,n,s){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{};this._log=il(e,"engine"),this.blockstore=t,this.network=r,this._stats=n,this._opts=this._processOpts(o),this.ledgerMap=fl({system:"ipfs",component:"bitswap",metric:"ledger-map",metrics:s.metrics}),this._running=!1,this._requestQueue=new Sl(Rl)}_processOpts(e){return{maxSizeReplaceHasWithBlock:1024,targetMessageSize:16384,...e}}_scheduleProcessTasks(){setTimeout((()=>{this._processTasks()}))}async _processTasks(){if(!this._running)return;const{peerId:e,tasks:t,pendingSize:r}=this._requestQueue.popTasks(this._opts.targetMessageSize);if(0===t.length)return;const n=new ll(!1);n.setPendingBytes(r);const s=[],o=new Map;for(const c of t){const e=u.CID.parse(c.topic);c.data.haveBlock?c.data.isWantBlock?(s.push(e),o.set(c.topic,c.data)):n.addHave(e):n.addDontHave(e)}const i=await this._getBlocks(s);for(const[c,l]of o){const e=u.CID.parse(c),t=i.get(c);t?n.addBlock(e,t):l.sendDontHave&&n.addDontHave(e)}if(n.empty)return e&&this._requestQueue.tasksDone(e,t),void this._scheduleProcessTasks();try{e&&await this.network.sendMessage(e,n);for(const[t,r]of i.entries())e&&this.messageSent(e,u.CID.parse(t),r)}catch(a){this._log.error(a)}e&&this._requestQueue.tasksDone(e,t),this._scheduleProcessTasks()}wantlistForPeer(e){const t=e.toB58String(),r=this.ledgerMap.get(t);return r?r.wantlist.sortedEntries():new Map}ledgerForPeer(e){const t=e.toB58String(),r=this.ledgerMap.get(t);return r?{peer:r.partner,value:r.debtRatio(),sent:r.accounting.bytesSent,recv:r.accounting.bytesRecv,exchanged:r.exchangeCount}:null}peers(){return Array.from(this.ledgerMap.values()).map((e=>e.partner))}receivedBlocks(e){if(e.length){for(const t of this.ledgerMap.values())for(const r of e){const e=t.wantlistContains(r.cid);if(!e)continue;const n=r.data.length,s=this._sendAsBlock(e.wantType,n);let o=n;s||(o=ll.blockPresenceSize(e.cid)),this._requestQueue.pushTasks(t.partner,[{topic:e.cid.toString(st.base58btc),priority:e.priority,size:o,data:{blockSize:n,isWantBlock:s,haveBlock:!0,sendDontHave:!1}}])}this._scheduleProcessTasks()}}async messageReceived(e,t){const r=this._findOrCreate(e);if(t.empty)return;if(t.full&&(r.wantlist=new dl.m),this._updateBlockAccounting(t.blocks,r),0===t.wantlist.size)return void this._scheduleProcessTasks();const n=[],s=[];t.wantlist.forEach((e=>{e.cancel?(r.cancelWant(e.cid),n.push(e.cid)):(r.wants(e.cid,e.priority,e.wantType),s.push(e))})),this._cancelWants(e,n),await this._addWants(e,s),this._scheduleProcessTasks()}_cancelWants(e,t){for(const r of t)this._requestQueue.remove(r.toString(st.base58btc),e)}async _addWants(e,t){const r=await this._getBlockSizes(t.map((e=>e.cid))),n=[];for(const s of t){const t=s.cid.toString(st.base58btc),o=r.get(t);if(null==o)s.sendDontHave&&n.push({topic:t,priority:s.priority,size:ll.blockPresenceSize(s.cid),data:{isWantBlock:s.wantType===Cl.Block,blockSize:0,haveBlock:!1,sendDontHave:s.sendDontHave}});else{const e=this._sendAsBlock(s.wantType,o);let r=o;e||(r=ll.blockPresenceSize(s.cid)),n.push({topic:t,priority:s.priority,size:r,data:{isWantBlock:e,blockSize:o,haveBlock:!0,sendDontHave:s.sendDontHave}})}this._requestQueue.pushTasks(e,n)}}_sendAsBlock(e,t){return e===Cl.Block||t<=this._opts.maxSizeReplaceHasWithBlock}async _getBlockSizes(e){const t=await this._getBlocks(e);return new Map([...t].map((e=>{let[t,r]=e;return[t,r.length]})))}async _getBlocks(e){const t=new Map;return await Promise.all(e.map((async e=>{try{const r=await this.blockstore.get(e);t.set(e.toString(st.base58btc),r)}catch(r){"ERR_NOT_FOUND"!==r.code&&this._log.error("failed to query blockstore for %s: %s",e,r)}}))),t}_updateBlockAccounting(e,t){for(const r of e.values())this._log("got block (%s bytes)",r.length),t.receivedBytes(r.length)}messageSent(e,t,r){const n=this._findOrCreate(e);n.sentBytes(r.length),n.wantlist.remove(t)}numBytesSentTo(e){return this._findOrCreate(e).accounting.bytesSent}numBytesReceivedFrom(e){return this._findOrCreate(e).accounting.bytesRecv}peerDisconnected(e){this.ledgerMap.delete(e.toB58String())}_findOrCreate(e){const t=e.toB58String(),r=this.ledgerMap.get(t);if(r)return r;const n=new El(e);return this.ledgerMap.set(t,n),this._stats&&this._stats.push(t,"peerCount",1),n}start(){this._running=!0}stop(){this._running=!1}}var Tl=r(36571);const Nl=e=>`unwant:${(0,ue.toString)(e.multihash.bytes,"base64")}`,Ol=e=>`block:${(0,ue.toString)(e.multihash.bytes,"base64")}`;class Bl extends Tl.EventEmitter{constructor(e){super(),this.setMaxListeners(1e3),this._log=il(e,"notif")}hasBlock(e,t){const r=Ol(e);this._log(r),this.emit(r,t)}wantBlock(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!e)throw new Error("Not a valid cid");const r=Ol(e),n=Nl(e);return this._log(`wantBlock:${e}`),new Promise(((s,o)=>{const i=()=>{this.removeListener(r,a),o(new Error(`Block for ${e} unwanted`))},a=e=>{this.removeListener(n,i),s(e)};this.once(n,i),this.once(r,a),t&&t.signal&&t.signal.addEventListener("abort",(()=>{this.removeListener(r,a),this.removeListener(n,i),o(new Error(`Want for ${e} aborted`))}))}))}unwantBlock(e){const t=Nl(e);this._log(t),this.emit(t)}}var jl=r(40316);class xl extends Tl.EventEmitter{constructor(e,t){super(),this._options=t,this._queue=[],this._stats={},this._frequencyLastTime=Date.now(),this._frequencyAccumulators={},this._movingAverages={},this._update=this._update.bind(this),e.forEach((e=>{this._stats[e]=BigInt(0),this._movingAverages[e]={},this._options.movingAverageIntervals.forEach((t=>{(this._movingAverages[e][t]=jl(t)).push(this._frequencyLastTime,0)}))})),this._enabled=this._options.enabled}enable(){this._enabled=!0}disable(){this._disabled=!0}stop(){this._timeout&&clearTimeout(this._timeout)}get snapshot(){return Object.assign({},this._stats)}get movingAverages(){return Object.assign({},this._movingAverages)}push(e,t){this._enabled&&(this._queue.push([e,t,Date.now()]),this._resetComputeTimeout())}_resetComputeTimeout(){this._timeout&&clearTimeout(this._timeout),this._timeout=setTimeout(this._update,this._nextTimeout())}_nextTimeout(){const e=this._queue.length/this._options.computeThrottleMaxQueueSize;return Math.max(this._options.computeThrottleTimeout*(1-e),0)}_update(){if(this._timeout=null,this._queue.length){let e;for(;this._queue.length;){const t=e=this._queue.shift();t&&this._applyOp(t)}e&&this._updateFrequency(e[2]),this.emit("update",this._stats)}}_updateFrequency(e){const t=e-this._frequencyLastTime;t&&Object.keys(this._stats).forEach((r=>{this._updateFrequencyFor(r,t,e)})),this._frequencyLastTime=e}_updateFrequencyFor(e,t,r){const n=this._frequencyAccumulators[e]||0;this._frequencyAccumulators[e]=0;const s=n/t*1e3;let o=this._movingAverages[e];o||(o=this._movingAverages[e]={}),this._options.movingAverageIntervals.forEach((e=>{let t=o[e];t||(t=o[e]=jl(e)),t.push(r,s)}))}_applyOp(e){const t=e[0],r=e[1];if("number"!==typeof r)throw new Error(`invalid increment number: ${r}`);Object.prototype.hasOwnProperty.call(this._stats,t)||(this._stats[t]=BigInt(0)),this._stats[t]=BigInt(this._stats[t])+BigInt(r),this._frequencyAccumulators[t]||(this._frequencyAccumulators[t]=0),this._frequencyAccumulators[t]+=r}}const Ll={enabled:!1,computeThrottleTimeout:1e3,computeThrottleMaxQueueSize:1e3,movingAverageIntervals:[6e4,3e5,9e5]};class Ml extends Tl.EventEmitter{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Ll;super();const n=Object.assign({},Ll,r);if("number"!==typeof n.computeThrottleTimeout)throw new Error("need computeThrottleTimeout");if("number"!==typeof n.computeThrottleMaxQueueSize)throw new Error("need computeThrottleMaxQueueSize");this._initialCounters=t,this._options=n,this._enabled=this._options.enabled,this._global=new xl(t,n),this._global.on("update",(e=>this.emit("update",e))),this._peers=fl({system:"ipfs",component:"bitswap",metric:"stats-peers",metrics:e.metrics})}enable(){this._enabled=!0,this._options.enabled=!0,this._global.enable()}disable(){this._enabled=!1,this._options.enabled=!1,this._global.disable()}stop(){this._enabled=!1,this._global.stop();for(const e of this._peers)e[1].stop()}get snapshot(){return this._global.snapshot}get movingAverages(){return this._global.movingAverages}forPeer(e){const t="string"!==typeof e&&e.toB58String?e.toB58String():`${e}`;return this._peers.get(t)}push(e,t,r){if(this._enabled&&(this._global.push(t,r),e)){let n=this._peers.get(e);n||(n=new xl(this._initialCounters,this._options),this._peers.set(e,n)),n.push(t,r)}}disconnected(e){const t=e.toB58String(),r=this._peers.get(t);r&&(r.stop(),this._peers.delete(t))}}const $l={statsEnabled:!1,statsComputeThrottleTimeout:1e3,statsComputeThrottleMaxQueueSize:1e3},Ul=["blocksReceived","dataReceived","dupBlksReceived","dupDataReceived","blocksSent","dataSent","providesBufferLength","wantListLength","peerCount"];class Fl extends ho.E{constructor(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};super(),this._libp2p=e,this._log=il(this.peerId),this._options=Object.assign({},$l,r),this._stats=new Ml(e,Ul,{enabled:this._options.statsEnabled,computeThrottleTimeout:this._options.statsComputeThrottleTimeout,computeThrottleMaxQueueSize:this._options.statsComputeThrottleMaxQueueSize}),this.network=new _l(e,this,this._stats,{hashLoader:r.hashLoader}),this.blockstore=t,this.engine=new Al(this.peerId,t,this.network,this._stats,e),this.wm=new gl(this.peerId,this.network,this._stats,e),this.notifications=new Bl(this.peerId),this.started=!1}isStarted(){return this.started}get peerId(){return this._libp2p.peerId}async _receiveMessage(e,t){try{await this.engine.messageReceived(e,t)}catch(n){this._log("failed to receive message",t)}if(0===t.blocks.size)return;const r=[];for(const[s,o]of t.blocks.entries()){const e=u.CID.parse(s);r.push({wasWanted:this.wm.wantlist.contains(e),cid:e,data:o})}this.wm.cancelWants(r.filter((e=>{let{wasWanted:t}=e;return t})).map((e=>{let{cid:t}=e;return t}))),await Promise.all(r.map((t=>{let{cid:r,wasWanted:n,data:s}=t;return this._handleReceivedBlock(e,r,s,n)})))}async _handleReceivedBlock(e,t,r,n){this._log("received block");const s=await this.blockstore.has(t);this._updateReceiveCounters(e.toB58String(),t,r,s),n&&await this.put(t,r)}_updateReceiveCounters(e,t,r,n){this._stats.push(e,"blocksReceived",1),this._stats.push(e,"dataReceived",r.length),n&&(this._stats.push(e,"dupBlksReceived",1),this._stats.push(e,"dupDataReceived",r.length))}_receiveError(e){this._log.error("ReceiveError: %s",e.message)}_onPeerConnected(e){this.wm.connected(e)}_onPeerDisconnected(e){this.wm.disconnected(e),this.engine.peerDisconnected(e),this._stats.disconnected(e)}enableStats(){this._stats.enable()}disableStats(){this._stats.disable()}wantlistForPeer(e,t){return this.engine.wantlistForPeer(e)}ledgerForPeer(e){return this.engine.ledgerForPeer(e)}async get(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const r=(e,t)=>(this.wm.wantBlocks([e],t),this.notifications.wantBlock(e,t));let n=!1;const s=new AbortController,o=t.signal?(0,jt.anySignal)([t.signal,s.signal]):s.signal,i=await Promise.race([this.notifications.wantBlock(e,{signal:o}),(async(e,t)=>{try{return await this.blockstore.get(e,t)}catch(s){if("ERR_NOT_FOUND"!==s.code)throw s;return n||(n=!0,this.network.findAndConnect(e).catch((e=>this._log.error(e)))),r(e,t)}})(e,{signal:o})]);return s.abort(),i}async*getMany(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};for await(const r of e)yield this.get(r,t)}unwant(e){const t=Array.isArray(e)?e:[e];this.wm.unwantBlocks(t),t.forEach((e=>this.notifications.unwantBlock(e)))}cancelWants(e){this.wm.cancelWants(Array.isArray(e)?e:[e])}async put(e,t,r){await this.blockstore.put(e,t),this._sendHaveBlockNotifications(e,t)}async*putMany(e,t){for await(const{key:r,value:n}of this.blockstore.putMany(e,t))this._sendHaveBlockNotifications(r,n),yield{key:r,value:n}}_sendHaveBlockNotifications(e,t){this.notifications.hasBlock(e,t),this.engine.receivedBlocks([{cid:e,data:t}]),this.network.provide(e).catch((e=>{this._log.error("Failed to provide: %s",e.message)}))}getWantlist(){return this.wm.wantlist.entries()}peers(){return this.engine.peers()}stat(){return this._stats}async start(){this.wm.start(),await this.network.start(),this.engine.start(),this.started=!0}async stop(){this._stats.stop(),this.wm.stop(),await this.network.stop(),this.engine.stop(),this.started=!1}unwrap(){return this.blockstore}}var zl=r(8266);r(37464);class Wl extends ho.E{constructor(e,t){super(),this.child=e,this.bitswap=t}open(){return this.child.open()}close(){return this.child.close()}unwrap(){return this.child}async put(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};await this.has(e)||(this.bitswap.isStarted()?await this.bitswap.put(e,t,r):await this.child.put(e,t,r))}async*putMany(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const r=Zt(e,(async e=>{let{key:t}=e;return!await this.has(t)}));this.bitswap.isStarted()?yield*this.bitswap.putMany(r,t):yield*this.child.putMany(r,t)}async get(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return!await this.has(e)&&this.bitswap.isStarted()?this.bitswap.get(e,t):this.child.get(e,t)}async*getMany(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const r=js(),n=js();Promise.resolve().then((async()=>{for await(const t of e)!await this.has(t)&&this.bitswap.isStarted()?r.push(t):n.push(t);r.end(),n.end()})),yield*Js(this.bitswap.getMany(r,t),this.child.getMany(n,t))}async delete(e,t){await this.child.delete(e,t)}async*deleteMany(e,t){yield*this.child.deleteMany(e,t)}async has(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.child.has(e,t)}async*query(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};yield*this.child.query(e,t)}async*queryKeys(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};yield*this.child.queryKeys(e,t)}}class Hl{constructor(e,t,r,n,s){this.peerId=e,this.libp2p=t,this.bitswap=r,this.repo=n,this.blockstore=s}static async start(e){let{peerId:t,repo:r,print:n,hashers:s,options:o}=e;r.closed&&await r.open();const i=await r.config.getAll(),a=await Kc({options:o,repo:r,peerId:t,multiaddrs:Kl(t,i),config:i,keychainConfig:void 0});a.keychain&&await a.loadKeychain(),await a.start();for(const d of a.multiaddrs)n(`Swarm listening on ${d}/p2p/${t.toB58String()}`);const c=function(e,t){return new Fl(e,t,arguments.length>2&&void 0!==arguments[2]?arguments[2]:{})}(a,r.blocks,{statsEnabled:!0,hashLoader:s});await c.start();const l=new Wl(r.blocks,c);return r.blocks=l,r.pins.blockstore=l,new Hl(t,a,c,r,l)}static async stop(e){e.repo.blocks=e.blockstore.unwrap(),e.repo.pins.blockstore=e.blockstore.unwrap(),await e.bitswap.stop(),await e.libp2p.stop()}}const Kl=(e,t)=>{const r=e.toB58String(),n=[],s=t.Addresses&&t.Addresses.Swarm||[];for(const o of s){let e=new Vt.Multiaddr(o);if(e.protoCodes().includes(Gl))throw c(new Error("websocket-star swarm addresses are not supported. See https://github.com/ipfs/js-ipfs/issues/2779"),"ERR_WEBSOCKET_STAR_SWARM_ADDR_NOT_SUPPORTED");const t=e.getPeerId();t&&t!==r&&(e=e.encapsulate(`/p2p/${r}`)),n.push(e)}return n},Gl=479;class ql{constructor(e){let{network:t}=e;this.addrs=function(e){let{network:t}=e;return(0,Q.a)((async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=[],{libp2p:n}=await t.use(e);for await(const t of n.peerStore.getPeers())r.push({id:t.id.toB58String(),addrs:t.addresses.map((e=>e.multiaddr))});return r}))}({network:t}),this.connect=function(e){let{network:t}=e;return(0,Q.a)((async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{libp2p:n}=await t.use(r);await n.dial(e,r)}))}({network:t}),this.disconnect=function(e){let{network:t}=e;return(0,Q.a)((async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{libp2p:n}=await t.use(r);await n.hangUp(e)}))}({network:t}),this.localAddrs=function(e){let{network:t}=e;return(0,Q.a)((async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{libp2p:r}=await t.use(e);return r.multiaddrs}))}({network:t}),this.peers=function(e){let{network:t}=e;return(0,Q.a)((async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{libp2p:r}=await t.use(e),n=[];for(const[t,s]of r.connections)for(const r of s){const s={addr:r.remoteAddr,peer:t};(e.verbose||e.direction)&&(s.direction=r.stat.direction),e.verbose&&(s.muxer=r.stat.multiplexer,s.latency="n/a",s.streams=[]),n.push(s)}return n}))}({network:t})}}const Vl={success:!0,time:0,text:""};const Xl="/ipns/";function Yl(e){let t;if(e.startsWith(Xl)&&(e=e.substring(Xl.length)),"1"!==e[0]&&"Q"!==e[0]||(e=`z${e}`),"z"===e[0]&&(t=st.base58btc.decode(e)),"k"===e[0]&&(t=Pt.base36.decode(e)),!t)throw new Error("Could not parse string");if(1!==t[0]&&114!==t[1]&&(t=(0,me.concat)([[1,114],t])),40!==t.length)throw new Error("Incorrect length "+t.length);return(0,me.concat)([(0,z.fromString)(Xl),t.subarray(2)])}function Jl(e){if("SENDING_QUERY"===e.name)return{type:e.type,name:e.name,to:e.to.toB58String()};if("PEER_RESPONSE"===e.name)return{type:e.type,name:e.name,messageType:e.messageType,messageName:e.messageName,closer:e.closer.map((e=>{let{id:t,multiaddrs:r}=e;return{id:t.toB58String(),multiaddrs:r}})),providers:e.providers.map((e=>{let{id:t,multiaddrs:r}=e;return{id:t.toB58String(),multiaddrs:r}})),record:e.record,from:e.from.toB58String()};if("FINAL_PEER"===e.name)return{type:e.type,name:e.name,from:e.from.toB58String(),peer:{id:e.peer.id.toB58String(),multiaddrs:e.peer.multiaddrs}};if("QUERY_ERROR"===e.name)return{type:e.type,name:e.name,error:e.error,from:e.from.toB58String()};if("PROVIDER"===e.name)return{type:e.type,name:e.name,providers:e.providers.map((e=>{let{id:t,multiaddrs:r}=e;return{id:t.toB58String(),multiaddrs:r}})),from:e.from.toB58String()};if("VALUE"===e.name)return{type:e.type,name:e.name,value:e.value,from:e.from.toB58String()};if("ADDING_PEER"===e.name)return{type:e.type,name:e.name,peer:e.peer.toB58String()};if("DIALING_PEER"===e.name)return{type:e.type,name:e.name,peer:e.peer.toB58String()};throw c(new Error("Unknown DHT event type"),"ERR_UNKNOWN_DHT_EVENT")}const Ql=async(e,t,r)=>{const n=await e.use(r);if(nt(n.libp2p,"_config.dht.enabled",!1))return n;{const e=async function*(){yield{from:t,name:"QUERY_ERROR",type:3,error:new F("dht not enabled")}};return{libp2p:{_dht:{get:e,put:e,findProvs:e,findPeer:e,provide:e,query:e}}}}};const Zl=async()=>{throw new F("pubsub not enabled")},ed=o.Z.bind({ignoreUndefined:!0}),td=Object.assign(a("ipfs"),{error:a("ipfs:error")});class rd{constructor(e){let{print:t,storage:r,codecs:n,options:s}=e;const{peerId:o,repo:i,keychain:a}=r,l=H.create(Hl),d=kn(s.preload),h=(0,Q.a)((async function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{recursive:!0};if("string"!==typeof e)throw new Error("Invalid arguments, domain must be a string");return J(e=Z(e),t)})),p=(0,ee.X)({network:l}),f=new _t(s),g=Object.values(O.kq);(s.ipld&&s.ipld.hashers?s.ipld.hashers:[]).forEach((e=>g.push(e))),this.hashers=new ko.d({hashers:g,loadHasher:s.ipld&&s.ipld.loadHasher});const y=Object.values(O.gh);(s.ipld&&s.ipld.bases?s.ipld.bases:[]).forEach((e=>y.push(e))),this.bases=new _o.x({bases:y,loadBase:s.ipld&&s.ipld.loadBase});const w=new le({repo:i,codecs:n}),m=new rr({codecs:n,hashers:this.hashers,preload:d,repo:i}),v=new Ot({dns:h,ipns:f,repo:i,codecs:n,peerId:o,isOnline:p,keychain:a,options:s}),b=function(e){let{repo:t,codecs:r,bases:n,name:s}=e;return(0,Q.a)((async function(e){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!te.path(e))throw new Error("invalid argument "+e);if(te.ipnsPath(e))for await(const t of s.resolve(e,o))e=t;const[,i,a,...c]=e.split("/"),l=o.cidBase?await n.getBase(o.cidBase):void 0,d=ne(a);if(0===c.length)return`/${i}/${l?l.encoder.encode(d):a}`;const h=u.CID.decode(d);e=c.join("/");const p=(0,W.DB)(h,e,r,t,o);let f=h,g=e;for await(const t of p)u.CID.asCID(t.value)&&(f=t.value,g=t.remainderPath);return`/ipfs/${f.toString(l&&l.encoder)}${g?"/"+g:""}`}))}({repo:i,codecs:n,bases:this.bases,name:v}),_=new yn({repo:i,codecs:n,hashers:this.hashers,preload:d}),E=Object.assign(function(e){let{repo:t,codecs:r,resolve:n,preload:s}=e;return async function*(e){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(0===o.maxDepth)return;if(o.edges&&o.format&&o.format!==Lt)throw new Error("Cannot set edges to true and also specify format");if(o.format=o.edges?Mt:o.format,"number"!==typeof o.maxDepth&&(o.maxDepth=o.recursive?1/0:1),o.timeout){const e=[new Bt.TimeoutController(o.timeout).signal];o.signal&&e.push(o.signal),o.signal=(0,jt.anySignal)(e)}const i=(Array.isArray(e)?e:[e]).map((e=>$t(s,e,o)));for(const s of i)try{yield*Ut(n,t,r,s,o)}catch(a){yield{ref:"",err:a.message}}}}({repo:i,codecs:n,resolve:b,preload:d}),{local:Wt({repo:r.repo})}),{add:k,addAll:I,cat:S,get:P,ls:D}=new Sr({preload:d,repo:i,options:s.EXPERIMENTAL,hashers:this.hashers}),R=zn({repo:i,preload:d,hashers:this.hashers,options:s}),C=function(e){let{preload:t,files:r,options:n={}}=e;if(n.interval=n.interval||3e4,!n.enabled){In("MFS preload disabled");const e=async()=>{};return{start:e,stop:e}}let s,o="";const i=async()=>{try{const e=await r.stat("/"),a=e.cid.toString();o!==a&&(In(`preloading updated MFS root ${o} -> ${e.cid}`),await t(e.cid),o=a)}catch(e){In.error("failed to preload MFS root",e)}finally{s=setTimeout(i,n.interval)}};return{async start(){const e=await r.stat("/");o=e.cid.toString(),In(`monitoring MFS root ${e.cid}`),s=setTimeout(i,n.interval)},stop(){clearTimeout(s)}}}({files:R,preload:d,options:s.preload});this.preload=d,this.name=v,this.ipns=f,this.pin=w,this.resolve=b,this.block=m,this.refs=E,this.start=function(e){let{network:t,preload:r,peerId:n,keychain:s,repo:o,ipns:i,mfsPreload:a,print:c,hashers:l,options:d}=e;return async()=>{const{libp2p:e}=await H.start(t,{peerId:n,repo:o,print:c,hashers:l,options:d});await Promise.all([i.startOnline({keychain:s,libp2p:e,peerId:n,repo:o}),r.start(),a.start()])}}({network:l,peerId:o,repo:i,preload:d,ipns:f,mfsPreload:C,print:t,keychain:a,hashers:this.hashers,options:s}),this.stop=function(e){let{network:t,preload:r,ipns:n,repo:s,mfsPreload:o}=e;return async()=>{await Promise.all([r.stop(),n.stop(),o.stop()]),await H.stop(t),await s.close()}}({network:l,preload:d,mfsPreload:C,ipns:f,repo:i}),this.dht=function(e){let{network:t,repo:r,peerId:n}=e;const{get:s,put:o,findProvs:i,findPeer:a,provide:l,query:d}={async*get(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{libp2p:s}=await Ql(t,n,r),o=e instanceof Uint8Array?e:Yl(e);yield*Qt(s._dht.get(o,r),Jl)},async*put(e,r,s){const{libp2p:o}=await Ql(t,n,s),i=e instanceof Uint8Array?e:Yl(e);yield*Qt(o._dht.put(i,r),Jl)},async*findProvs(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{libp2p:s}=await Ql(t,n,r);yield*Qt(s._dht.findProviders(e,{signal:r.signal}),Jl)},async*findPeer(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{libp2p:s}=await Ql(t,n,r);yield*Qt(s._dht.findPeer(re.parse(e),{signal:r.signal}),Jl)},async*provide(e){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{recursive:!1};const{libp2p:o}=await Ql(t,n,s);if(!await r.blocks.has(e))throw c(new Error("block(s) not found locally, cannot provide"),"ERR_BLOCK_NOT_FOUND");if(s.recursive)throw c(new Error("not implemented yet"),"ERR_NOT_IMPLEMENTED_YET");yield*Qt(o._dht.provide(e),Jl)},async*query(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{libp2p:s}=await Ql(t,n,r);let o;const i=u.CID.asCID(e);o=null!=i?i.multihash.bytes:re.parse(e.toString()).toBytes(),yield*Qt(s._dht.getClosestPeers(o,r),Jl)}};return{get:(0,Q.a)(s),put:(0,Q.a)(o),findProvs:(0,Q.a)(i),findPeer:(0,Q.a)(a),provide:(0,Q.a)(l),query:(0,Q.a)(d)}}({network:l,repo:i,peerId:o}),this.pubsub=function(e){let{network:t,config:r}=e;const n=nt(r||{},"Pubsub.Enabled",!0);return{subscribe:n?(0,Q.a)((async function(e,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{libp2p:s}=await t.use(n);return s.pubsub.subscribe(e,r,n)})):Zl,unsubscribe:n?(0,Q.a)((async function(e,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{libp2p:s}=await t.use(n);s.pubsub.unsubscribe(e,r,n)})):Zl,publish:n?(0,Q.a)((async function(e,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{libp2p:s}=await t.use(n);if(!r)throw c(new Error('argument "data" is required'),"ERR_ARG_REQUIRED");await s.pubsub.publish(e,r)})):Zl,ls:n?(0,Q.a)((async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{libp2p:r}=await t.use(e);return r.pubsub.getTopics()})):Zl,peers:n?(0,Q.a)((async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{libp2p:n}=await t.use(r);return n.pubsub.getSubscribers(e)})):Zl}}({network:l,config:s.config}),this.dns=h,this.isOnline=p,this.id=function(e){let{peerId:t,network:r}=e;return(0,Q.a)((async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n=r.try();if(!n){if(e.peerId)throw new M;return{id:t.toB58String(),publicKey:(0,ue.toString)(t.pubKey.bytes,"base64pad"),addresses:[],agentVersion:`js-ipfs/${Pr.Pr}`,protocolVersion:"9000",protocols:[]}}const{libp2p:s}=n,o=e.peerId?re.parse(e.peerId):t,i=await Rr(o,s,e),a=(0,ue.toString)(i.metadata.get("AgentVersion")||new Uint8Array),c=(0,ue.toString)(i.metadata.get("ProtocolVersion")||new Uint8Array),l=i.id.toB58String(),d=i.publicKey?(0,ue.toString)(i.publicKey.bytes,"base64pad"):"";return{id:l,publicKey:d,addresses:(i.addresses||[]).map((e=>{const t=e.toString();return t.endsWith(`/p2p/${l}`)?t:`${t}/p2p/${l}`})).sort().map((e=>new Vt.Multiaddr(e))),agentVersion:a,protocolVersion:c,protocols:(i.protocols||[]).sort()}}))}({network:l,peerId:o}),this.version=function(e){let{repo:t}=e;return(0,Q.a)((async function(){const e=await t.version.get();return{version:Pr.Pr,commit:Pr.th,repo:`${e}`,"ipfs-core":Pr.Pr,"interface-ipfs-core":Pr.Px}}))}({repo:i}),this.bitswap=new Kt({network:l}),this.bootstrap=new Yt({repo:i}),this.config=function(e){let{repo:t}=e;return{getAll:(0,Q.a)((async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.config.getAll(e)})),get:(0,Q.a)((async function(e,r){return e?t.config.get(e,r):Promise.reject(new Error("key argument is required"))})),set:(0,Q.a)((async function(e,r,n){return t.config.set(e,r,n)})),replace:(0,Q.a)((async function(e,r){return t.config.replace(e,r)})),profiles:{apply:(0,Q.a)((async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{dryRun:!1};const{dryRun:n}=r,s=Ar[e];if(!s)throw new Error(`No profile with name '${e}' exists`);try{const e=await t.config.getAll(r);let o=JSON.parse(JSON.stringify(e));return o=s.transform(o),n||await t.config.replace(o,r),delete e.Identity.PrivKey,delete o.Identity.PrivKey,{original:e,updated:o}}catch(o){throw Tr(o),new Error(`Could not apply profile '${e}' to config: ${o.message}`)}})),list:(0,Q.a)(Nr)}}}({repo:i}),this.ping=function(e){let{network:t}=e;return(0,Q.a)((async function*(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{libp2p:n}=await t.use();r.count=r.count||10;const s=re.createFromB58String(e),o=await n.peerStore.get(s);let i=o&&o.id;if(!i){yield{...Vl,text:`Looking up peer ${e}`};const t=await n.peerRouting.findPeer(s);i=t&&t.id}if(!i)throw new Error("Peer was not found");yield{...Vl,text:`PING ${i.toB58String()}`};let a=0,c=0;for(let t=0;t<r.count;t++)try{const e=await n.ping(i);c+=e,a++,yield{...Vl,time:e}}catch(l){yield{...Vl,success:!1,text:l.toString()}}if(a){const e=c/a;yield{...Vl,text:`Average latency: ${e}ms`}}}))}({network:l}),this.add=k,this.addAll=I,this.cat=S,this.get=P,this.ls=D,this.dag=_,this.files=R,this.key=new Kn({keychain:a}),this.object=new Jn({preload:d,codecs:n,repo:i}),this.repo=new rs({repo:i,hashers:this.hashers}),this.stats=new ss({repo:i,network:l}),this.swarm=new ql({network:l}),Object.defineProperty(this,"libp2p",{get(){const e=l.try();return e?e.libp2p:void 0}});const A=()=>Promise.reject(c(new Error("Not implemented"),"ERR_NOT_IMPLEMENTED"));this.commands=A,this.diag={cmds:A,net:A,sys:A},this.log={level:A,ls:A,tail:async function*(){throw c(new Error("Not implemented"),"ERR_NOT_IMPLEMENTED")}},this.mount=A,this.codecs=n}async init(){throw new L}}const nd=async e=>{const t=d.encode({Data:new l.fL({type:"directory"}).marshal(),Links:[]}),r=await e.block.put(t,{mhtype:"sha2-256",format:"dag-pb"});return await e.pin.add(r),r},sd=()=>({start:!0,EXPERIMENTAL:{},preload:{enabled:!i.isTest,addresses:["/dns4/node0.preload.ipfs.io/https","/dns4/node1.preload.ipfs.io/https","/dns4/node2.preload.ipfs.io/https","/dns4/node3.preload.ipfs.io/https"]}});r(64009);const od=async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};e=ed(sd(),e);const t=e.init||{},r={name:N.identity.name,code:N.identity.code,encode:e=>e,decode:e=>e},o=Object.values(O.QB);[d,n,s,T,r].concat(e.ipld&&e.ipld.codecs||[]).forEach((e=>o.push(e)));const i=new Eo.w({codecs:o,loadCodec:e.ipld&&e.ipld.loadCodec}),a=e.silent?td:console.log;td("creating repo");const c=await Vc.start(a,i,e);td("getting repo config");const l=await c.repo.config.getAll(),h=new rd({storage:c,print:a,codecs:i,options:{...e,config:l}});if(td("starting preload"),await h.preload.start(),td("starting storage"),h.ipns.startOffline(c),c.isNew&&!t.emptyRepo){const e=await nd(h);td("adding default assets"),await(0,B.L)({addAll:h.addAll,print:a}),td("initializing IPNS keyspace"),await h.ipns.initializeKeyspace(c.peerId.privKey,(0,z.fromString)(`/ipfs/${e}`))}return!1!==e.start&&(td("starting node"),await h.start()),h},id=te},97085:(e,t,r)=>{"use strict";r.d(t,{AH:()=>p,DB:()=>m,Fb:()=>w,JU:()=>f,Nt:()=>h,i3:()=>g,iJ:()=>u,jr:()=>y,yH:()=>d});var n=r(13380),s=r(32743),o=r(82149),i=r(15504),a=r(41048),c=r(7901),l=r(47922);const d="This command must be run in online mode. Try running 'ipfs daemon' first.",h=new o.Key("/local/filesroot"),u=262144,p=e=>{if(s.CID.asCID(e))return`/ipfs/${e}`;const t=e.toString();try{return`/ipfs/${s.CID.parse(t)}`}catch{}if(n.path(t))return t;throw i(new Error(`invalid path: ${e}`),"ERR_BAD_PATH")},f=e=>e instanceof Uint8Array?s.CID.decode(e).toString():(0===(e=e.toString()).indexOf("/ipfs/")&&(e=e.substring("/ipfs/".length)),"/"===e.charAt(e.length-1)&&(e=e.substring(0,e.length-1)),e),g=async function(e,t,r){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const{cid:o,path:i}=(0,c.B)(r);i&&(n.path=i);let a=o,l=n.path||"";if(l.startsWith("/")&&(l=l.substring(1)),n.path)try{for await(const{value:r,remainderPath:i}of m(o,n.path,t,e,{signal:n.signal})){if(!s.CID.asCID(r))break;l=i,a=r}}catch(d){throw d.message.startsWith("Object has no property")&&(d.message=`no link named "${l.split("/")[0]}" under ${a}`,d.code="ERR_NO_LINK"),d}return{cid:a,remainderPath:l||""}},y=e=>{if("file"!==e.type&&"directory"!==e.type&&"raw"!==e.type)throw new Error(`Unknown node type '${e.type}'`);const t={cid:e.cid,path:e.path,name:e.name,size:e.size,type:"file"};return"directory"===e.type&&(t.type="dir"),"file"===e.type&&(t.size=e.unixfs.fileSize()),"file"!==e.type&&"directory"!==e.type||(t.mode=e.unixfs.mode,void 0!==e.unixfs.mtime&&(t.mtime=e.unixfs.mtime)),t},w=(0,a.a)((async(e,t)=>await e)),m=async function*(e,t,r,n,o){const a=async e=>{const t=await r.getCodec(e.code),s=await n.blocks.get(e,o);return t.decode(s)},c=t.split("/").filter(Boolean);let d=await a(e),h=e;for(;c.length;){const r=c.shift();if(!r)throw i(new Error(`Could not resolve path "${t}"`),"ERR_INVALID_PATH");if(e.code===l.code&&Array.isArray(d.Links)){const e=d.Links.find((e=>e.Name===r));if(e){yield{value:e.Hash,remainderPath:c.join("/")},d=await a(e.Hash),h=e.Hash;continue}}if(!Object.prototype.hasOwnProperty.call(d,r))throw i(new Error(`no link named "${r}" under ${h}`),"ERR_NO_LINK");d=d[r],yield{value:d,remainderPath:c.join("/")},s.CID.asCID(d)&&(h=d,d=await a(d))}yield{value:d,remainderPath:""}}},70732:(e,t,r)=>{"use strict";r.d(t,{j:()=>s});var n=r(44190);const s=e=>t=>e(new n.KU(t),t)},44190:(e,t,r)=>{"use strict";r.d(t,{KU:()=>v});var n=r(10006),s=r(41257),o=r(73620),i=r(60720),a=r(68170),c=r(664),l=r(62414),d=r(10912);const h=i("ipfs-http-client:lib:error-handler"),u=c.Z.bind({ignoreUndefined:!0}),p=s.isBrowser||s.isWebWorker?location.protocol:"http",f=s.isBrowser||s.isWebWorker?location.hostname:"localhost",g=s.isBrowser||s.isWebWorker?location.port:"5001",y=async e=>{let t;try{if((e.headers.get("Content-Type")||"").startsWith("application/json")){const r=await e.json();h(r),t=r.Message||r.message}else t=await e.text()}catch(n){h("Failed to parse error response",n),t=n.message}let r=new a.HTTPError(e);throw t&&(t.includes("deadline has elapsed")&&(r=new a.TimeoutError),t&&t.includes("context deadline exceeded")&&(r=new a.TimeoutError)),t&&t.includes("request timed out")&&(r=new a.TimeoutError),t&&(r.message=t),r},w=/[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g,m=e=>e.replace(w,(function(e){return"-"+e.toLowerCase()}));class v extends a{constructor(){var e;const t=function(){let e,t,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},o={};if("string"===typeof r||n.Multiaddr.isMultiaddr(r))e=new URL((0,l.d)(r));else if(r instanceof URL)e=r;else if("string"===typeof r.url||n.Multiaddr.isMultiaddr(r.url))e=new URL((0,l.d)(r.url)),o=r;else if(r.url instanceof URL)e=r.url,o=r;else{o=r||{};const t=(o.protocol||p).replace(":",""),n=(o.host||f).split(":")[0],s=o.port||g;e=new URL(`${t}://${n}:${s}`)}if(o.apiPath?e.pathname=o.apiPath:"/"!==e.pathname&&void 0!==e.pathname||(e.pathname="api/v0"),s.isNode){const r=(0,d.Z)(e);t=o.agent||new r({keepAlive:!0,maxSockets:6})}return{...o,host:e.host,protocol:e.protocol.replace(":",""),port:Number(e.port),apiPath:e.pathname,url:e,agent:t}}(arguments.length>0&&void 0!==arguments[0]?arguments[0]:{});var r;super({timeout:(r=t.timeout||0,("string"===typeof r?(0,o.Z)(r):r)||void 0),headers:t.headers,base:`${t.url}`,handleError:y,transformSearchParams:e=>{const t=new URLSearchParams;for(const[r,n]of e)"undefined"!==n&&"null"!==n&&"signal"!==r&&t.append(m(r),n),"timeout"!==r||isNaN(n)||t.append(m(r),n);return t},agent:t.agent}),e=this,delete this.get,delete this.put,delete this.delete,delete this.options;const i=this.fetch;this.fetch=function(r){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return"string"!==typeof r||r.startsWith("/")||(r=`${t.url}/${r}`),i.call(e,r,u(n,{method:"POST"}))}}}a.HTTPError},39541:(e,t,r)=>{"use strict";r.d(t,{X:()=>o});var n=r(15059),s=r(13068);function o(){let{arg:e,searchParams:t,hashAlg:r,mtime:o,mode:i,...a}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};t&&(a={...a,...t}),r&&(a.hash=r),null!=o&&(o=(0,s.X)(o),a.mtime=o.secs,a.mtimeNsecs=o.nsecs),null!=i&&(a.mode=(0,n.Q)(i)),a.timeout&&!isNaN(a.timeout)&&(a.timeout=`${a.timeout}ms`),void 0===e||null===e?e=[]:Array.isArray(e)||(e=[e]);const c=new URLSearchParams(a);return e.forEach((e=>c.append("arg",e))),c}},38099:(e,t,r)=>{"use strict";r.r(t),r.d(t,{InvalidValueError:()=>i,MissingRepoOptionsError:()=>a,NonReversibleMigrationError:()=>n,NotInitializedRepoError:()=>s,RequiredParameterError:()=>o});class n extends Error{constructor(e){super(e),this.name="NonReversibleMigrationError",this.code=n.code,this.message=e}}n.code="ERR_NON_REVERSIBLE_MIGRATION";class s extends Error{constructor(e){super(e),this.name="NotInitializedRepoError",this.code=s.code,this.message=e}}s.code="ERR_NOT_INITIALIZED_REPO";class o extends Error{constructor(e){super(e),this.name="RequiredParameterError",this.code=o.code,this.message=e}}o.code="ERR_REQUIRED_PARAMETER";class i extends Error{constructor(e){super(e),this.name="InvalidValueError",this.code=i.code,this.message=e}}i.code="ERR_INVALID_VALUE";class a extends Error{constructor(e){super(e),this.name="MissingRepoOptionsError",this.code=a.code,this.message=e}}a.code="ERR_MISSING_REPO_OPTIONS"},61757:(e,t,r)=>{"use strict";r.d(t,{fR:()=>o,pf:()=>l,s0:()=>a,xW:()=>i});var n=r(82149),s=r(66957);const o=new n.Key("/config"),i=new n.Key("/version");function a(e){let t=e;for(;t.db||t.child;)if(t=t.db||t.child,"level-js"===t.type||"Level"===t.constructor.name)return t}function c(e){const t=e.get.bind(e),r=e.has.bind(e);return e.get=n=>async function(e,t,r,n){if(await r(e))return t(e);const o=a(n);if(!o)throw(0,s.notFoundError)();return new Promise(((t,r)=>{const n=o.store("readonly").get(e.toString());n.transaction.onabort=()=>{r(n.transaction.error)},n.transaction.oncomplete=()=>{if(n.result)return t(n.result);r((0,s.notFoundError)())}}))}(n,t,r,e),e.has=t=>async function(e,t,r){const n=await t(e);if(n)return n;const s=a(r);return!!s&&new Promise(((t,r)=>{const n=s.store("readonly").get(e.toString());n.transaction.onabort=()=>{r(n.transaction.error)},n.transaction.oncomplete=()=>{t(Boolean(n.result))}}))}(t,r,e),e}function l(e){return{...e,root:c(e.root),datastore:c(e.datastore),pins:c(e.pins),keys:c(e.keys)}}},48206:(e,t,r)=>{"use strict";r.d(t,{BE:()=>d,HN:()=>c,OY:()=>l});var n=r(15504),s=r(32743),o=r(23887),i=r(16586);const a=e=>{if(e instanceof Uint8Array)return{cid:s.CID.decode(e),toResolve:[]};const t=s.CID.asCID(e);if(t)return{cid:t,toResolve:[]};if("string"===typeof e){0===e.indexOf("/ipfs/")&&(e=e.substring(6));const t=function(){return((arguments.length>0&&void 0!==arguments[0]?arguments[0]:"").trim().match(/([^\\^/]|\\\/)+/g)||[]).filter(Boolean)}(e);return{cid:s.CID.parse(t[0]),toResolve:t.slice(1)}}throw n(new Error(`Unknown path type ${e}`),"ERR_BAD_PATH")};async function*c(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},{cid:s,toResolve:i}=a(e),c=s.toString(),l=c;const d=i.length;for(;;){const a=await(0,o.Z)(s,c,l,i,d,t,r);if(!a.entry&&!a.next)throw n(new Error(`Could not resolve ${e}`),"ERR_NOT_FOUND");if(a.entry&&(yield a.entry),!a.next)return;i=a.next.toResolve,s=a.next.cid,c=a.next.name,l=a.next.path}}async function l(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=await i(c(e,t,r));if(!s)throw n(new Error(`Could not resolve ${e}`),"ERR_NOT_FOUND");return s}async function*d(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const n=await l(e,t,r);if(n&&(yield n,"directory"===n.type))for await(const o of s(n,r))yield o;async function*s(e,t){for await(const r of e.content(t))yield r,r instanceof Uint8Array||"directory"===r.type&&(yield*s(r,t))}}},46224:(e,t,r)=>{"use strict";r.d(t,{Z:()=>a});var n=r(88411),s=r(22580),o=r(45711),i=r(49067);async function*a(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=(0,s.Z)(r);let c,l,d;c="function"===typeof r.dagBuilder?r.dagBuilder:o.Z,l="function"===typeof r.treeBuilder?r.treeBuilder:i.Z,d=Symbol.asyncIterator in e||Symbol.iterator in e?e:[e];for await(const s of l(n(c(d,t,a),a.fileImportConcurrency),t,a))yield{cid:s.cid,path:s.path,unixfs:s.unixfs,size:s.size}}},5724:(e,t,r)=>{"use strict";r.d(t,{Xu:()=>d,fL:()=>h,tK:()=>l});var n=r(15504);const s=r(46766).Vw,o=["raw","directory","file","metadata","symlink","hamt-sharded-directory"],i=["directory","hamt-sharded-directory"],a=parseInt("0644",8),c=parseInt("0755",8);function l(e){if(null!=e)return"number"===typeof e?4095&e:"0"===(e=e.toString()).substring(0,1)?4095&parseInt(e,8):4095&parseInt(e,10)}function d(e){if(null==e)return;let t;if(null!=e.secs&&(t={secs:e.secs,nsecs:e.nsecs}),null!=e.Seconds&&(t={secs:e.Seconds,nsecs:e.FractionalNanoseconds}),Array.isArray(e)&&(t={secs:e[0],nsecs:e[1]}),e instanceof Date){const r=e.getTime(),n=Math.floor(r/1e3);t={secs:n,nsecs:1e3*(r-1e3*n)}}if(Object.prototype.hasOwnProperty.call(t,"secs")){if(null!=t&&null!=t.nsecs&&(t.nsecs<0||t.nsecs>999999999))throw n(new Error("mtime-nsecs must be within the range [0,999999999]"),"ERR_INVALID_MTIME_NSECS");return t}}class h{static unmarshal(e){const t=s.decode(e),r=s.toObject(t,{defaults:!1,arrays:!0,longs:Number,objects:!1}),n=new h({type:o[r.Type],data:r.Data,blockSizes:r.blocksizes,mode:r.mode,mtime:r.mtime?{secs:r.mtime.Seconds,nsecs:r.mtime.FractionalNanoseconds}:void 0});return n._originalMode=r.mode||0,n}constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{type:"file"};const{type:t,data:r,blockSizes:s,hashType:i,fanout:a,mtime:c,mode:h}=e;if(t&&!o.includes(t))throw n(new Error("Type: "+t+" is not valid"),"ERR_INVALID_TYPE");this.type=t||"file",this.data=r,this.hashType=i,this.fanout=a,this.blockSizes=s||[],this._originalMode=0,this.mode=l(h),c&&(this.mtime=d(c),this.mtime&&!this.mtime.nsecs&&(this.mtime.nsecs=0))}set mode(e){this._mode=this.isDirectory()?c:a;const t=l(e);void 0!==t&&(this._mode=t)}get mode(){return this._mode}isDirectory(){return Boolean(this.type&&i.includes(this.type))}addBlockSize(e){this.blockSizes.push(e)}removeBlockSize(e){this.blockSizes.splice(e,1)}fileSize(){if(this.isDirectory())return 0;let e=0;return this.blockSizes.forEach((t=>{e+=t})),this.data&&(e+=this.data.length),e}marshal(){let e;switch(this.type){case"raw":e=s.DataType.Raw;break;case"directory":e=s.DataType.Directory;break;case"file":e=s.DataType.File;break;case"metadata":e=s.DataType.Metadata;break;case"symlink":e=s.DataType.Symlink;break;case"hamt-sharded-directory":e=s.DataType.HAMTShard;break;default:throw n(new Error("Type: "+e+" is not valid"),"ERR_INVALID_TYPE")}let t,r,o=this.data;if(this.data&&this.data.length||(o=void 0),null!=this.mode&&(t=4294963200&this._originalMode|(l(this.mode)||0),t!==a||this.isDirectory()||(t=void 0),t===c&&this.isDirectory()&&(t=void 0)),null!=this.mtime){const e=d(this.mtime);e&&(r={Seconds:e.secs,FractionalNanoseconds:e.nsecs},0===r.FractionalNanoseconds&&delete r.FractionalNanoseconds)}const i={Type:e,Data:o,filesize:this.isDirectory()?void 0:this.fileSize(),blocksizes:this.blockSizes,hashType:this.hashType,fanout:this.fanout,mode:t,mtime:r};return s.encode(i).finish()}}},664:(e,t,r)=>{"use strict";r.d(t,{Z:()=>n});const n=r(47250)},71659:(e,t,r)=>{"use strict";r.r(t),r.d(t,{base36:()=>s,base36upper:()=>o});var n=r(17384);const s=(0,n.kU)({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),o=(0,n.kU)({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"})},43019:(e,t,r)=>{"use strict";r.r(t),r.d(t,{base58btc:()=>s,base58flickr:()=>o});var n=r(17384);const s=(0,n.kU)({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),o=(0,n.kU)({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"})},40963:(e,t,r)=>{"use strict";r.d(t,{QB:()=>m,gh:()=>y,kq:()=>w});var n=r(17527),s=r(14906),o=r(90247),i=r(86955),a=r(2180),c=r(79357),l=r(71659),d=r(43019),h=r(63225),u=r(92829),p=r(80073),f=r(96602),g=r(39928);r(28546);const y={...n,...s,...o,...i,...a,...c,...l,...d,...h},w={...u,...p},m={raw:f,json:g}},80073:(e,t,r)=>{"use strict";r.r(t),r.d(t,{identity:()=>i});var n=r(17893),s=r(17578);const o=n.coerce,i={code:0,name:"identity",encode:o,digest:e=>s.create(0,o(e))}},92829:(e,t,r)=>{"use strict";r.r(t),r.d(t,{sha256:()=>o,sha512:()=>i});var n=r(32616);const s=e=>async t=>new Uint8Array(await crypto.subtle.digest(e,t)),o=(0,n.D)({name:"sha2-256",code:18,encode:s("SHA-256")}),i=(0,n.D)({name:"sha2-512",code:19,encode:s("SHA-512")})},73620:(e,t,r)=>{"use strict";r.d(t,{Z:()=>i});let n=/(-?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*([\p{L}]*)/giu;function s(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"ms";var r=null;return e=(e+"").replace(/(\d)[,_](\d)/g,"$1$2"),e.replace(n,(function(e,t,n){(n=o(n))&&(r=(r||0)+parseFloat(t,10)*n)})),r&&r/(o(t)||1)}function o(e){return s[e]||s[e.toLowerCase().replace(/s$/,"")]}s.nanosecond=s.ns=1e-6,s["\xb5s"]=s["\u03bcs"]=s.us=s.microsecond=.001,s.millisecond=s.ms=s[""]=1,s.second=s.sec=s.s=1e3*s.ms,s.minute=s.min=s.m=60*s.s,s.hour=s.hr=s.h=60*s.m,s.day=s.d=24*s.h,s.week=s.wk=s.w=7*s.d,s.month=s.b=30.4375*s.d,s.year=s.yr=s.y=365.25*s.d;const i=s},68425:(e,t,r)=>{"use strict";r.r(t),r.d(t,{fromString:()=>s});var n=r(71124);function s(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf8";const r=n.Z[t];if(!r)throw new Error(`Unsupported encoding "${t}"`);return r.decoder.decode(`${r.prefix}${e}`)}},93314:(e,t,r)=>{"use strict";r.r(t),r.d(t,{toString:()=>s});var n=r(71124);function s(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf8";const r=n.Z[t];if(!r)throw new Error(`Unsupported encoding "${t}"`);return r.encoder.encode(e).substring(1)}}}]);
//# sourceMappingURL=398.94cd9c00.chunk.js.map