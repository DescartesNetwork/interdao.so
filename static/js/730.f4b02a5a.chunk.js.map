{"version":3,"file":"static/js/730.f4b02a5a.chunk.js","mappings":"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","sources":["os/configs/sol.config.ts","os/configs/register.config.ts","os/configs/stat.config.ts","os/configs/index.ts","os/store/mints.reducer.ts","os/view/wallet/lib/cloverWallet.ts","os/view/wallet/lib/coin98Wallet.ts","os/view/wallet/lib/guestWallet.ts","os/view/wallet/lib/phantomWallet.ts","os/view/wallet/lib/secretkeyWallet.ts","os/view/wallet/lib/slopeWallet.ts","os/view/wallet/lib/solflareExtWallet.ts","os/view/wallet/lib/solflareWebWallet.ts","os/view/wallet/lib/solletWebWallet.ts","shared/pdb/index.ts","shared/pdb/ipfs.ts"],"sourcesContent":["import { Net } from 'shared/runtime'\n\nconst SOLVARS = {\n  spltAddress: 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  splataAddress: 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',\n}\n\n/**\n * Contructor\n */\ntype Conf = {\n  node: string\n  sntrAddress: string\n  sntrPoolAddress: string\n  swapAddress: string\n  taxmanAddress: string\n} & typeof SOLVARS\n\nconst conf: Record<Net, Conf> = {\n  /**\n   * Development configurations\n   */\n  devnet: {\n    ...SOLVARS,\n    node: 'https://api.devnet.solana.com',\n    sntrAddress: '5YwUkPdXLoujGkZuo9B4LsLKj3hdkDcfP4derpspifSJ',\n    sntrPoolAddress: '3EUPL7YQLbU6DNU5LZeQeHPXTf1MigJ2yASXA9rH5Ku4',\n    swapAddress: '4erFSLP7oBFSVC1t35jdxmbfxEhYCKfoM6XdG2BLR3UF',\n    taxmanAddress: '8UaZw2jDhJzv5V53569JbCd3bD4BnyCfBH3sjwgajGS9',\n  },\n\n  /**\n   * Staging configurations\n   */\n  testnet: {\n    ...SOLVARS,\n    node: 'https://api.testnet.solana.com',\n    sntrAddress: '',\n    sntrPoolAddress: '',\n    swapAddress: '',\n    taxmanAddress: '',\n  },\n\n  /**\n   * Production configurations\n   */\n  mainnet: {\n    ...SOLVARS,\n    node: 'https://sentre.genesysgo.net',\n    sntrAddress: 'SENBBKVCM7homnf5RX9zqpf1GFe935hnbU4uVzY1Y6M',\n    sntrPoolAddress: 'Aa3WZX7Xunfebp2MuAcz9CNw8TYTDL7mVrmb11rjyVm6',\n    swapAddress: 'SSW7ooZ1EbEognq5GosbygA3uWW1Hq1NsFq6TsftCFV',\n    taxmanAddress: '9doo2HZQEmh2NgfT3Yx12M89aoBheycYqH1eaR5gKb3e',\n  },\n}\n\n/**\n * Module exports\n */\nexport default conf\n","import { Env } from 'shared/runtime'\n\nif (\n  typeof process.env.REACT_APP_ID !== 'string' ||\n  typeof process.env.REACT_APP_NAME !== 'string' ||\n  typeof process.env.REACT_APP_URL !== 'string'\n)\n  throw new Error(\n    'Please add REACT_APP_ID, REACT_APP_NAME, REACT_APP_URL in .env.local!',\n  )\n\n/**\n * Contructor\n */\n\ntype Conf = {\n  defaultAppId: string\n  extra: SenReg\n  senreg: string\n}\n\nconst DEFAULT_APP_ID = process.env.REACT_APP_ID\nconst devApp = {\n  [DEFAULT_APP_ID]: {\n    url: process.env.REACT_APP_URL,\n    appId: DEFAULT_APP_ID,\n    name: process.env.REACT_APP_NAME,\n    author: {\n      name: process.env.REACT_APP_AUTHOR_NAME || '',\n      email: process.env.REACT_APP_AUTHOR_EMAIL || '',\n    },\n    tags: (process.env.REACT_APP_TAGS || '')\n      .split(',')\n      .map((tag) => tag.trim()),\n    description: process.env.REACT_APP_DESCRIPTION || '',\n    verified: false,\n  },\n}\n\nconst conf: Record<Env, Conf> = {\n  /**\n   * Development configurations\n   */\n  development: {\n    defaultAppId: DEFAULT_APP_ID,\n    extra: devApp,\n    senreg: 'https://descartesnetwork.github.io/senreg/register.json',\n  },\n\n  /**\n   * Staging configurations\n   */\n  staging: {\n    defaultAppId: DEFAULT_APP_ID,\n    extra: devApp,\n    senreg: 'https://descartesnetwork.github.io/senreg/register.json',\n  },\n\n  /**\n   * Production configurations\n   */\n  production: {\n    defaultAppId: DEFAULT_APP_ID,\n    extra: {},\n    senreg: 'https://descartesnetwork.github.io/senreg/register.json',\n  },\n}\n\n/**\n * Module exports\n */\nexport default conf\n","import { Net } from 'shared/runtime'\n\n/**\n * Contructor\n */\ntype Config = {\n  baseURL: string\n}\n\nconst config: Record<Net, Config> = {\n  /**\n   * Development configurations\n   */\n  devnet: {\n    baseURL: 'https://stat-dev.sentre.io',\n  },\n\n  /**\n   * Staging configurations\n   */\n  testnet: {\n    baseURL: 'https://stat-dev.sentre.io',\n  },\n\n  /**\n   * Production configurations\n   */\n  mainnet: {\n    baseURL: 'https://stat.sentre.io',\n  },\n}\n\n/**\n * Module exports\n */\nexport default config\n","import { net, env } from 'shared/runtime'\nimport sol from './sol.config'\nimport register from './register.config'\nimport stat from './stat.config'\n\nconst configs = {\n  sol: sol[net],\n  register: register[env],\n  stat: stat[net],\n}\n\n/**\n * Module exports\n */\nexport default configs\n","import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'\nimport { account, MintData } from '@senswap/sen-js'\n\n/**\n * Interface & Utility\n */\n\nexport type MintsState = Record<string, MintData>\n\n/**\n * Store constructor\n */\n\nconst NAME = 'mints'\nconst initialState: MintsState = {}\n\n/**\n * Actions\n */\n\nexport const getMint = createAsyncThunk<\n  MintsState,\n  { address: string; force?: boolean },\n  { state: any }\n>(`${NAME}/getMint`, async ({ address, force = false }, { getState }) => {\n  if (!account.isAddress(address)) throw new Error('Invalid mint address')\n  if (!force) {\n    const {\n      accounts: { [address]: data },\n    } = getState()\n    if (data) return { [address]: data }\n  }\n  const { splt } = window.sentre\n  const raw = await splt.getMintData(address)\n  return { [address]: raw }\n})\n\nexport const upsetMint = createAsyncThunk<\n  MintsState,\n  { address: string; data: MintData },\n  { state: any }\n>(`${NAME}/upsetMint`, async ({ address, data }) => {\n  if (!account.isAddress(address)) throw new Error('Invalid address')\n  if (!data) throw new Error('Data is empty')\n  return { [address]: data }\n})\n\nexport const deleteMint = createAsyncThunk(\n  `${NAME}/deleteMint`,\n  async ({ address }: { address: string }) => {\n    if (!account.isAddress(address)) throw new Error('Invalid address')\n    return { address }\n  },\n)\n\n/**\n * Usual procedure\n */\n\nconst slice = createSlice({\n  name: NAME,\n  initialState,\n  reducers: {},\n  extraReducers: (builder) =>\n    void builder\n      .addCase(\n        getMint.fulfilled,\n        (state, { payload }) => void Object.assign(state, payload),\n      )\n      .addCase(\n        upsetMint.fulfilled,\n        (state, { payload }) => void Object.assign(state, payload),\n      )\n      .addCase(\n        deleteMint.fulfilled,\n        (state, { payload }) => void delete state[payload.address],\n      ),\n})\n\nexport default slice.reducer\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, Signature, SignedMessage } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\n\nclass CloverWallet extends BaseWallet {\n  constructor() {\n    super('Clover')\n  }\n\n  getProvider = async () => {\n    const { clover_solana } = window\n    if (!clover_solana?.isCloverWallet)\n      throw new Error('Wallet is not connected')\n    return clover_solana\n  }\n\n  getAddress = async () => {\n    const provider = await this.getProvider()\n    const address = await provider.getAccount()\n    if (!account.isAddress(address))\n      throw new Error('There is no Solana account')\n    return address\n  }\n\n  rawSignTransaction = async (transaction: Transaction) => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transaction.feePayer = publicKey\n    const { signature } = await provider.signTransaction(transaction)\n    return { publicKey, signature } as Signature\n  }\n\n  signMessage = async (message: string) => {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.signMessage(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default CloverWallet\n","import { Transaction } from '@solana/web3.js'\nimport { account, Signature, SignedMessage } from '@senswap/sen-js'\nimport { decode } from 'bs58'\n\nimport BaseWallet from './baseWallet'\n\n\nclass Coin98Wallet extends BaseWallet {\n  constructor() {\n    super('Coin98')\n  }\n\n  getProvider = async () => {\n    const { sol } = window?.coin98 || {}\n    if (!sol) throw new Error('Wallet is not connected')\n    return sol\n  }\n\n  getAddress = async () => {\n    const provider = await this.getProvider()\n    const [address] = (await provider.request({ method: 'sol_accounts' })) || []\n    if (!account.isAddress(address))\n      throw new Error('There is no Solana account')\n    return address\n  }\n\n  rawSignTransaction = async (transaction: Transaction) => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transaction.feePayer = publicKey\n    const { signature: sig } = await provider.request({\n      method: 'sol_sign',\n      params: [transaction],\n    })\n    const signature = decode(sig)\n    return { publicKey, signature } as Signature\n  }\n\n  signMessage = async (message: string) => {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const data = await provider.request({\n      method: 'sol_sign',\n      params: [message],\n    })\n    return data as SignedMessage\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    address = address || (await this.getAddress())\n    const valid = await account.verifySignature(address, signature, message)\n    return valid as boolean\n  }\n}\n\nexport default Coin98Wallet\n","import { Transaction } from '@solana/web3.js'\nimport { Provider } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\n\nexport const GUEST_ADDRESS = 'GuestAccount11111111111111111111111111111111'\n\ntype ExpanedProvider = Provider & { address: string }\n\nclass GuestWallet extends BaseWallet {\n  constructor(callback: () => void = () => {}) {\n    super('Guest')\n\n    this._callback = callback\n  }\n\n  private _callback = () => {}\n  private _error = () => {\n    throw new Error(\n      'You are in the Guest Mode. Please connect your personal wallet to proceed the action.',\n    )\n  }\n\n  getProvider = async (): Promise<ExpanedProvider> => {\n    const provider = {\n      address: GUEST_ADDRESS,\n      disconnect: () => {},\n    }\n    return provider\n  }\n\n  getAddress = async () => {\n    const { address } = await this.getProvider()\n    return address\n  }\n\n  rawSignTransaction = async (transaction: Transaction) => {\n    await this._callback()\n    return this._error()\n  }\n\n  signMessage = async (message: string) => {\n    await this._callback()\n    return this._error()\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    await this._callback()\n    return this._error()\n  }\n}\n\nexport default GuestWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, Signature, SignedMessage } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\n\nclass PhantomWallet extends BaseWallet {\n  constructor() {\n    super('Phantom')\n  }\n\n  getProvider = async () => {\n    const { solana } = window\n    if (!solana?.isPhantom) throw new Error('Wallet is not connected')\n    if (solana.isConnected) return solana\n    solana.connect()\n    return await new Promise((resolve) =>\n      solana.on('connect', () => resolve(solana)),\n    )\n  }\n\n  getAddress = async () => {\n    const provider = await this.getProvider()\n    const address = provider.publicKey.toString()\n    if (!account.isAddress(address))\n      throw new Error('There is no Solana account')\n    return address\n  }\n\n  rawSignTransaction = async (transaction: Transaction) => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transaction.feePayer = publicKey\n    const { signature } = await provider.signTransaction(transaction)\n    return { publicKey, signature } as Signature\n  }\n\n  signMessage = async (message: string) => {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.signMessage(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default PhantomWallet\n","import { Transaction, Keypair } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, Provider, Signature } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\nimport session from 'shared/session'\n\ntype ExpanedProvider = Provider & { keypair: Keypair }\n\nclass SecretKeyWallet extends BaseWallet {\n  constructor(secretKey: string) {\n    super('SecretKey')\n\n    this._setSecretKey(secretKey)\n  }\n\n  private _setSecretKey = (secretKey: string): void => {\n    if (!secretKey) throw new Error('Invalid secret key')\n    session.set('SecretKey', secretKey)\n  }\n\n  getProvider = async (): Promise<ExpanedProvider> => {\n    const secretKey = session.get('SecretKey')\n    const keypair = account.fromSecretKey(secretKey)\n    if (!keypair) throw new Error('Cannot get the keystore-based provider')\n    const provider = {\n      keypair,\n      disconnect: () => session.clear('SecretKey'),\n    }\n    return provider\n  }\n\n  getAddress = async () => {\n    const { keypair } = await this.getProvider()\n    return keypair.publicKey.toBase58()\n  }\n\n  rawSignTransaction = async (transaction: Transaction) => {\n    const confirmed = window.confirm('Please confirm to sign the transaction!')\n    if (!confirmed) throw new Error('User rejects to sign the transaction')\n    const { keypair } = await this.getProvider()\n    const signData = transaction.serializeMessage()\n    const publicKey = keypair.publicKey\n    const signature = nacl.sign.detached(signData, keypair.secretKey)\n    return { publicKey, signature } as Signature\n  }\n\n  signMessage = async (message: string) => {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const confirmed = window.confirm(\n      `Please confirm to sign the message! Message: ${message}`,\n    )\n    if (!confirmed) throw new Error('User rejects to sign the message')\n    const { keypair } = await this.getProvider()\n    const secretKey = Buffer.from(keypair.secretKey).toString('hex')\n    const data = account.signMessage(message, secretKey)\n    return { ...data }\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    address = address || (await this.getAddress())\n    const valid = account.verifySignature(address, signature, message)\n    return valid as boolean\n  }\n}\n\nexport default SecretKeyWallet\n","import { Transaction, PublicKey } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, Signature } from '@senswap/sen-js'\nimport { decode, encode } from 'bs58'\n\nimport BaseWallet from './baseWallet'\n\nclass SlopeWallet extends BaseWallet {\n  private provider: any\n  constructor() {\n    super('Slope')\n    this.provider = null\n  }\n\n  getProvider = async () => {\n    const { Slope } = window || {}\n    if (!Slope) throw new Error('Cannot connect to Slope')\n    if (this.provider) return this.provider\n    this.provider = new Slope()\n    await this.provider.connect()\n    return this.provider\n  }\n\n  getAddress = async () => {\n    const provider = await this.getProvider()\n    const { data } = await provider.connect()\n    if (!data.publicKey) throw new Error('Wallet is not connected')\n    return data.publicKey\n  }\n\n  rawSignTransaction = async (transaction: Transaction) => {\n    const provider = await this.getProvider()\n    const message = encode(transaction.serializeMessage())\n    const { msg, data } = await provider.signTransaction(message)\n\n    if (!data.publicKey) throw new Error(msg)\n    const publicKey = new PublicKey(data.publicKey)\n    const signature = decode(data.signature)\n\n    return { publicKey, signature } as Signature\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    const slopeAddress = address || (await this.getAddress())\n    const publicKey = account.fromAddress(slopeAddress)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default SlopeWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, Signature, SignedMessage } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\n\nclass SolflareExtWallet extends BaseWallet {\n  constructor() {\n    super('SolflareExtension')\n  }\n\n  getProvider = async () => {\n    const { solflare } = window\n    if (!solflare.isSolflare) throw new Error('Wallet is not connected')\n    if (solflare.isConnected) return solflare\n    solflare.connect()\n    return await new Promise((resolve) =>\n      solflare.on('connect', () => resolve(solflare)),\n    )\n  }\n\n  getAddress = async () => {\n    const provider = await this.getProvider()\n    const address = provider.publicKey.toString()\n    if (!account.isAddress(address))\n      throw new Error('There is no Solana account')\n    return address\n  }\n\n  rawSignTransaction = async (transaction: Transaction) => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transaction.feePayer = publicKey\n    const { signature } = await provider.signTransaction(transaction)\n    return { publicKey, signature } as Signature\n  }\n\n  signMessage = async (message: string) => {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.signMessage(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default SolflareExtWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, Provider, Signature, SignedMessage } from '@senswap/sen-js'\nimport WalletAdapter from '@project-serum/sol-wallet-adapter'\n\nimport BaseWallet from './baseWallet'\nimport configs from 'os/configs'\n\nconst PROVIDER_URL = 'https://solflare.com/provider'\n\nclass SolflareWebWallet extends BaseWallet {\n  private provider: WalletAdapter & Provider\n\n  constructor() {\n    super('SolflareWeb')\n\n    const {\n      sol: { node },\n    } = configs\n    this.provider = new WalletAdapter(PROVIDER_URL, node)\n  }\n\n  getProvider = async () => {\n    if (!this.provider.connected) await this.provider.connect()\n    return this.provider\n  }\n\n  getAddress = async () => {\n    const provider = await this.getProvider()\n    if (!provider.publicKey) throw new Error('Cannot connect to Solflare')\n    return provider.publicKey.toBase58()\n  }\n\n  rawSignTransaction = async (transaction: Transaction) => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transaction.feePayer = publicKey\n    const { signature } = await provider.signTransaction(transaction)\n    return { publicKey, signature } as Signature\n  }\n\n  signMessage = async (message: string) => {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.sign(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default SolflareWebWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, Provider, Signature, SignedMessage } from '@senswap/sen-js'\nimport WalletAdapter from '@project-serum/sol-wallet-adapter'\n\nimport BaseWallet from './baseWallet'\nimport configs from 'os/configs'\n\nconst PROVIDER_URL = 'https://www.sollet.io'\n\nclass SolletWallet extends BaseWallet {\n  private provider: WalletAdapter & Provider\n\n  constructor() {\n    super('SolletWeb')\n\n    const {\n      sol: { node },\n    } = configs\n    this.provider = new WalletAdapter(PROVIDER_URL, node)\n  }\n\n  getProvider = async () => {\n    if (!this.provider.connected) await this.provider.connect()\n    return this.provider\n  }\n\n  getAddress = async () => {\n    const provider = await this.getProvider()\n    if (!provider.publicKey) throw new Error('Cannot connect to Sollet Web')\n    return provider.publicKey.toBase58()\n  }\n\n  rawSignTransaction = async (transaction: Transaction) => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transaction.feePayer = publicKey\n    const { signature } = await provider.signTransaction(transaction)\n    return { publicKey, signature } as Signature\n  }\n\n  signMessage = async (message: string) => {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.sign(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default SolletWallet\n","import localForage from 'localforage'\nimport { account } from '@senswap/sen-js'\nimport IPFS from './ipfs'\n\n/**\n * Persistent Database\n */\nclass PDB {\n  readonly dbName: string\n  private driver: any\n  private ipfs: IPFS\n\n  constructor(walletAddress: string) {\n    if (!account.isAddress(walletAddress)) throw new Error('Invalid address')\n    this.dbName = walletAddress\n    this.driver = [localForage.WEBSQL, localForage.LOCALSTORAGE]\n    this.ipfs = new IPFS()\n  }\n\n  /**\n   * Local\n   */\n\n  createInstance = (appId: string): LocalForage => {\n    return localForage.createInstance({\n      driver: this.driver,\n      name: this.dbName,\n      storeName: appId,\n    })\n  }\n\n  dropInstance = async (appId: string): Promise<void> => {\n    const instance = this.createInstance(appId)\n    await instance.clear()\n    return await localForage.dropInstance({\n      name: this.dbName,\n      storeName: appId,\n    })\n  }\n\n  all = async (): Promise<any> => {\n    let data: any = {}\n    const appIds = (\n      ((await this.createInstance('sentre').getItem('appIds')) as string[]) ||\n      []\n    )\n      .flat()\n      .concat(['sentre'])\n    for (const appId of appIds) {\n      data[appId] = {}\n      const instance = this.createInstance(appId)\n      await instance.iterate((value: string, key: string) => {\n        data[appId][key] = value\n      })\n    }\n    return data\n  }\n\n  /**\n   * Cloud\n   */\n\n  fetch = async (cid: string) => {\n    return await this.ipfs.get(cid)\n  }\n\n  backup = async () => {\n    const data = await this.all()\n    return await this.ipfs.set(data)\n  }\n\n  restore = async (cid: string) => {\n    // Download data\n    const data = await this.fetch(cid)\n    // Apply to storage\n    for (const appId in data) {\n      const instance = await this.createInstance(appId)\n      for (const key in data[appId]) {\n        const value = data[appId][key]\n        await instance.setItem(key, value)\n      }\n    }\n    return data\n  }\n}\n\nexport default PDB\n\n/**\n * High abtraction pdb for app\n */\nexport const createPDB = (walletArress: string, appId: string) => {\n  return account.isAddress(walletArress)\n    ? new PDB(walletArress).createInstance(appId)\n    : undefined\n}\n","import { create, isIPFS } from 'ipfs-core'\nimport { asyncWait } from 'shared/util'\n\nclass IPFS {\n  private _ipfs: any = async () => {\n    try {\n      if (!window.ipfs) window.ipfs = await create()\n      return window.ipfs\n    } catch (er) {\n      await asyncWait(500)\n      return await this._ipfs()\n    }\n  }\n\n  static isCID = (cid: string | undefined | null): boolean => {\n    try {\n      if (!cid) return false\n      return isIPFS.multihash(cid)\n    } catch (er) {\n      return false\n    }\n  }\n\n  get = async (cid: string) => {\n    if (!IPFS.isCID(cid)) throw new Error('Invalid CID')\n    const ipfs = await this._ipfs()\n    const stream = await ipfs.cat(cid)\n    let raw = ''\n    for await (const chunk of stream) raw += Buffer.from(chunk).toString()\n    const data = JSON.parse(raw)\n    return data\n  }\n\n  set = async (data: object): Promise<string> => {\n    if (!data) throw new Error('Empty data')\n    const raw = JSON.stringify(data)\n    const ipfs = await this._ipfs()\n    const { path: cid } = await ipfs.add(raw)\n    return cid as string\n  }\n}\n\nexport default IPFS\n"],"names":["SOLVARS","spltAddress","splataAddress","devnet","node","sntrAddress","sntrPoolAddress","swapAddress","taxmanAddress","testnet","mainnet","DEFAULT_APP_ID","process","devApp","url","appId","name","author","email","tags","split","map","tag","trim","description","verified","development","defaultAppId","extra","senreg","staging","production","baseURL","sol","net","register","env","stat","NAME","getMint","createAsyncThunk","async","address","force","getState","account","Error","accounts","data","splt","window","sentre","getMintData","upsetMint","deleteMint","createSlice","initialState","reducers","extraReducers","builder","addCase","fulfilled","state","payload","Object","assign","CloverWallet","BaseWallet","constructor","super","getProvider","clover_solana","isCloverWallet","getAddress","provider","this","getAccount","rawSignTransaction","publicKey","transaction","feePayer","signature","signTransaction","signMessage","message","encodedMsg","TextEncoder","encode","sig","Buffer","from","toString","verifySignature","bufSig","nacl","toBuffer","Coin98Wallet","coin98","request","method","params","decode","GuestWallet","callback","_callback","_error","disconnect","PhantomWallet","solana","isPhantom","isConnected","connect","Promise","resolve","on","SecretKeyWallet","secretKey","_setSecretKey","session","keypair","toBase58","confirm","signData","serializeMessage","SlopeWallet","Slope","msg","PublicKey","slopeAddress","SolflareExtWallet","solflare","isSolflare","SolflareWebWallet","connected","sign","configs","WalletAdapter","SolletWallet","PDB","walletAddress","dbName","driver","ipfs","createInstance","localForage","storeName","dropInstance","instance","clear","all","appIds","getItem","flat","concat","iterate","value","key","fetch","get","cid","backup","set","restore","setItem","IPFS","_ipfs","create","er","asyncWait","isCID","stream","cat","raw","chunk","JSON","parse","stringify","path","add","isIPFS"],"sourceRoot":""}